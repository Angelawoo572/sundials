! This file was automatically generated by SWIG (http://www.swig.org).
! Version 4.0.0
!
! Do not make changes to this file unless you know what you are doing--modify
! the SWIG interface file instead.
module fnvector
 use, intrinsic :: ISO_C_BINDING
 use fsundials_types
 implicit none
 private

 ! PUBLIC METHODS AND TYPES
 public :: N_Vector_ID, SUNDIALS_NVEC_SERIAL, SUNDIALS_NVEC_PARALLEL, SUNDIALS_NVEC_OPENMP, SUNDIALS_NVEC_PTHREADS, &
    SUNDIALS_NVEC_PARHYP, SUNDIALS_NVEC_PETSC, SUNDIALS_NVEC_CUDA, SUNDIALS_NVEC_RAJA, SUNDIALS_NVEC_OPENMPDEV, &
    SUNDIALS_NVEC_TRILINOS, SUNDIALS_NVEC_CUSTOM
 public :: N_VGetVectorID
 public :: N_VClone
 public :: N_VCloneEmpty
 public :: N_VDestroy
 public :: N_VSpace
 public :: N_VGetArrayPointer
 public :: N_VSetArrayPointer
 public :: N_VLinearSum
 public :: N_VConst
 public :: N_VProd
 public :: N_VDiv
 public :: N_VScale
 public :: N_VAbs
 public :: N_VInv
 public :: N_VAddConst
 public :: N_VDotProd
 public :: N_VMaxNorm
 public :: N_VWrmsNorm
 public :: N_VWrmsNormMask
 public :: N_VMin
 public :: N_VWL2Norm
 public :: N_VL1Norm
 public :: N_VCompare
 public :: N_VInvTest
 public :: N_VConstrMask
 public :: N_VMinQuotient
 public :: N_VLinearCombination
 public :: N_VScaleAddMulti
 public :: N_VDotProdMulti
 public :: N_VLinearSumVectorArray
 public :: N_VScaleVectorArray
 public :: N_VConstVectorArray
 public :: N_VWrmsNormVectorArray
 public :: N_VWrmsNormMaskVectorArray
 public :: N_VScaleAddMultiVectorArray
 public :: N_VLinearCombinationVectorArray
 public :: N_VCloneEmptyVectorArray
 public :: N_VCloneVectorArray
 public :: N_VDestroyVectorArray

 ! PARAMETERS
 enum, bind(c)
  enumerator :: N_Vector_ID = -1
  enumerator :: SUNDIALS_NVEC_SERIAL = 0
  enumerator :: SUNDIALS_NVEC_PARALLEL = SUNDIALS_NVEC_SERIAL + 1
  enumerator :: SUNDIALS_NVEC_OPENMP = SUNDIALS_NVEC_PARALLEL + 1
  enumerator :: SUNDIALS_NVEC_PTHREADS = SUNDIALS_NVEC_OPENMP + 1
  enumerator :: SUNDIALS_NVEC_PARHYP = SUNDIALS_NVEC_PTHREADS + 1
  enumerator :: SUNDIALS_NVEC_PETSC = SUNDIALS_NVEC_PARHYP + 1
  enumerator :: SUNDIALS_NVEC_CUDA = SUNDIALS_NVEC_PETSC + 1
  enumerator :: SUNDIALS_NVEC_RAJA = SUNDIALS_NVEC_CUDA + 1
  enumerator :: SUNDIALS_NVEC_OPENMPDEV = SUNDIALS_NVEC_RAJA + 1
  enumerator :: SUNDIALS_NVEC_TRILINOS = SUNDIALS_NVEC_OPENMPDEV + 1
  enumerator :: SUNDIALS_NVEC_CUSTOM = SUNDIALS_NVEC_TRILINOS + 1
 end enum

 ! WRAPPER DECLARATIONS
 interface
function N_VGetVectorID(w) &
bind(C, name="N_VGetVectorID") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: w
integer(C_INT) :: fresult
end function

function N_VClone(w) &
bind(C, name="N_VClone") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: w
type(C_PTR) :: fresult
end function

function N_VCloneEmpty(w) &
bind(C, name="N_VCloneEmpty") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: w
type(C_PTR) :: fresult
end function

subroutine N_VDestroy(v) &
bind(C, name="N_VDestroy")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
end subroutine

subroutine N_VSpace(v, lrw, liw) &
bind(C, name="N_VSpace")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
integer(C_INT64_T) :: lrw
integer(C_INT64_T) :: liw
end subroutine

function N_VGetArrayPointer(v) &
bind(C, name="N_VGetArrayPointer") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
type(C_PTR) :: fresult
end function

subroutine N_VSetArrayPointer(v_data, v) &
bind(C, name="N_VSetArrayPointer")
use, intrinsic :: ISO_C_BINDING
real(C_DOUBLE) :: v_data
type(C_PTR), value :: v
end subroutine

subroutine N_VLinearSum(a, x, b, y, z) &
bind(C, name="N_VLinearSum")
use, intrinsic :: ISO_C_BINDING
real(C_DOUBLE), value :: a
type(C_PTR), value :: x
real(C_DOUBLE), value :: b
type(C_PTR), value :: y
type(C_PTR), value :: z
end subroutine

subroutine N_VConst(c, z) &
bind(C, name="N_VConst")
use, intrinsic :: ISO_C_BINDING
real(C_DOUBLE), value :: c
type(C_PTR), value :: z
end subroutine

subroutine N_VProd(x, y, z) &
bind(C, name="N_VProd")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: y
type(C_PTR), value :: z
end subroutine

subroutine N_VDiv(x, y, z) &
bind(C, name="N_VDiv")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: y
type(C_PTR), value :: z
end subroutine

subroutine N_VScale(c, x, z) &
bind(C, name="N_VScale")
use, intrinsic :: ISO_C_BINDING
real(C_DOUBLE), value :: c
type(C_PTR), value :: x
type(C_PTR), value :: z
end subroutine

subroutine N_VAbs(x, z) &
bind(C, name="N_VAbs")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: z
end subroutine

subroutine N_VInv(x, z) &
bind(C, name="N_VInv")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: z
end subroutine

subroutine N_VAddConst(x, b, z) &
bind(C, name="N_VAddConst")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
real(C_DOUBLE), value :: b
type(C_PTR), value :: z
end subroutine

function N_VDotProd(x, y) &
bind(C, name="N_VDotProd") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: y
real(C_DOUBLE) :: fresult
end function

function N_VMaxNorm(x) &
bind(C, name="N_VMaxNorm") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
real(C_DOUBLE) :: fresult
end function

function N_VWrmsNorm(x, w) &
bind(C, name="N_VWrmsNorm") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: w
real(C_DOUBLE) :: fresult
end function

function N_VWrmsNormMask(x, w, id) &
bind(C, name="N_VWrmsNormMask") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: w
type(C_PTR), value :: id
real(C_DOUBLE) :: fresult
end function

function N_VMin(x) &
bind(C, name="N_VMin") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
real(C_DOUBLE) :: fresult
end function

function N_VWL2Norm(x, w) &
bind(C, name="N_VWL2Norm") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: w
real(C_DOUBLE) :: fresult
end function

function N_VL1Norm(x) &
bind(C, name="N_VL1Norm") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
real(C_DOUBLE) :: fresult
end function

subroutine N_VCompare(c, x, z) &
bind(C, name="N_VCompare")
use, intrinsic :: ISO_C_BINDING
real(C_DOUBLE), value :: c
type(C_PTR), value :: x
type(C_PTR), value :: z
end subroutine

function N_VInvTest(x, z) &
bind(C, name="N_VInvTest") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: z
logical(C_BOOL) :: fresult
end function

function N_VConstrMask(c, x, m) &
bind(C, name="N_VConstrMask") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: c
type(C_PTR), value :: x
type(C_PTR), value :: m
logical(C_BOOL) :: fresult
end function

function N_VMinQuotient(num, denom) &
bind(C, name="N_VMinQuotient") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: num
type(C_PTR), value :: denom
real(C_DOUBLE) :: fresult
end function

function N_VLinearCombination(nvec, c, x, z) &
bind(C, name="N_VLinearCombination") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
real(C_DOUBLE) :: c
type(C_PTR), value :: x
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function N_VScaleAddMulti(nvec, a, x, y, z) &
bind(C, name="N_VScaleAddMulti") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
real(C_DOUBLE) :: a
type(C_PTR), value :: x
type(C_PTR), value :: y
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function N_VDotProdMulti(nvec, x, y, dotprods) &
bind(C, name="N_VDotProdMulti") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
type(C_PTR), value :: x
type(C_PTR), value :: y
real(C_DOUBLE) :: dotprods
integer(C_INT) :: fresult
end function

function N_VLinearSumVectorArray(nvec, a, x, b, y, z) &
bind(C, name="N_VLinearSumVectorArray") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
real(C_DOUBLE), value :: a
type(C_PTR), value :: x
real(C_DOUBLE), value :: b
type(C_PTR), value :: y
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function N_VScaleVectorArray(nvec, c, x, z) &
bind(C, name="N_VScaleVectorArray") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
real(C_DOUBLE) :: c
type(C_PTR), value :: x
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function N_VConstVectorArray(nvec, c, z) &
bind(C, name="N_VConstVectorArray") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
real(C_DOUBLE), value :: c
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function N_VWrmsNormVectorArray(nvec, x, w, nrm) &
bind(C, name="N_VWrmsNormVectorArray") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
type(C_PTR), value :: x
type(C_PTR), value :: w
real(C_DOUBLE) :: nrm
integer(C_INT) :: fresult
end function

function N_VWrmsNormMaskVectorArray(nvec, x, w, id, nrm) &
bind(C, name="N_VWrmsNormMaskVectorArray") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
type(C_PTR), value :: x
type(C_PTR), value :: w
type(C_PTR), value :: id
real(C_DOUBLE) :: nrm
integer(C_INT) :: fresult
end function

function N_VScaleAddMultiVectorArray(nvec, nsum, a, x, y, z) &
bind(C, name="N_VScaleAddMultiVectorArray") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
integer(C_INT), value :: nsum
real(C_DOUBLE) :: a
type(C_PTR), value :: x
type(C_PTR), value :: y
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function N_VLinearCombinationVectorArray(nvec, nsum, c, x, z) &
bind(C, name="N_VLinearCombinationVectorArray") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
integer(C_INT), value :: nsum
real(C_DOUBLE) :: c
type(C_PTR), value :: x
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function N_VCloneEmptyVectorArray(count, w) &
bind(C, name="N_VCloneEmptyVectorArray") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: count
type(C_PTR), value :: w
type(C_PTR) :: fresult
end function

function N_VCloneVectorArray(count, w) &
bind(C, name="N_VCloneVectorArray") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: count
type(C_PTR), value :: w
type(C_PTR) :: fresult
end function

subroutine N_VDestroyVectorArray(vs, count) &
bind(C, name="N_VDestroyVectorArray")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: vs
integer(C_INT), value :: count
end subroutine

 end interface


end module
