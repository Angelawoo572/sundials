! This file was automatically generated by SWIG (http://www.swig.org).
! Version 4.0.0
!
! Do not make changes to this file unless you know what you are doing--modify
! the SWIG interface file instead.
module fnvector_pthreads_mod
 use, intrinsic :: ISO_C_BINDING
 use fsundials_types
 use fnvector_mod
 implicit none
 private

 ! PUBLIC METHODS AND TYPES

  public :: FN_VGetData_Pthreads
  
 public :: FN_VNew_Pthreads
 public :: FN_VNewEmpty_Pthreads
 public :: FN_VMake_Pthreads
 public :: FN_VCloneVectorArray_Pthreads
 public :: FN_VCloneVectorArrayEmpty_Pthreads
 public :: FN_VDestroyVectorArray_Pthreads
 public :: FN_VGetLength_Pthreads
 public :: FN_VPrint_Pthreads
 public :: FN_VPrintFile_Pthreads
 public :: FN_VGetVectorID_Pthreads
 public :: FN_VCloneEmpty_Pthreads
 public :: FN_VClone_Pthreads
 public :: FN_VDestroy_Pthreads
 public :: FN_VSpace_Pthreads
 public :: FN_VGetArrayPointer_Pthreads
 public :: FN_VSetArrayPointer_Pthreads
 public :: FN_VLinearSum_Pthreads
 public :: FN_VConst_Pthreads
 public :: FN_VProd_Pthreads
 public :: FN_VDiv_Pthreads
 public :: FN_VScale_Pthreads
 public :: FN_VAbs_Pthreads
 public :: FN_VInv_Pthreads
 public :: FN_VAddConst_Pthreads
 public :: FN_VDotProd_Pthreads
 public :: FN_VMaxNorm_Pthreads
 public :: FN_VWrmsNorm_Pthreads
 public :: FN_VWrmsNormMask_Pthreads
 public :: FN_VMin_Pthreads
 public :: FN_VWL2Norm_Pthreads
 public :: FN_VL1Norm_Pthreads
 public :: FN_VCompare_Pthreads
 public :: FN_VInvTest_Pthreads
 public :: FN_VConstrMask_Pthreads
 public :: FN_VMinQuotient_Pthreads
 public :: FN_VLinearCombination_Pthreads
 public :: FN_VScaleAddMulti_Pthreads
 public :: FN_VDotProdMulti_Pthreads
 public :: FN_VLinearSumVectorArray_Pthreads
 public :: FN_VScaleVectorArray_Pthreads
 public :: FN_VConstVectorArray_Pthreads
 public :: FN_VWrmsNormVectorArray_Pthreads
 public :: FN_VWrmsNormMaskVectorArray_Pthreads
 public :: FN_VScaleAddMultiVectorArray_Pthreads
 public :: FN_VLinearCombinationVectorArray_Pthreads
 public :: FN_VEnableFusedOps_Pthreads
 public :: FN_VEnableLinearCombination_Pthreads
 public :: FN_VEnableScaleAddMulti_Pthreads
 public :: FN_VEnableDotProdMulti_Pthreads
 public :: FN_VEnableLinearSumVectorArray_Pthreads
 public :: FN_VEnableScaleVectorArray_Pthreads
 public :: FN_VEnableConstVectorArray_Pthreads
 public :: FN_VEnableWrmsNormVectorArray_Pthreads
 public :: FN_VEnableWrmsNormMaskVectorArray_Pthreads
 public :: FN_VEnableScaleAddMultiVectorArray_Pthreads
 public :: FN_VEnableLinearCombinationVectorArray_Pthreads

 ! WRAPPER DECLARATIONS
 interface
function FN_VNew_Pthreads(vec_length, n_threads) &
bind(C, name="N_VNew_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT64_T), value :: vec_length
integer(C_INT), value :: n_threads
type(C_PTR) :: fresult
end function

function FN_VNewEmpty_Pthreads(vec_length, n_threads) &
bind(C, name="N_VNewEmpty_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT64_T), value :: vec_length
integer(C_INT), value :: n_threads
type(C_PTR) :: fresult
end function

function FN_VMake_Pthreads(vec_length, n_threads, v_data) &
bind(C, name="N_VMake_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT64_T), value :: vec_length
integer(C_INT), value :: n_threads
real(C_DOUBLE), dimension(*) :: v_data
type(C_PTR) :: fresult
end function

function FN_VCloneVectorArray_Pthreads(count, w) &
bind(C, name="N_VCloneVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: count
type(C_PTR), value :: w
type(C_PTR) :: fresult
end function

function FN_VCloneVectorArrayEmpty_Pthreads(count, w) &
bind(C, name="N_VCloneVectorArrayEmpty_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: count
type(C_PTR), value :: w
type(C_PTR) :: fresult
end function

subroutine FN_VDestroyVectorArray_Pthreads(vs, count) &
bind(C, name="N_VDestroyVectorArray_Pthreads")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: vs
integer(C_INT), value :: count
end subroutine

function FN_VGetLength_Pthreads(v) &
bind(C, name="N_VGetLength_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
integer(C_INT64_T) :: fresult
end function

subroutine FN_VPrint_Pthreads(v) &
bind(C, name="N_VPrint_Pthreads")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
end subroutine

subroutine FN_VPrintFile_Pthreads(v, outfile) &
bind(C, name="N_VPrintFile_Pthreads")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
type(C_PTR), value :: outfile
end subroutine

function FN_VGetVectorID_Pthreads(v) &
bind(C, name="N_VGetVectorID_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
integer(C_INT) :: fresult
end function

function FN_VCloneEmpty_Pthreads(w) &
bind(C, name="N_VCloneEmpty_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: w
type(C_PTR) :: fresult
end function

function FN_VClone_Pthreads(w) &
bind(C, name="N_VClone_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: w
type(C_PTR) :: fresult
end function

subroutine FN_VDestroy_Pthreads(v) &
bind(C, name="N_VDestroy_Pthreads")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
end subroutine

subroutine FN_VSpace_Pthreads(v, lrw, liw) &
bind(C, name="N_VSpace_Pthreads")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
integer(C_INT64_T) :: lrw
integer(C_INT64_T) :: liw
end subroutine

function FN_VGetArrayPointer_Pthreads(v) &
bind(C, name="N_VGetArrayPointer_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
type(C_PTR) :: fresult
end function

subroutine FN_VSetArrayPointer_Pthreads(v_data, v) &
bind(C, name="N_VSetArrayPointer_Pthreads")
use, intrinsic :: ISO_C_BINDING
real(C_DOUBLE), dimension(*) :: v_data
type(C_PTR), value :: v
end subroutine

subroutine FN_VLinearSum_Pthreads(a, x, b, y, z) &
bind(C, name="N_VLinearSum_Pthreads")
use, intrinsic :: ISO_C_BINDING
real(C_DOUBLE), value :: a
type(C_PTR), value :: x
real(C_DOUBLE), value :: b
type(C_PTR), value :: y
type(C_PTR), value :: z
end subroutine

subroutine FN_VConst_Pthreads(c, z) &
bind(C, name="N_VConst_Pthreads")
use, intrinsic :: ISO_C_BINDING
real(C_DOUBLE), value :: c
type(C_PTR), value :: z
end subroutine

subroutine FN_VProd_Pthreads(x, y, z) &
bind(C, name="N_VProd_Pthreads")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: y
type(C_PTR), value :: z
end subroutine

subroutine FN_VDiv_Pthreads(x, y, z) &
bind(C, name="N_VDiv_Pthreads")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: y
type(C_PTR), value :: z
end subroutine

subroutine FN_VScale_Pthreads(c, x, z) &
bind(C, name="N_VScale_Pthreads")
use, intrinsic :: ISO_C_BINDING
real(C_DOUBLE), value :: c
type(C_PTR), value :: x
type(C_PTR), value :: z
end subroutine

subroutine FN_VAbs_Pthreads(x, z) &
bind(C, name="N_VAbs_Pthreads")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: z
end subroutine

subroutine FN_VInv_Pthreads(x, z) &
bind(C, name="N_VInv_Pthreads")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: z
end subroutine

subroutine FN_VAddConst_Pthreads(x, b, z) &
bind(C, name="N_VAddConst_Pthreads")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
real(C_DOUBLE), value :: b
type(C_PTR), value :: z
end subroutine

function FN_VDotProd_Pthreads(x, y) &
bind(C, name="N_VDotProd_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: y
real(C_DOUBLE) :: fresult
end function

function FN_VMaxNorm_Pthreads(x) &
bind(C, name="N_VMaxNorm_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
real(C_DOUBLE) :: fresult
end function

function FN_VWrmsNorm_Pthreads(x, w) &
bind(C, name="N_VWrmsNorm_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: w
real(C_DOUBLE) :: fresult
end function

function FN_VWrmsNormMask_Pthreads(x, w, id) &
bind(C, name="N_VWrmsNormMask_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: w
type(C_PTR), value :: id
real(C_DOUBLE) :: fresult
end function

function FN_VMin_Pthreads(x) &
bind(C, name="N_VMin_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
real(C_DOUBLE) :: fresult
end function

function FN_VWL2Norm_Pthreads(x, w) &
bind(C, name="N_VWL2Norm_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: w
real(C_DOUBLE) :: fresult
end function

function FN_VL1Norm_Pthreads(x) &
bind(C, name="N_VL1Norm_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
real(C_DOUBLE) :: fresult
end function

subroutine FN_VCompare_Pthreads(c, x, z) &
bind(C, name="N_VCompare_Pthreads")
use, intrinsic :: ISO_C_BINDING
real(C_DOUBLE), value :: c
type(C_PTR), value :: x
type(C_PTR), value :: z
end subroutine

function FN_VInvTest_Pthreads(x, z) &
bind(C, name="N_VInvTest_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: x
type(C_PTR), value :: z
logical(C_BOOL) :: fresult
end function

function FN_VConstrMask_Pthreads(c, x, m) &
bind(C, name="N_VConstrMask_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: c
type(C_PTR), value :: x
type(C_PTR), value :: m
logical(C_BOOL) :: fresult
end function

function FN_VMinQuotient_Pthreads(num, denom) &
bind(C, name="N_VMinQuotient_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: num
type(C_PTR), value :: denom
real(C_DOUBLE) :: fresult
end function

function FN_VLinearCombination_Pthreads(nvec, c, x, z) &
bind(C, name="N_VLinearCombination_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
real(C_DOUBLE) :: c
type(C_PTR), value :: x
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function FN_VScaleAddMulti_Pthreads(nvec, a, x, y, z) &
bind(C, name="N_VScaleAddMulti_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
real(C_DOUBLE) :: a
type(C_PTR), value :: x
type(C_PTR), value :: y
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function FN_VDotProdMulti_Pthreads(nvec, x, y, dotprods) &
bind(C, name="N_VDotProdMulti_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
type(C_PTR), value :: x
type(C_PTR), value :: y
real(C_DOUBLE) :: dotprods
integer(C_INT) :: fresult
end function

function FN_VLinearSumVectorArray_Pthreads(nvec, a, x, b, y, z) &
bind(C, name="N_VLinearSumVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
real(C_DOUBLE), value :: a
type(C_PTR), value :: x
real(C_DOUBLE), value :: b
type(C_PTR), value :: y
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function FN_VScaleVectorArray_Pthreads(nvec, c, x, z) &
bind(C, name="N_VScaleVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
real(C_DOUBLE) :: c
type(C_PTR), value :: x
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function FN_VConstVectorArray_Pthreads(nvec, c, z) &
bind(C, name="N_VConstVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
real(C_DOUBLE), value :: c
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function FN_VWrmsNormVectorArray_Pthreads(nvec, x, w, nrm) &
bind(C, name="N_VWrmsNormVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
type(C_PTR), value :: x
type(C_PTR), value :: w
real(C_DOUBLE) :: nrm
integer(C_INT) :: fresult
end function

function FN_VWrmsNormMaskVectorArray_Pthreads(nvec, x, w, id, nrm) &
bind(C, name="N_VWrmsNormMaskVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
type(C_PTR), value :: x
type(C_PTR), value :: w
type(C_PTR), value :: id
real(C_DOUBLE) :: nrm
integer(C_INT) :: fresult
end function

function FN_VScaleAddMultiVectorArray_Pthreads(nvec, nsum, a, x, y, z) &
bind(C, name="N_VScaleAddMultiVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
integer(C_INT), value :: nsum
real(C_DOUBLE) :: a
type(C_PTR), value :: x
type(C_PTR), value :: y
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function FN_VLinearCombinationVectorArray_Pthreads(nvec, nsum, c, x, z) &
bind(C, name="N_VLinearCombinationVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: nvec
integer(C_INT), value :: nsum
real(C_DOUBLE) :: c
type(C_PTR), value :: x
type(C_PTR), value :: z
integer(C_INT) :: fresult
end function

function FN_VEnableFusedOps_Pthreads(v, tf) &
bind(C, name="N_VEnableFusedOps_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
logical(C_BOOL), value :: tf
integer(C_INT) :: fresult
end function

function FN_VEnableLinearCombination_Pthreads(v, tf) &
bind(C, name="N_VEnableLinearCombination_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
logical(C_BOOL), value :: tf
integer(C_INT) :: fresult
end function

function FN_VEnableScaleAddMulti_Pthreads(v, tf) &
bind(C, name="N_VEnableScaleAddMulti_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
logical(C_BOOL), value :: tf
integer(C_INT) :: fresult
end function

function FN_VEnableDotProdMulti_Pthreads(v, tf) &
bind(C, name="N_VEnableDotProdMulti_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
logical(C_BOOL), value :: tf
integer(C_INT) :: fresult
end function

function FN_VEnableLinearSumVectorArray_Pthreads(v, tf) &
bind(C, name="N_VEnableLinearSumVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
logical(C_BOOL), value :: tf
integer(C_INT) :: fresult
end function

function FN_VEnableScaleVectorArray_Pthreads(v, tf) &
bind(C, name="N_VEnableScaleVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
logical(C_BOOL), value :: tf
integer(C_INT) :: fresult
end function

function FN_VEnableConstVectorArray_Pthreads(v, tf) &
bind(C, name="N_VEnableConstVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
logical(C_BOOL), value :: tf
integer(C_INT) :: fresult
end function

function FN_VEnableWrmsNormVectorArray_Pthreads(v, tf) &
bind(C, name="N_VEnableWrmsNormVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
logical(C_BOOL), value :: tf
integer(C_INT) :: fresult
end function

function FN_VEnableWrmsNormMaskVectorArray_Pthreads(v, tf) &
bind(C, name="N_VEnableWrmsNormMaskVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
logical(C_BOOL), value :: tf
integer(C_INT) :: fresult
end function

function FN_VEnableScaleAddMultiVectorArray_Pthreads(v, tf) &
bind(C, name="N_VEnableScaleAddMultiVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
logical(C_BOOL), value :: tf
integer(C_INT) :: fresult
end function

function FN_VEnableLinearCombinationVectorArray_Pthreads(v, tf) &
bind(C, name="N_VEnableLinearCombinationVectorArray_Pthreads") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: v
logical(C_BOOL), value :: tf
integer(C_INT) :: fresult
end function

 end interface


contains
 ! FORTRAN PROXY CODE

  subroutine FN_VGetData_Pthreads(vec, vdata)

      use, intrinsic :: iso_c_binding
      implicit none

      type(C_PTR)        :: vec
      integer(C_INT64_T) :: len
      type(C_PTR)        :: cptr
      real(C_DOUBLE), dimension(:), pointer :: vdata

      len = FN_VGetLength_Pthreads(vec)
      cptr = FN_VGetArrayPointer_Pthreads(vec)

      call c_f_pointer(cptr, vdata, (/len/))

  end subroutine FN_VGetData_Pthreads
  

end module
