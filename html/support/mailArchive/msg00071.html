<!-- MHonArc v2.6.10 -->
<!--X-Subject: Re: Enforcing a minimum time step -->
<!--X-From-R13: Dnqh Ereona <freona1Nyyay.tbi> -->
<!--X-Date: Fri, 10 Jun 2005 10:21:14 &#45;0700 (PDT) -->
<!--X-Message-Id: 42A9CB68.9010402@llnl.gov -->
<!--X-Content-Type: multipart/mixed -->
<!--X-Reference: opsoj9h0y0t8lo91@smtp.kuleuven.ac.be -->
<!--X-Reference: 424D80AE.4060907@llnl.gov -->
<!--X-Head-End-->
<html>
<head>
<title>Re: Enforcing a minimum time step</title>
<meta name="author" content="Radu Serban">
<meta name="description" content="suite of nonlinear differential algebraic equation solvers">
<meta name="keywords" content="SUNDIALS, CVODE, CVODES, IDA, KINSOL">
<meta name="keywords" content="ODE, DAE, sensitivity">
<meta name="keywords" content="differential, algebraic">
<link REL="SHORTCUT ICON" HREF="img/favicon.ico" type="image/x-icon">
<link REL="ICON" HREF="img/favicon.ico" type="image/x-icon">
<link href="../../sundials_styles.css" rel="stylesheet" type="text/css">
<script language="JavaScript">
<!--
homeon = new Image();           homeon.src = "../../graphics/home_buttonH.png";
homeoff = new Image();          homeoff.src = "../../graphics/home_button.png";
descriptionon = new Image();    descriptionon.src = "../../graphics/description_buttonH.png";
descriptionoff = new Image();   descriptionoff.src = "../../graphics/description_button.png";
documentationon = new Image();  documentationon.src = "../../graphics/documentation_buttonH.png";
documentationoff = new Image(); documentationoff.src = "../../graphics/documentation_button.png";
downloadon = new Image();       downloadon.src = "../../graphics/download_buttonH.png";
downloadoff = new Image();      downloadoff.src = "../../graphics/download_button.png";
supporton = new Image();        supporton.src = "../../graphics/support_buttonH.png";
supportoff = new Image();       supportoff.src = "../../graphics/support_button.png";
//-->
</script>
<script src="../../sunjs.js" type="text/javascript" language="javascript1.2"></script>
</head>
<!-- ******************************************************************************** -->
<body>
<table width="100%" height="100%" border="0" cellpadding="0" cellspacing="0">
  <tr valign="top">
  <td height="60" background="../../graphics/table_bck1.gif"><img src="../../graphics/table_bck1.gif" width="5" height="60"></td>
  <td width="116"><img SRC="../../graphics/head_top_left.png" height="60" width="116" border="0"></td>
  <td width="720"><img SRC="../../graphics/head_mail_top_right.png" height="60" width="720" border="0"></td>
  <td background="../../graphics/table_bck1.gif"><img src="../../graphics/table_bck1.gif" width="5" height="60"></td>
  </tr>
  <tr valign="top">
  <td height="127" background="../../graphics/table_bck2.gif"><img src="../../graphics/table_bck2.gif" width="5" height="127"></td>
  <td width="116">
    <a href="../../main.html" onMouseOver="img_act('home'); return true;" onMouseOut="img_inact('home'); return true;"><img src="../../graphics/home_button.png" border="0" name="home"></a><br>
    <a href="../../description/description.html" onMouseOver="img_act('description'); return true;" onMouseOut="img_inact('description'); return true;"><img src="../../graphics/description_button.png" border="0" name="description"></a><br>
    <a href="../../documentation/documentation.html" onMouseOver="img_act('documentation'); return true;" onMouseOut="img_inact('documentation'); return true;"><img src="../../graphics/documentation_button.png" border="0" name="documentation"></a><br>
    <a href="../../download/download.html" onMouseOver="img_act('download'); return true;" onMouseOut="img_inact('download'); return true;"><img src="../../graphics/download_button.png" border="0" name="download"></a><br>
    <a href="../../support/support.html" onMouseOver="img_act('support'); return true;" onMouseOut="img_inact('support'); return true;"><img src="../../graphics/support_button.png" border="0" name="support"></a><br>
    <img SRC="../../graphics/line_tl.gif" height="7" width="116" border="0"></td>
  <td width="720">
      <img SRC="../../graphics/head_bottom_right.png" height="120" width="720" border="0"><br>
      <img SRC="../../graphics/line_tr.gif" height="7" width="720" border="0"></td>
  <td background="../../graphics/table_bck2.gif"><img src="../../graphics/table_bck2.gif" width="5" height="127"></td>
  </tr>
  <tr valign="top">
  <td background="../../graphics/table_bck3.gif"></td>
  <td width="116" valign="bottom" align="center" background="../../graphics/table_bck5.gif"><img SRC="../../graphics/logo.png" border="0"></td>
  <td width="720" bgcolor="#ffffff">
  <div id="content">   
<!-- Start content for this page -->
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<p class="links">
[<a href="msg00070.html">Date Prev</a>] [<a href="msg00072.html">Date Next</a>] [<a href="msg00035.html">Thread Prev</a>] [<a href="msg00036.html">Thread Next</a>]<br>
[<b><a href="maillist.html#00071">Date Index</a></b>]
[<b><a href="threads.html#00071">Thread Index</a></b>]
</p>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Enforcing a minimum time step</h1>
<div class="frame">
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<table border=0 cellpadding=2 cellspacing=0>
<tr>
<td align="right"><b>
<em>From</em></b></td>
<td align="left">
Radu Serban &lt;<a href="mailto:serban1%40llnl.gov">serban1@llnl.gov</a>&gt;</td>
</tr>

<tr>
<td align="right"><b>
<em>Date</em></b></td>
<td align="left">
Fri, 10 Jun 2005 10:18:32 -0700</td>
</tr>

</table>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
</div>
<div class="container">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<tt>Since another user has asked the same question, I thought I'll share an example on how tolerances can be controlled in 
order to enforce a minimum step size.</tt><br>
<br>
<pre style="margin: 0em;">The attached file (cvdx1.c) is a modification of the cvdx CVODE/CVODES example:</pre><br>
<tt>- When HMIN is reached (CV_ERR_FAILURE or CV_CONV_FAILURE return from CVode), looser tolerances are estimated such that 
the solver can proceed with order 1 without the step size going below HMIN.<br>
- The absolute tolerance estimates are based on the current value of y'' (see comments for function loosen_tol).<br>
- While proceeding with looser tolerances, we check for sufficient increase in the step size and, when it reaches 
H_FACT*HMIN, we tighten the tolerances back to their original values and reset the maximum order to 5 (BDF).<br>
- Note that one could tighten the tolerances in stages and continue with backward Euler until the tolerances reached 
their original values.</tt><br>
<br>
<tt>See the comments in cvdx1.c for more details on the absolute tolerance control strategy. Note that cvdx1 uses CVODES. To 
use it with CVODE, just replace<br>
#include &quot;cvodes.h&quot;<br>
with<br>
#include &quot;cvode.h&quot;</tt><br>
<br>
<tt>IMPORTANT: Unfortunately, the current implementation of CVodeSetMaxOrd in CVODE/CVODES does not allow an increase in the 
maximum order. This is a limitation that we have already removed in the development version. Until the next release, you 
can just comment out the test<br>
if (maxord &gt; qmax) {<br>
...<br>
}<br>
in the function CVodeSetMaxOrd (files cvodeio.c and cvodesio.c in CVODE and CVODES, respectively). However, make sure 
you never increase the maximum order beyond the value it had whenever CVodeMalloc was called (the default values for 
qmax are 12 and 5 for Adams and BDF, respectively).</tt><br>
<br>
<pre style="margin: 0em;">I hope this example is helpful.</pre><br>
<pre style="margin: 0em;">Cheers,
--Radu</pre><br>
<pre style="margin: 0em;">--
   Radu Serban
   Center for Applied Scientific Computing   [email] radu@llnl.gov
   Lawrence Livermore National Laboratory    [phone] 925-424-4852
   P.O. Box 808, L-560                       [fax]   925-422-6287
   Livermore, CA 94551</pre><br>
<tt>Radu Serban wrote:
</tt><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">Hi Andreas,</pre><br>
<tt>Although CVODE has an option for setting a minimum value for the step 
size (CVodeSetMinStep), this will not help your problem. The hmin value 
in CVODE has a role opposite to what you want: you can look at it as a 
mechanism for stopping the integrator when accuracy requirements would 
drive the step size below the prescribed limit.</tt><br>
<br>
<tt>CVODE strives to satisfy first the tolerance requirements and not 
limitations on step size.</tt><br>
<br>
<tt>The answer to your problem is hidden in your question itself! You say 
that in such regions, you are willing to accept a loss of accuracy. Then 
you should just use looser tolerances in that region and then tighten 
them back after you're past the tough spot. You can change tolerances 
between calls to CVode without having to restart it by using the 
CVodeSetTolerances function (you can also change directly the variables 
that you used to pass tolerances to CVodeMalloc, since CVODE stores them 
by reference and not value. However, I am currently working on changes 
to the code that will not allow this anymore, for different reasons, and 
when the new codes will be released -- probably in a week or so -- this 
option will not be available anymore).</tt><br>
<br>
<tt>Of course, to do this you'd have to call CVode in ONE_STEP mode. If you 
do not know beforehand where these tough regions are, you should be able 
to detect them by specifying minimum and maximum step sizes and by 
monitoring the CVODE solver statistics and/or return values.</tt><br>
<br>
<pre style="margin: 0em;">--Radu</pre><br>
<pre style="margin: 0em;">Andreas Nicolai wrote:</pre><br>
<blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">Hi there,</pre><br>
<tt>before using CVODE I was writing single-step, implicit solvers with 
variable time steps. And depending on the convergence criteria the 
time step could get very small. However, in order not to break out the 
solution I enforced a minimum time step (accepting the reduction in 
accuracy).</tt><br>
<br>
<tt>Can this be done with CVODE as well? I mean, force the solver to go on 
even if he can't converge at a certain time step which would normally 
cause him to slow down?</tt><br>
<br>
<pre style="margin: 0em;">Thanks for any suggestions!
Bye - Andreas</pre><br>
<pre style="margin: 0em;"><br></pre><br>
</blockquote><br>
</blockquote><pre>/*
 * -----------------------------------------------------------------
 * $Revision: 1.1 $
 * $Date: 2006-01-06 19:15:40 $
 * -----------------------------------------------------------------
 * Programmer(s): Radu Serban @ LLNL
 * -----------------------------------------------------------------
 * Modification of the cvdx example to illustrate enforcing a 
 * minimum step size.
 *
 * When HMIN is reached (CV_ERR_FAILURE or CV_CONV_FAILURE return 
 * from CVode), looser tolerances are estimated such that the solver
 * can proceed with order 1 without the step size going below HMIN.
 * The absolute tolerance estimates are based on the current value 
 * of y'' (see comments for function loosen_tol).
 * While proceeding with looser tolerances, we check for sufficient
 * increase in the step size and when it reaches H_FACT*HMIN we 
 * tighten the tolerances back to their original values and reset
 * the maximum order to 5 (BDF).
 * Note that one could tighten the tolerances in stages and continue
 * with backward Euler until the tolerances reached their original
 * values.
 *
 * For readibility, no checks are performed on the various function
 * return flags.
 * -----------------------------------------------------------------
 */

#include &lt;stdio.h&gt;
#include &quot;sundialstypes.h&quot;
#include &quot;cvodes.h&quot;
#include &quot;cvdense.h&quot;
#include &quot;nvector_serial.h&quot;

/* User-defined vector and matrix accessor macros: Ith, IJth */
#define Ith(v,i)    NV_Ith_S(v,i-1)
#define IJth(A,i,j) DENSE_ELEM(A,i-1,j-1)

/* Problem Constants */
#define NEQ   3
#define Y1    RCONST(1.0)
#define Y2    RCONST(0.0)
#define Y3    RCONST(0.0)
#define RTOL  RCONST(1.0e-4)
#define ATOL1 RCONST(1.0e-10)
#define ATOL2 RCONST(1.0e-14)
#define ATOL3 RCONST(1.0e-10)
#define T0    RCONST(0.0)
#define TOUT1 RCONST(0.4)
#define TOUT2 RCONST(400.0)

#define HMIN   RCONST(1.0e-2)
#define H_FACT RCONST(50.0)
#define A_FACT RCONST(10.0)

#define TIGHT 1
#define LOOSE 2

/* Type : UserData */
typedef struct {
  realtype p[3];        /* Problem parameters */
  N_Vector yp, yy, yyp; /* Temporary space    */
} *UserData;

/* Functions called by the solver */
static void f(realtype t, N_Vector y, N_Vector ydot, void *f_data);
static void Jac(long int N, DenseMat J, realtype t,
                N_Vector y, N_Vector fy, void *jac_data,
                N_Vector tmp1, N_Vector tmp2, N_Vector tmp3);

/* Private functions */
static UserData set_data();
static void free_data(UserData data);
static realtype loosen_tol(void *cvode_mem, realtype t, N_Vector y, 
                           UserData data, N_Vector atolL);
static void PrintOutput(void *cvode_mem, realtype t, realtype y1, realtype y2, 
realtype y3);
static void PrintSolverStats(void *cvode_mem);

/*
 *-------------------------------
 * Main Program
 *-------------------------------
 */

int main()
{
  UserData data;
  realtype reltol, t, hu, alpha;
  N_Vector y, atolT, atolL;
  void *cvode_mem;
  int flag, mode;

  /* Allocate and initialize user data structure */
  data = set_data();

  /* Create serial vector of length NEQ for I.C., atolT, and atolL */
  y = N_VNew_Serial(NEQ);
  atolT = N_VNew_Serial(NEQ); 
  atolL = N_VNew_Serial(NEQ);

  /* Initialize y */
  Ith(y,1) = Y1;
  Ith(y,2) = Y2;
  Ith(y,3) = Y3;

  /* Set the scalar relative tolerance and vector absolute tolerance */
  reltol = RTOL;
  Ith(atolT,1) = ATOL1;
  Ith(atolT,2) = ATOL2;
  Ith(atolT,3) = ATOL3;

  /* Call CVodeCreate and CVodeMalloc */
  cvode_mem = CVodeCreate(CV_BDF, CV_NEWTON);
  flag = CVodeMalloc(cvode_mem, f, T0, y, CV_SV, reltol, atolT);
  flag = CVodeSetFdata(cvode_mem, data);

  /* Use the CVDENSE dense linear solver with user-supplied Jacobian */
  flag = CVDense(cvode_mem, NEQ);
  flag = CVDenseSetJacFn(cvode_mem, Jac, data);

  /* Integrate to TOUT1 in NORMAL_MODE */
  flag = CVode(cvode_mem, TOUT1, y, &amp;t, CV_NORMAL);
  PrintOutput(cvode_mem, t, Ith(y,1), Ith(y,2), Ith(y,3));

  /* Now set a minimum step size */
  printf(&quot;\nEnforce minimum step\n\n&quot;);
  flag = CVodeSetMinStep(cvode_mem, HMIN);

  flag = CVodeSetErrFile(cvode_mem, NULL);

  /* Continue to TOUT2 in ONE_STEP mode, while controlling tolerances
     to enforce the desired minimum step size */

  mode = TIGHT;

  while(t &lt; TOUT2) {

    flag = CVode(cvode_mem, TOUT2, y, &amp;t, CV_ONE_STEP);
    
    /* Test if the solver tries to go below HMIN */
    if (flag == CV_ERR_FAILURE || flag == CV_CONV_FAILURE) {
      PrintSolverStats(cvode_mem);
      /* Estimate relaxed tolerances */
      alpha = loosen_tol(cvode_mem, t, y, data, atolL);
      printf(&quot;Loosen tolerances:  alpha = %14.6le\n\n&quot;, alpha);
      /* Enforce backward Euler */
      CVodeSetMaxOrd(cvode_mem, 1);
      /* Reinitialize solver with loose tolerances */
      flag = CVodeReInit(cvode_mem, f, t, y, CV_SV, reltol, atolL);
      mode = LOOSE;
      /* Keep going */
      continue;
    }

    /* Check that no other error occured */
    if (flag &lt; 0) {
      printf(&quot;\nAn error occured!!!\n\n&quot;);
      break;
    }

    PrintOutput(cvode_mem, t, Ith(y,1), Ith(y,2), Ith(y,3));

    if (mode == LOOSE) {
      flag = CVodeGetLastStep(cvode_mem, &amp;hu);
      /* Test for sufficient increase in step size */
      if (hu &gt; H_FACT*HMIN) {
        PrintSolverStats(cvode_mem);
        printf(&quot;Tighten tolerances\n\n&quot;);
        /* Reset maximum order */
        CVodeSetMaxOrd(cvode_mem, 5);
        /* Reinitialize solver with tight tolerances */
        flag = CVodeReInit(cvode_mem, f, t, y, CV_SV, reltol, atolT);
        mode = TIGHT;
        /* Keep going */
        continue;
      }
    }
  }

  PrintSolverStats(cvode_mem);

  /* Get solution at final time */
  t = TOUT2;
  CVodeGetDky(cvode_mem, t, 0, y);
  PrintOutput(cvode_mem, t, Ith(y,1), Ith(y,2), Ith(y,3));
  
  /* Free memory */
  N_VDestroy_Serial(y);
  N_VDestroy_Serial(atolT);
  N_VDestroy_Serial(atolL);
  free_data(data);
  CVodeFree(cvode_mem);

  return(0);
}

/*
 * set_data
 *
 * Allocate and set user data structure
 */

static UserData set_data()
{
  UserData data;

  data = (UserData) malloc(sizeof *data);

  data-&gt;yp  = N_VNew_Serial(NEQ);
  data-&gt;yy  = N_VNew_Serial(NEQ);
  data-&gt;yyp = N_VNew_Serial(NEQ);

  data-&gt;p[0] = RCONST(0.04);
  data-&gt;p[1] = RCONST(1.0e4);
  data-&gt;p[2] = RCONST(3.0e7);

  return(data);
}

/*
 * free_data
 *
 * Deallocate user data structure
 */

static void free_data(UserData data)
{
  N_VDestroy_Serial(data-&gt;yp);
  N_VDestroy_Serial(data-&gt;yy);
  N_VDestroy_Serial(data-&gt;yyp);
  free(data);
}

/*
 * loosen_tol
 *
 * Estimate looser absolute tolerances so that the solver can proceed with
 * maximum order 1 (backward Euler) without the step size going below h_min
 *
 *                   (h_min)^2
 * atol_i = A_FACT * --------- * |y''_i|
 *                       2
 *
 * This ensures that ||y''||_WRMS &lt;= 1 (which is essentially the error test
 * for backward Euler).
 * 
 * A_FACT is a safety factor to prevent having to loosen the tolerances
 * at two consecutive steps.
 *
 * If the current order is greater than 1, we obtain y'' from the BDF 
 * interpolant (calling CVodeGetDky). If already at order 1, we estimate
 * y'' using a difference quotient, the same way it is estimated in CVODES
 * to compute an initial step size (see CVYddNorm in cvodes.c).
 */

static realtype loosen_tol(void *cvode_mem, realtype t, N_Vector y, UserData 
data, 
                           N_Vector atolL)
{
  int flag, qu;
  realtype alpha;
  N_Vector yp, yy, yyp;

  flag = CVodeGetLastOrder(cvode_mem, &amp;qu);

  if (qu &gt; 1) {

    /* atolL &lt;- y'' */
    flag = CVodeGetDky(cvode_mem, t, 2, atolL);

  } else {

    yp = data-&gt;yp;
    yy = data-&gt;yy;
    yyp = data-&gt;yyp;
    
    /* yp &lt;- y'(t) */
    flag = CVodeGetDky(cvode_mem, t, 1, yp);

    /* yy &lt;- h_min * y'(t) + y(t) */
    N_VLinearSum(HMIN, yp, 1.0, y, yy);

    /* yyp &lt;- f( t+h_min, h*y'(t)+y(t) ) */
    f(t+HMIN, yy, yyp, data);

    /* atolL &lt;- f(t+h, h*y'(t)+y(t)) - y'(t) */
    N_VLinearSum(1.0, yyp, -1.0, yp, atolL);

    /* atolL &lt;- y'' */
    N_VScale(1.0/HMIN, atolL, atolL);

  }

  alpha = A_FACT * (HMIN*HMIN/2.0);

  /* atolL &lt;- |y''| */
  N_VAbs(atolL, atolL);

  /* atolL &lt;- alpha * |y''| */
  N_VScale(alpha, atolL, atolL);

  return(alpha);

}

/*
 * f
 *
 * Compute RHS function f(t,y). 
 */

static void f(realtype t, N_Vector y, N_Vector ydot, void *f_data)
{
  UserData data;
  realtype p1, p2, p3;
  realtype y1, y2, y3, yd1, yd3;

  data = (UserData) f_data;
  p1 = data-&gt;p[0]; 
  p2 = data-&gt;p[1]; 
  p3 = data-&gt;p[2];

  y1 = Ith(y,1); 
  y2 = Ith(y,2); 
  y3 = Ith(y,3);

  yd1 = Ith(ydot,1) = -p1*y1 + p2*y2*y3;
  yd3 = Ith(ydot,3) = p3*y2*y2;
        Ith(ydot,2) = -yd1 - yd3;
}

/*
 * Jac
 *
 * Compute Jacobian J(t,y) = df/dy. *
 */

static void Jac(long int N, DenseMat J, realtype t,
                N_Vector y, N_Vector fy, void *jac_data,
                N_Vector tmp1, N_Vector tmp2, N_Vector tmp3)
{
  UserData data;
  realtype p1, p2, p3;
  realtype y1, y2, y3;

  data = (UserData) jac_data;
  p1 = data-&gt;p[0]; 
  p2 = data-&gt;p[1]; 
  p3 = data-&gt;p[2];

  y1 = Ith(y,1);
  y2 = Ith(y,2);
  y3 = Ith(y,3);

  IJth(J,1,1) = -p1;
  IJth(J,1,2) = p2*y3;
  IJth(J,1,3) = p2*y2;

  IJth(J,2,1) =  p1;
  IJth(J,2,2) = -p2*y3-2*p3*y2;
  IJth(J,2,3) = -p2*y2;

  IJth(J,3,2) = 2*p3*y2;
}

/*
 * PrintOutput
 *
 * Print current time, order, step size, and solution
 */

static void PrintOutput(void *cvode_mem, realtype t, realtype y1, realtype y2, 
realtype y3)
{
  int flag, qu;
  realtype hu;

  flag = CVodeGetLastOrder(cvode_mem, &amp;qu);
  flag = CVodeGetLastStep(cvode_mem, &amp;hu);

  printf(&quot;At t = %0.4le    | qu = %1d  hu =%14.6le |  y =%14.6le  %14.6le  
%14.6le\n&quot;, 
         t, qu, hu, y1, y2, y3);

  return;
}

/* 
 * PrinsolverStats
 *
 * Get and print some solver statistics
 */

static void PrintSolverStats(void *cvode_mem)
{
  realtype h0u;
  long int nst, nfe, nsetups, nni, ncfn, netf;
  int flag;

  flag = CVodeGetActualInitStep(cvode_mem, &amp;h0u);

  flag = CVodeGetNumSteps(cvode_mem, &amp;nst);
  flag = CVodeGetNumRhsEvals(cvode_mem, &amp;nfe);
  flag = CVodeGetNumLinSolvSetups(cvode_mem, &amp;nsetups);
  flag = CVodeGetNumErrTestFails(cvode_mem, &amp;netf);
  flag = CVodeGetNumNonlinSolvIters(cvode_mem, &amp;nni);
  flag = CVodeGetNumNonlinSolvConvFails(cvode_mem, &amp;ncfn);

  printf(&quot;\nSolver Statistics:\n&quot;);
  printf(&quot;nst = %-6ld nfe  = %-6ld nsetups = %-6ld nni = %-6ld ncfn = %-6ld 
netf = %-6ld\n&quot;,
         nst, nfe, nsetups, nni, ncfn, netf);
  printf(&quot;h0u = %14.6le\n\n&quot;,h0u);
}

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<div class="container">
<table width="95%" frame="below"><tr><td></td></table>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00030" href="msg00030.html">Enforcing a minimum time step</a></strong>
<ul><li><em>From:</em> Andreas Nicolai &lt;Andreas.Nicolai@gmx.net&gt;</li></ul></li>
<li><strong><a name="00033" href="msg00033.html">Re: Enforcing a minimum time step</a></strong>
<ul><li><em>From:</em> Radu Serban &lt;serban1@llnl.gov&gt;</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00070.html">Re: SUNDIALS applications</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00072.html">Re: SUNDIALS applications</a></strong>
</li>

<li>Previous by thread:
<strong><a href="msg00035.html">Re: Enforcing a minimum time step</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00036.html">how to write functions lsetup and lsove</a></strong>
</li>

<li>Index(es):
<ul>
<li><a href="maillist.html#00071">
<strong>Main</strong></a></li>
<li><a href="threads.html#00071">
<strong>Thread</strong></a></li>
</ul>
</li>
</ul>
</div>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
<!-- End content for this page -->
  </div>
  </td>
  <td background="../../graphics/table_bck3.gif"></td>
  </tr>
  <tr valign="top">
  <td height="17" background="../../graphics/table_bck4.gif"><img src="../../graphics/table_bck4.gif" width="5" height="17"></td>
  <td width="116"><a HREF="http://www.llnl.gov/disclaimer.html" target="_top"><img SRC="../../graphics/line_bl.gif" height="17" width="116" border="0"></a></td>
  <td width="720"><img SRC="../../graphics/line_br.gif" height="17" width="720" border="0"></td>
  <td background="../../graphics/table_bck4.gif"><img src="../../graphics/table_bck4.gif" width="5" height="17"></td>
  </tr>
  </table>
</body>
</html>
