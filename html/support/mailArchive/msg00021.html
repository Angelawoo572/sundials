<!-- MHonArc v2.6.10 -->
<!--X-Subject: Re: Using a class member function as the RhsFn in CVODE -->
<!--X-From-R13: Xnzrf Vbyybjnl <untneNhzvpu.rqh> -->
<!--X-Date: Mon, 21 Mar 2005 05:23:30 &#45;0800 (PST) -->
<!--X-Message-Id: 18a2c13f50b6bedb438b222f24eb46d4@umich.edu -->
<!--X-Content-Type: multipart/mixed -->
<!--X-Reference: BAY104&#45;F409F14AEA46CBE711E4A24B34A0@phx.gbl -->
<!--X-Reference: 423EB862.5020001@eas.iis.fraunhofer.de -->
<!--X-Head-End-->
<html>
<head>
<title>Re: Using a class member function as the RhsFn in CVODE</title>
<meta name="author" content="Radu Serban">
<meta name="description" content="suite of nonlinear differential algebraic equation solvers">
<meta name="keywords" content="SUNDIALS, CVODE, CVODES, IDA, KINSOL">
<meta name="keywords" content="ODE, DAE, sensitivity">
<meta name="keywords" content="differential, algebraic">
<link REL="SHORTCUT ICON" HREF="img/favicon.ico" type="image/x-icon">
<link REL="ICON" HREF="img/favicon.ico" type="image/x-icon">
<link href="../../sundials_styles.css" rel="stylesheet" type="text/css">
<script language="JavaScript">
<!--
homeon = new Image();           homeon.src = "../../graphics/home_buttonH.png";
homeoff = new Image();          homeoff.src = "../../graphics/home_button.png";
descriptionon = new Image();    descriptionon.src = "../../graphics/description_buttonH.png";
descriptionoff = new Image();   descriptionoff.src = "../../graphics/description_button.png";
documentationon = new Image();  documentationon.src = "../../graphics/documentation_buttonH.png";
documentationoff = new Image(); documentationoff.src = "../../graphics/documentation_button.png";
downloadon = new Image();       downloadon.src = "../../graphics/download_buttonH.png";
downloadoff = new Image();      downloadoff.src = "../../graphics/download_button.png";
supporton = new Image();        supporton.src = "../../graphics/support_buttonH.png";
supportoff = new Image();       supportoff.src = "../../graphics/support_button.png";
//-->
</script>
<script src="../../sunjs.js" type="text/javascript" language="javascript1.2"></script>
</head>
<!-- ******************************************************************************** -->
<body>
<table width="100%" height="100%" border="0" cellpadding="0" cellspacing="0">
  <tr valign="top">
  <td height="60" background="../../graphics/table_bck1.gif"><img src="../../graphics/table_bck1.gif" width="5" height="60"></td>
  <td width="116"><img SRC="../../graphics/head_top_left.png" height="60" width="116" border="0"></td>
  <td width="720"><img SRC="../../graphics/head_mail_top_right.png" height="60" width="720" border="0"></td>
  <td background="../../graphics/table_bck1.gif"><img src="../../graphics/table_bck1.gif" width="5" height="60"></td>
  </tr>
  <tr valign="top">
  <td height="127" background="../../graphics/table_bck2.gif"><img src="../../graphics/table_bck2.gif" width="5" height="127"></td>
  <td width="116">
    <a href="../../main.html" onMouseOver="img_act('home'); return true;" onMouseOut="img_inact('home'); return true;"><img src="../../graphics/home_button.png" border="0" name="home"></a><br>
    <a href="../../description/description.html" onMouseOver="img_act('description'); return true;" onMouseOut="img_inact('description'); return true;"><img src="../../graphics/description_button.png" border="0" name="description"></a><br>
    <a href="../../documentation/documentation.html" onMouseOver="img_act('documentation'); return true;" onMouseOut="img_inact('documentation'); return true;"><img src="../../graphics/documentation_button.png" border="0" name="documentation"></a><br>
    <a href="../../download/download.html" onMouseOver="img_act('download'); return true;" onMouseOut="img_inact('download'); return true;"><img src="../../graphics/download_button.png" border="0" name="download"></a><br>
    <a href="../../support/support.html" onMouseOver="img_act('support'); return true;" onMouseOut="img_inact('support'); return true;"><img src="../../graphics/support_button.png" border="0" name="support"></a><br>
    <img SRC="../../graphics/line_tl.gif" height="7" width="116" border="0"></td>
  <td width="720">
      <img SRC="../../graphics/head_bottom_right.png" height="120" width="720" border="0"><br>
      <img SRC="../../graphics/line_tr.gif" height="7" width="720" border="0"></td>
  <td background="../../graphics/table_bck2.gif"><img src="../../graphics/table_bck2.gif" width="5" height="127"></td>
  </tr>
  <tr valign="top">
  <td background="../../graphics/table_bck3.gif"></td>
  <td width="116" valign="bottom" align="center" background="../../graphics/table_bck5.gif"><img SRC="../../graphics/logo.png" border="0"></td>
  <td width="720" bgcolor="#ffffff">
  <div id="content">   
<!-- Start content for this page -->
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<p class="links">
[<a href="msg00020.html">Date Prev</a>] [<a href="msg00022.html">Date Next</a>] [<a href="msg00020.html">Thread Prev</a>] [<a href="msg00022.html">Thread Next</a>]<br>
[<b><a href="maillist.html#00021">Date Index</a></b>]
[<b><a href="threads.html#00021">Thread Index</a></b>]
</p>

<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Using a class member function as the RhsFn in CVODE</h1>
<div class="frame">
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<table border=0 cellpadding=2 cellspacing=0>
<tr>
<td align="right"><b>
<em>From</em></b></td>
<td align="left">
James Holloway &lt;<a href="mailto:hagar%40umich.edu">hagar@umich.edu</a>&gt;</td>
</tr>

<tr>
<td align="right"><b>
<em>Date</em></b></td>
<td align="left">
Mon, 21 Mar 2005 08:22:42 -0500</td>
</tr>

</table>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
</div>
<div class="container">
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre style="margin: 0em;">Jordan,</pre><br>
<pre style="margin: 0em;">I believe that Jens meant the cFlux function to look like this:</pre><br>
extern &quot;C&quot;<br>
void cFlux(realtype t, N_Vector CV_Y, N_Vector CV_DY, void *integrator)<br>
{<br>
    Integrator * this = (Integrator *) integrator;   //  cast to 
pointer to Integrator base object<br>
    this-&gt;CV_Flux(t, CV_Y, CV_DY);  // call virtual function CV_Flux<br>
}<br>
<br>
This function cFlux will provide the glue between cvode and your class 
-- it converts the integrator pointer to a pointer to the base class 
Integrator, and calls the member function CV_Flux of that to do the 
actual work of computing the right-hand-side of your ODEs.   Note that 
CV_Flux must be declared as a virtual member function, so that the 
right one is called even though integrator (and this) points to a base 
class.<br>
<br>
It's possible to put  the cFlux function into the class by making it a 
static member function, but there are hassles involved, and no benefits 
that I can see.<br>
<br>
I've attached the class odeDynamics that I use to provide an object 
oriented interface to CVode with Dense solvers, either with or without 
an explicit Jacobian.  Basically one subclasses either odeDynamics or 
odeDynamicsJacobian and replaces the virtual functions virtual void 
vectorField(double t, double * x, double * xdot)  (The CV_Flux function 
above) and virtual void Jacobian(double t, double * x, double * xdot, 
double ** jByCols).    There are some other members for looking at 
state, setting state and reinitializing the solver, indexing the 
Jacobian etc.   (And I think of odes as dx/dt = f(x,t), so what the 
cvode documents call y I call x, and what they call x I call t).<br>
<br>
<pre style="margin: 0em;">James</pre><br>
<pre>// odeDynamics.h
// $Id: msg00021.html,v 1.2 2006-01-24 00:52:06 radu Exp $
// A class that will provide an interface to the sundials solvers
// James Paul Holloway
// hagar@umich.edu
// 
========================================================================================
#ifndef ODE_DYNAMICS_H
#define ODE_DYNAMICS_H
#include &lt;iostream&gt;
#include &lt;string&gt;

// 
========================================================================================
// cvode solvers 
// 
========================================================================================
#include &quot;nvector_serial.h&quot;
#include &quot;cvode.h&quot;
#include &quot;cvdense.h&quot;

// 
========================================================================================
// Class declaration and definitions of inline functions
// 
========================================================================================
class odeDynamics
{
  public:
    // Constructor and destructor
    odeDynamics(unsigned int n, double t, double relativeTol, double 
absoluteTol);
    virtual ~odeDynamics();

    // 
====================================================================================
    // Indexing of current state  (also see setState and getState)
    // 
====================================================================================
    double &amp; operator[](unsigned int i) { return NV_Ith_S(solverStateVector,i); 
}

    // 
====================================================================================
    // Commands
    // 
====================================================================================

    // Initialize (or reinitialize) solver
    virtual void initialize();

    // Take a time step forward to time t 
    void takeStepTo(double t);

    // Take a step to the time current time plus dt
    void takeStepForwardDt(double dt) { takeStepTo(dt + currentTime()); }

    // Set the state at index i  (also see operator[])
    void setState(unsigned int i, double value) { NV_Ith_S(solverStateVector, 
i) = value; }

    // Set relative and absolute tolerances
    void setTolerances();

    void setRelativeTolerance(double eps)
    {
      relativeTolerance = eps;
      setTolerances();
    }

    void setAbsoluteTolerance(unsigned int i, double value)
    {
      NV_Ith_S(absoluteToleranceVector, i) = value; 
      setTolerances();
    }

    // 
====================================================================================
    // Queries 
    // 
====================================================================================

    // Get the state at index i  (also see operator[])
    double getState(unsigned int i) const { return NV_Ith_S(solverStateVector, 
i); }

    // Evaluate the vector field.  Replace in subclasses
    virtual void vectorField(double t, double * x, double * xdot) = 0;

    // Evaluate a Jacobian of the vector field -- implement so heirs do not 
have to
    // provide if not needed
    virtual void Jacobian(double t, double * x, double * xdot, double ** 
jByCols) { };

    // Dimension of system 
    unsigned int size() const { return stateSpaceSize;  }
    unsigned int dimension() const { return size(); }

    // Time at which current state data is valid
    double currentTime() const { return currentStatet; }

    
    // 
====================================================================================
    // Error classes 
    // 
====================================================================================
    class odeDynamicsError
    {
      public: 
        odeDynamicsError(const std::string &amp; label, const std::string &amp; msg)
        {
          std::cerr &lt;&lt; label &lt;&lt; &quot; &quot; &lt;&lt; msg &lt;&lt; std::endl;
        }
    };

    class CVodeSetupError: odeDynamicsError
    { 
      public: CVodeSetupError(const std::string &amp; msg) : 
odeDynamicsError(&quot;CVode Setup Error: &quot;, msg) { }
    };
    class CVodeRuntimeError: odeDynamicsError
    { 
      public: CVodeRuntimeError(const std::string &amp; msg) : 
odeDynamicsError(&quot;CVode Runtime Error: &quot;, msg) { }
    };

  protected:
    // A method to allow subclasses to get at cvodeMem, so they can do cvode 
operations on it
    void * getCvodeMem() { return cvodeMem; }
    
  private:

    // ========================================================================
    // State data
    // ========================================================================
    // size of the state space
    unsigned int stateSpaceSize;

    // Time at which state is current
    double currentStatet;

    // cvode data
    bool initialized;                  // Has the solver been initialized?
    void * cvodeMem;                   // Memory for solver
    N_Vector solverStateVector;        // State vector used by cvode
    N_Vector absoluteToleranceVector;  // Needs to be set by user
    double relativeTolerance;          // Needs to be set by user

    // ========================================================================
    // No copying or assignment, so make these private 
    // ========================================================================
    odeDynamics(const odeDynamics &amp; obj) {};
    odeDynamics &amp; operator=(const odeDynamics &amp; obj) {};
};


// =============================================================================
// =============================================================================
// =============================================================================
// =============================================================================
// odeDynamicsJacobian subclass that allows for an explicit Jacobian to be set

class odeDynamicsJacobian: public odeDynamics
{
   public:
     odeDynamicsJacobian(unsigned int n, double t, double relativeTol, double 
absoluteTol);
     virtual ~odeDynamicsJacobian() { };
     virtual void Jacobian(double t, double * x, double * xdot, double ** 
jacByCols) = 0;
     void initialize();

     // Set an element of the Jacobian stored by columns
     void setJ(unsigned int i, unsigned int j, double val, double ** J)
     {
       J[j][i] = val;
     }
};

#endif
</pre><pre>// odeDynamics.cpp
// $Id: msg00021.html,v 1.2 2006-01-24 00:52:06 radu Exp $
// A class that will provide an interface to the sundials solvers
// James Paul Holloway
// hagar@umich.edu
// 
========================================================================================
#include &quot;odeDynamics.h&quot;
#include &lt;sstream&gt;

// 
========================================================================================
// The interface to the vector field for the ode solver -- needs to be a
// C linkage function that can be passed by address.   To get access to the 
needed data
// We get a pointer to the base class, and use virtual functions to evaluate 
the vector
// field.  Any specialized data for subclasses can then be available via that 
virtual
// function.   Assume sundial realtype is t
// 
========================================================================================
extern &quot;C&quot;
void odeDynamicsF(double t, N_Vector x, N_Vector xdot, void * f_data)
{
   odeDynamics * dynamics = (odeDynamics *)f_data;           // get base class 
pointer
   dynamics-&gt;vectorField(t, NV_DATA_S(x), NV_DATA_S(xdot));  // need to be sure 
xdot is allocated 
}

// 
========================================================================================
// Constructor
// 
========================================================================================
odeDynamics::odeDynamics(unsigned int n, double t, double relativeTol, double 
absoluteTol)
{
  initialized = false;

  stateSpaceSize = n;
  currentStatet = t;

  cvodeMem = CVodeCreate(CV_BDF, CV_NEWTON);
  if(0 == cvodeMem) { throw CVodeSetupError(&quot;CVodeCreate failed.&quot;); }
 
  solverStateVector = N_VNew_Serial(n);
  if(0 == solverStateVector) { throw CVodeSetupError(&quot;Failed to create 
solverStateVector.&quot;); }
  for(unsigned int i = 0; i &lt; n; i = i + 1) { NV_Ith_S(solverStateVector, i) = 
0.0; }
 
  relativeTolerance = relativeTol;
  absoluteToleranceVector = N_VNew_Serial(n);
  if(0 == absoluteToleranceVector) { throw CVodeSetupError(&quot;Failed to create 
absoluteToleranceVector.&quot;); }
  for(unsigned int i = 0; i &lt; n; i = i + 1) { NV_Ith_S(absoluteToleranceVector, 
i) = absoluteTol; }

  
}

// 
========================================================================================
// Destructor
// 
========================================================================================
odeDynamics::~odeDynamics()
{
  // Clean up after cvode
  N_VDestroy_Serial(absoluteToleranceVector);
  N_VDestroy_Serial(solverStateVector);
  if(initialized == true) CVodeFree(cvodeMem);
}


// 
========================================================================================
// Commands
// 
========================================================================================

void odeDynamics::initialize()
{
  if(not initialized)
  {
    int flag = CVodeMalloc(cvodeMem, odeDynamicsF, currentStatet, 
solverStateVector, CV_SV, &amp;relativeTolerance, absoluteToleranceVector);
    if(flag != CV_SUCCESS)
    {
      if(flag == CV_MEM_NULL) { throw CVodeSetupError(&quot;CVodeMalloc called with 
cvodeMem NULL.&quot;); }
      else if(flag == CV_MEM_FAIL) { throw CVodeSetupError(&quot;CVodeMalloc failed 
to allocate memory.&quot;); }
      else if(flag == CV_ILL_INPUT) { throw CVodeSetupError(&quot;CVodeMalloc input 
argument invalid.&quot;); }
      else { throw CVodeSetupError(&quot;CVodeMalloc returned undefined error.&quot;); }
    }
    initialized = true;
  }
  else
  {
    int flag = CVodeReInit(cvodeMem, odeDynamicsF, currentStatet, 
solverStateVector, CV_SV, &amp;relativeTolerance, absoluteToleranceVector);
    if(flag != CV_SUCCESS)
    {
      if(flag == CV_MEM_NULL) { throw CVodeSetupError(&quot;CVodeReInit called with 
cvodeMem NULL.&quot;); }
      else if(flag == CV_NO_MALLOC) { throw CVodeSetupError(&quot;CVodeReInit no 
previous call to CVodeMalloc.&quot;); }
      else if(flag == CV_ILL_INPUT) { throw CVodeSetupError(&quot;CVodeReInit input 
argument invalid.&quot;); }
      else { throw CVodeSetupError(&quot;CVodeReInit returned undefined error.&quot;); }
    }
  }
  
  int flag = CVDense(cvodeMem, size());
  if(flag != CV_SUCCESS)
  {
    if(flag == CV_MEM_NULL) { throw CVodeSetupError(&quot;CVDense called with 
cvodeMem NULL.&quot;); }
    else if(flag == CV_MEM_FAIL) { throw CVodeSetupError(&quot;CVDense failed to 
allocate memory.&quot;); }
    else if(flag == CV_ILL_INPUT) { throw CVodeSetupError(&quot;CVDense is 
incompatible with the N_Vector module.&quot;); }
    else { throw CVodeSetupError(&quot;CVDense returned undefined error.&quot;); }
  }

  flag = CVodeSetFdata(cvodeMem, (void *)this);
  if(flag != CV_SUCCESS)
  {
    if(flag == CV_MEM_NULL) { throw CVodeSetupError(&quot;CVodeSetFdata called with 
cvodeMem NULL.&quot;); }
    else { throw CVodeSetupError(&quot;CVodeSetFdata returned undefined error.&quot;); }
  }
}

void odeDynamics::takeStepTo(double t)
{
  if(not initialized) initialize();

  double tReturn;  // time reached by solver
  int itask = CV_NORMAL;  // reach required t, if possible
  int flag = CVode(cvodeMem, t, solverStateVector, &amp;tReturn, itask);
  if(flag != CV_SUCCESS)
  {
    if(flag == CV_MEM_NULL) { throw CVodeSetupError(&quot;CVode called with cvodeMem 
NULL.&quot;); }
    else if(flag == CV_ILL_INPUT) { throw CVodeSetupError(&quot;CVode argument or 
internal error.&quot;); }
    else if(flag == CV_NO_MALLOC) { throw CVodeSetupError(&quot;CVode memory was not 
allocated.&quot;); }
    else if(flag == CV_LINIT_FAIL) { throw CVodeSetupError(&quot;CVode linear solver 
not initialized.&quot;); }
    else if(flag == CV_LSETUP_FAIL) { throw CVodeSetupError(&quot;CVode linear 
solver setup failed.&quot;); }
    else if(flag == CV_LSOLVE_FAIL) { throw CVodeRuntimeError(&quot;CVode linear 
solve failed.&quot;); }
    else if(flag == CV_TOO_MUCH_WORK)
    {
      long int numSteps;
      int flag = CVodeGetNumSteps(cvodeMem, &amp;numSteps);
      std::ostringstream message;
      message &lt;&lt; &quot;CVode too much work.  Solver took &quot; &lt;&lt; numSteps 
              &lt;&lt; &quot; internal steps but could not reach final time &quot; &lt;&lt; t ;
      throw CVodeRuntimeError(message.str()); 
    }
    else if(flag == CV_TOO_MUCH_ACC) { throw CVodeRuntimeError(&quot;CVode could not 
achieve requested accuracy.&quot;); }
    else if(flag == CV_ERR_FAILURE)
    {
      std::string message(&quot;CVode Error test failures occured too many times 
during one internal time step,&quot;);
      message = message + &quot; or occured at minimum time step.&quot;;
      throw CVodeRuntimeError(message);
    }
    else if(flag == CV_CONV_FAILURE)
    {
      std::string message(&quot;CVode Convergence test failures occured too many 
times during one internal time step,&quot;);
      message = message + &quot; or occured at minimum time step.&quot;;
      throw CVodeRuntimeError(message);
    }
    else if(flag == CV_TSTOP_RETURN) { /* not an error */ }
    else if(flag == CV_ROOT_RETURN) { /* not an error */ }
    else { throw CVodeSetupError(&quot;CVode returned undefined error.&quot;); }
  }

  // Check that tReturn is the same as t?
  // if(t != tReturn) std::cerr &lt;&lt; &quot;t = &quot; &lt;&lt; t &lt;&lt; &quot; is not same as tReturn = &quot; 
&lt;&lt; tReturn &lt;&lt; std::endl;
  currentStatet = tReturn;
}

void odeDynamics::setTolerances()
{
  int flag = CVodeSetTolerances(cvodeMem, CV_SV, &amp;relativeTolerance, 
absoluteToleranceVector);  
  if(flag != CV_SUCCESS)
  {
    if(flag == CV_MEM_NULL) { throw CVodeSetupError(&quot;CVodeSetTolerances called 
with cvodeMem NULL.&quot;); }
    else if(flag == CV_ILL_INPUT) { throw CVodeSetupError(&quot;CVodeSetTolerances 
input argument invalid.&quot;); }
    else { throw CVodeSetupError(&quot;CVodeSetTolerances returned undefined 
error.&quot;); }
  }
}


// 
========================================================================================
// 
========================================================================================
// 
========================================================================================
// 
========================================================================================
// Implementation of the odeDynamicsJacobian class

// 
========================================================================================
// Interface to a dense jacobian -- needs to have C linkage function that can 
be passed by
// address.  The jacobian member of the odeDynamicsJacobian needs to be virtual 
so that subclasses
// can have the right member function called
// 
========================================================================================
extern &quot;C&quot;
void odeDynamicsJ(long int N, DenseMat J, double t, N_Vector x, N_Vector xdot,
                  void * jac_data, N_Vector tmp1, N_Vector tmp2, N_Vector tmp3)
{
   odeDynamicsJacobian * dynamics = (odeDynamicsJacobian *)jac_data;   // get 
base class pointer
   dynamics-&gt;Jacobian(t, NV_DATA_S(x), NV_DATA_S(xdot), J-&gt;data);      // call 
the Jacobian
}

odeDynamicsJacobian::odeDynamicsJacobian(unsigned int n, double t, double 
relativeTol, double absoluteTol):
                     odeDynamics(n, t, relativeTol, absoluteTol)
{
   // Nothing to do here.  The initialize routine will add the Jacobian 
function to the solver
}

void odeDynamicsJacobian::initialize()
{
  odeDynamics::initialize();  // call base class version
  // Now add Jacobian
  int flag = CVDenseSetJacFn(getCvodeMem(), odeDynamicsJ);
  if(flag != CVDENSE_SUCCESS)
  {
    if(flag == CVDENSE_MEM_NULL) { throw CVodeSetupError(&quot;CVDenseSetJacFn 
called with cvodeMem NULL.&quot;); }
    else if(flag == CVDENSE_LMEM_NULL) { throw CVodeSetupError(&quot;CVDenseSetJacFn 
called with no solver memory.&quot;); }
    else { throw CVodeSetupError(&quot;CVDenseSetJacFn returned undefined error.&quot;); }
  }

  flag = CVDenseSetJacData(getCvodeMem(), (void *)this);
  if(flag != CVDENSE_SUCCESS)
  {
    if(flag == CVDENSE_MEM_NULL) { throw CVodeSetupError(&quot;CVDenseSetJacData 
called with cvodeMem NULL.&quot;); }
    else if(flag == CVDENSE_LMEM_NULL) { throw 
CVodeSetupError(&quot;CVDenseSetJacData called with no solver memory.&quot;); }
    else { throw CVodeSetupError(&quot;CVDenseSetJacData returned undefined 
error.&quot;); }
  }
  
}
</pre><pre style="margin: 0em;"><br></pre><br>
<pre style="margin: 0em;"><br>On Mar 21, 2005, at 7:04 AM, Jens Bastian wrote:</pre><br>
<blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">Hello Jordan,</pre><br>
CV_Flux() must not be a member function of a class. Instead it has to 
be a C function. E.g. you can write a function<br>
<br>
<pre style="margin: 0em;">cFlux(realtype t, N_Vector CV_Y, N_Vector CV_DY, void *integrator)
{
    return ((Integrator *)integrator)-&gt;CV_Flux(t, CV_Y, CV_DY);
}</pre><br>
<pre style="margin: 0em;">which calls the member function</pre><br>
<pre style="margin: 0em;">Integrator::CV_Flux(realtype t, N_Vector CV_Y, N_Vector CV_DY)
{
...
}</pre><br>
In the call to CVodeMalloc you must use the C function cFlux() as 
parameter:<br>
<br>
flag_CVodeMalloc = CVodeMalloc(cvode_mem, cFlux, 0.0, CV_Y, CV_SS, 
&amp;reltol, &amp;abstol);<br>
<br>
You must also set the user data to the actual class (this). I do not 
know the API function for CVODE but for IDA it looks like this:<br>
<br>
<pre style="margin: 0em;">IDASetRdata(mem, this);</pre><br>
<pre style="margin: 0em;">Best regards
Jens Bastian</pre><br>
Jordan Atlas wrote:
<blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em">Hello all,<br>
I get the following error when I try to compile my project that uses 
CVODE (using VC++ 6.0):<br>
D:\...\Integrator.cpp(329) : error C2664: 'CVodeMalloc' : cannot 
convert parameter 2 from 'void (double,struct _generic_N_Vector 
*,struct _generic_N_Vector *,void *)' to 'void (__cdecl 
*)(double,struct _generic_N_Vector *,struct _generic_N_Vector *,void 
*)'<br>
       None of the functions with this name in scope match the target 
type<br>
The offending line is:<br>
flag_CVodeMalloc = CVodeMalloc(cvode_mem, CV_Flux, 0.0, CV_Y, CV_SS, 
&amp;reltol, &amp;abstol);<br>
This line appears in a function declared as:<br>
void Integrator::CVODEMethod()    (ie, it is a member of the 
Integrator class).<br>
CV_Y is of type N_Vector.<br>
The declaration for my CV_Flux function (the &quot;second parameter&quot; 
mentioned in the error) is:<br>
void Integrator::CV_Flux(realtype t, N_Vector CV_Y, N_Vector CV_DY, 
void *f_data)<br>
(ie - CV_Flux is also a member of the integrator class).<br>
When I made my own example program using CVODE, I declared my RhsFn 
exactly the same way, except that it was not a member of a class.  Is 
it impossible to declare the functions in the way I described?<br>
Please let me know if this description is unclear.  Thank you for 
your assistance.<br>
--Jordan Atlas--
</blockquote><pre style="margin: 0em;"><br></pre><br>
<br>
</blockquote><pre style="margin: 0em;">--
James Paul Holloway
hagar@umich.edu
734-936-3126
</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
</div>
<div class="container">
<table width="95%" frame="below"><tr><td></td></table>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00019" href="msg00019.html">Using a class member function as the RhsFn in CVODE</a></strong>
<ul><li><em>From:</em> Jordan Atlas &lt;tunamaccheese@hotmail.com&gt;</li></ul></li>
<li><strong><a name="00020" href="msg00020.html">Re: Using a class member function as the RhsFn in CVODE</a></strong>
<ul><li><em>From:</em> Jens Bastian &lt;Jens.Bastian@eas.iis.fraunhofer.de&gt;</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00020.html">Re: Using a class member function as the RhsFn in CVODE</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00022.html">CVODES error</a></strong>
</li>

<li>Previous by thread:
<strong><a href="msg00020.html">Re: Using a class member function as the RhsFn in CVODE</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00022.html">CVODES error</a></strong>
</li>

<li>Index(es):
<ul>
<li><a href="maillist.html#00021">
<strong>Main</strong></a></li>
<li><a href="threads.html#00021">
<strong>Thread</strong></a></li>
</ul>
</li>
</ul>
</div>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
<!-- End content for this page -->
  </div>
  </td>
  <td background="../../graphics/table_bck3.gif"></td>
  </tr>
  <tr valign="top">
  <td height="17" background="../../graphics/table_bck4.gif"><img src="../../graphics/table_bck4.gif" width="5" height="17"></td>
  <td width="116"><a HREF="http://www.llnl.gov/disclaimer.html" target="_top"><img SRC="../../graphics/line_bl.gif" height="17" width="116" border="0"></a></td>
  <td width="720"><img SRC="../../graphics/line_br.gif" height="17" width="720" border="0"></td>
  <td background="../../graphics/table_bck4.gif"><img src="../../graphics/table_bck4.gif" width="5" height="17"></td>
  </tr>
  </table>
</body>
</html>
