<html>

<head>

<title>SUNDIALS NOTES</title>

<meta name="author" content="Radu Serban">
<meta name="description" content="suite of nonlinear differential algebraic equation solvers">
<meta name="keywords" content="SUNDIALS, CVODE, CVODES, IDA, KINSOL">
<meta name="keywords" content="ODE, DAE, sensitivity">
<meta name="keywords" content="differential, algebraic">
<link REL="SHORTCUT ICON" HREF="img/favicon.ico" type="image/x-icon">
<link REL="ICON" HREF="img/favicon.ico" type="image/x-icon">
<link href="../sundials_styles.css" rel="stylesheet" type="text/css">
<script language="JavaScript">
<!--
homeon = new Image();           homeon.src = "../graphics/home_buttonH.png";
homeoff = new Image();          homeoff.src = "../graphics/home_button.png";
descriptionon = new Image();    descriptionon.src = "../graphics/description_buttonH.png";
descriptionoff = new Image();   descriptionoff.src = "../graphics/description_button.png";
documentationon = new Image();  documentationon.src = "../graphics/documentation_buttonH.png";
documentationoff = new Image(); documentationoff.src = "../graphics/documentation_button.png";
downloadon = new Image();       downloadon.src = "../graphics/download_buttonH.png";
downloadoff = new Image();      downloadoff.src = "../graphics/download_button.png";
supporton = new Image();        supporton.src = "../graphics/support_buttonH.png";
supportoff = new Image();       supportoff.src = "../graphics/support_button.png";
//-->
</script>
<script src="../sunjs.js" type="text/javascript" language="javascript1.2"></script>

</head>

<!-- ******************************************************************************** -->

<body>


<table width="100%" height="100%" border="0" cellpadding="0" cellspacing="0">

  <tr valign="top">
  <td height="60" background="../graphics/table_bck1.gif"><img src="../graphics/table_bck1.gif" width="5" height="60"></td>
  <td width="116"><img SRC="../graphics/head_top_left.png" height="60" width="116" border="0"></td>
  <td width="720"><img SRC="../graphics/head_support_top_right.png" height="60" width="720" border="0"></td>
  <td background="../graphics/table_bck1.gif"><img src="../graphics/table_bck1.gif" width="5" height="60"></td>
  </tr>

  <tr valign="top">
  <td height="127" background="../graphics/table_bck2.gif"><img src="../graphics/table_bck2.gif" width="5" height="127"></td>
  <td width="116">
    <a href="../main.html" onMouseOver="img_act('home'); return true;" onMouseOut="img_inact('home'); return true;"><img src="../graphics/home_button.png" border="0" name="home"></a><br>
    <a href="../description/description.html" onMouseOver="img_act('description'); return true;" onMouseOut="img_inact('description'); return true;"><img src="../graphics/description_button.png" border="0" name="description"></a><br>
    <a href="../documentation/documentation.html" onMouseOver="img_act('documentation'); return true;" onMouseOut="img_inact('documentation'); return true;"><img src="../graphics/documentation_button.png" border="0" name="documentation"></a><br>
    <a href="../download/download.html" onMouseOver="img_act('download'); return true;" onMouseOut="img_inact('download'); return true;"><img src="../graphics/download_button.png" border="0" name="download"></a><br>
    <a href="support.html" onMouseOver="img_act('support'); return true;" onMouseOut="img_inact('support'); return true;"><img src="../graphics/support_button.png" border="0" name="support"></a><br>
    <img SRC="../graphics/line_tl.gif" height="7" width="116" border="0"></td>
  <td width="720">
      <img SRC="../graphics/head_bottom_right.png" height="120" width="720" border="0"><br>
      <img SRC="../graphics/line_tr.gif" height="7" width="720" border="0"></td>
  <td background="../graphics/table_bck2.gif"><img src="../graphics/table_bck2.gif" width="5" height="127"></td>
  </tr>

  <tr valign="top">
  <td background="../graphics/table_bck3.gif"></td>
  <td width="116" valign="bottom" align="center" background="../graphics/table_bck5.gif">
    <a href="../sitemap.html"><img SRC="../graphics/sitemap.png" border="0"></a><img SRC="../graphics/logo.png" border="0">
  </td>

  <td width="720" bgcolor="#ffffff">
  <div id="content">   

<!-- Start content for this page -->

<div class="title">Notes</div>
<br><br>

<h1>Contents</h1>
<div class="frame">
<ul>
<li><a href="#disc">Controlling unphysical solutions and integrating over discontinuities</a></li>
<li><a href="#switch">Switching on/off forward sensitivity computations</a></li>
</ul>
</div>

<!-- ------ -->

<a name="disc"></a>
<h1>Controlling unphysical solutions and integrating over discontinuities</h1>

<div class="frame">
<br>
We refer here to ODEs (and CVODE). DAE or IDA-specific issues will be explicitly mentioned. 
<br>
<br>
<h2>A) What are these problems?</h2>
<br>
<br>
First of all, to put things in context and lay blame where it's due, recall the chain
<br><br>
<center>physical phenomenon &rarr; mathematical model &rarr; numerical solution</center>
<br>
The <b>only</b> issues with unphysical solution components that can be
resolved by various settings and/or 'tricks' with numerical solvers
such as those in SUNDIALS are those arising in the second step, from
the mathematical model to its numerical solution. It is unreasonable to
expect an ODE/DAE solver to resolve problems introduced in the modeling part.
<br>
<br>
On the other hand, issues with discontinuities in the RHS function
arise (genuinely in some applications) in the first step, namely in
modeling a certain physical phenomenon.
<br>
<br>
Secondly, let's define the two problems under discussion (from the
perspective of the above comment).
<br>
<br>
<h3>A1) Unphysical solution components</h3>
<br>
<br>
In many applications, some components in the <b>true</b> solution (of
the mathematical model) are always positive or non-negative, though at
times very small. In the numerical solution, however, small negative
(hence unphysical) values can then occur. In most cases, these values
are harmless, and simply need to be controlled, not eliminated. 
<br>
<br>
Note that we assume that the mathematical model itself does <b>not</b>
lead to unphysical solutions. In other words, if we were able to
exactly solve it, its solution would be physically acceptable. If that
is not true (e.g. the model for some fluxes is such that it leads to
negative concentrations) then the mathematical model itself is
unphysical in some regions and the solution is to go back and revisit
the first step in the chain above. In such a case, it may be necessary
to switch between different models depending on the operating
conditions, which could introduce discontinuities in the ODE right-hand
side function and thus we may end up in the territory covered by the
next problem.
<br>
<br>
The CVODE cvdenx problem is an example of unphysical solutions introduced
by the numerical computation. This problem models three chemical
reactions and the 3 concentrations would always be positive (and less
than or equal to 1) if the system of ODEs were solved exactly. However,
depending on the integration tolerances (more on this later), it is
possible to obtain small negative values for y1 and y3 or even
completely unrealistic results!
<br>
<br>
<h3>A2) Discontinuities in the RHS function</h3>
<br>
<br>
In certain types of problems (most notably in some controls problems)
the underlying mathematical model must be changed in certain regions of
the solution space or the solution itself must be perturbed and this
can introduce discontinuities in the ODE right-hand side. The point (in
time, or whatever the independent ODE variable happens to be) at which
such a change occurs can be defined explicitly (i.e., it is known a
priori or can be determined externally to the ODE solver) or implicitly
(i.e., it is triggered by the satisfaction of some condition involving
the ODE solution).
<br>
<ol>
<li>
  For example, a model for the water flow in your sprinkler system will have a
  discontinuity whenever the system is turned on, the time at which this
happens being known a priori. This is an <i>explicitly-defined
discontinuity</i>.
</li>
<li>
On the other hand hand, imagine having a simple model based on F=ma for the 
evolution of the position of an airplane and wish to use it during landing. 
While the airplane is airborne, you integrate your ODEs for x,y,z but once
the altitude z becomes 0 an additional reaction force needs to be introduced 
into the model (the ground reaction force). Since the time at which the 
airplane touches ground cannot be known in advance, this is an 
<i>implicitly-defined discontinuity</i> (the condition in this case being z=0).
</li>
</ol>

Since the integration methods implemented in SUNDIALS are based on
assumptions of sufficient smoothness of the solution and the RHS
functions, such discontinuities must be addressed and treated
appropriately.
<br>
<br>
<h2>B) How do you resolve these problems?</h2>
<br>
<br>
In attempting to solve one of these problems, it is important to
remember that you should <b>never</b> simply change the solution 
y passed as an (input only) argument to the RHS or RES functions!
<br>
<br>
<h3>B1) Unphysical solution components</h3>
<br>
<br>
Note that, if unphysical components appear in the numerical solution, the amount by
which the physical bounds are violated will be of the order of the
absolute tolerance. The following pieces of advice are relevant:
<br>
<ol>
<li>
The way to control the size of unwanted physical violations of the computed values
is with tighter absolute tolerances. This requires some
knowledge of the noise level of these components, which may or may not
be different for different components. Some experimentation may be
needed.
<br>
The SUNDIALS solvers allow for the RHS/RES functions to return a positive flag 
indicating a "recoverable error". 
In this case, the solver will attempt to correct this by reducing the step size 
(which, for all practical purposes, is equivalent to a tightening of the tolerances!). 
Note that this assumes that the model is not at fault for the unphysical values and 
therefore, if y was physical at the previous step there must be some step size 
that will keep it physical.
</li>
<li>
If output plots or tables are being generated, and it is important to avoid having 
negative numbers appear there (for the sake of avoiding a long explanation of them, 
if nothing else), then eliminate them, but <b>only</b> in the context of the output 
medium. Then the internal values carried by the solver are unaffected. 
Remember that a small negative value in y returned by CVODE, with magnitude comparable 
to abstol or less, is equivalent to zero as far as the computation is concerned.</li>
<li>
The user's RHS function should <b>never</b> change a negative value in the solution 
vector y to a non-negative value, as a "solution" to this problem. This can cause 
instability. If the RHS routine cannot tolerate a zero or negative value (e.g. because
there is a square root or log of it), then the offending value should be changed to 
zero or a tiny positive number in a temporary variable (<b>not</b> in the input y 
vector) for the purposes of computing f(t,y).
</li>
</ol>

In addition, IDA provides the option of enforcing positivity or non-negativity
on components (specified through IDASetConstraints). 
But these constraint options should only be exercised if the use of absolute 
tolerances to control the computed values is unsuccessful, because they involve 
some extra overhead cost.
<br>
<br>
<h3>B2) Discontinuities in the RHS function</h3>
<br>
<br>
If the jumps at the discontinuities are relatively small, simply keep them in the 
RHS function, and let the integrator respond to them (possibly taking smaller steps 
through each point of discontinuity).
<br>
<br>
If the jumps are large, it is more efficient to stop at the point of
discontinuity and restart the integrator. The following steps must
therefore be taken:

<ol>
<li>
Integrate up to the point of discontinuity
<br>
<br>
The method used to reach that location depends on whether
the discontinuity is defined explicitly or implicitly. In either case,
it is critical that the RHS function <b>does not</b> incorporate the
discontinuity while integrating towards it.
<br>
<br>
For an explicitly-defined discontinuity  (i.e. tdisc is known a priori)
simply make that location an output time (tout=tdisc) and integrate to 
that point. If a smooth extension of the model over the discontinuity 
(see below) does not exist, in order to prevent the solver ever attempting 
a RHS evaluation at a point beyond the location of the discontinuity, also 
make that location a stopping time by calling CVodeSetStopTime(cvode_mem, tdisc).
<br>
<br>
To stop when the location of the discontinuity is determined by the solution 
(implicitly-defined discontinuity), use the rootfinding feature (available 
both in CVODE/CVODES and IDA). In other words, the location of the discontinuity 
is the zero of some function g of the solution (i.e.,g(tdisc, y(tdisc))=0). 
Note that, in this situation, you cannot use CVodeSetStopTime 
to prevent the discontinuity from being "seen" during this integration
phase. Indeed, the rootfinding algorithm relies on detecting sign
changes in g and therefore needs to be allowed to evaluate it (and
implicitly the RHS) on both sides of tdisc. Therefore, during this
phase only, you need to have a <b>smooth extension</b> over the
discontinuity so that the step across it and the subsequent rootfinding
can be done efficiently.
</li>
<li>
Incorporate the discontinuity
<br>
<br>
Depending on the (problem-dependent) type of discontinuity, you can now
adjust the solution y (for example by adding a jump) or switch to a new
ODE model (for example by flipping a switch in the user data passed to
RHS to activate the use of the new ODE model for the next integration
phase).
</li>
<li>
Reinitialize the solver at the point of discontinuity
<br>
<br>
This step is crucial and is the reason for all the work done in step 1
to identify the location of the discontinuity. Recall that the SUNDIALS 
solvers implement <b>multistep</b> methods and therefore use past solution
history (stored internally) to advance the solution in time. Once a
discontinuity occurred, the solutions at previous steps are not suitable 
any more and must therefore be discarded. Calling the reinitialization
function CVodeReInit ensures that the solvers restart at order 1 and begin 
building up a fresh solution history.
<br>
<br>
If using IDA, you must ensure that a solution (y,y') <b>consistent</b>
with the DAE is&nbsp; passed to IDAReInit. Therefore, you may need to first 
call IDACalcIC.
</li>
<li>
Integrate from the point of discontinuity
</li>
</ol>

</div>  <!-- END FRAME -->
  

<!--  ======================================================================== -->

<a name="switch"></a>
<h1>Switching on/off forward sensitivity computations</h1>
<div class="frame">

One of the common applications of sensitivity analysis is in generating derivative
information for dynamically-constrained optimization when using a reduced-space
approach. Depending on the optimization method used, several solutions of the 
underlying ODE system may be required in between evaluations of the sensitivities
(for example when using a line search).
To turn off sensitivity calculations (without deallocating any sensitivity-related memory 
or resetting any of the optional inputs, so that sensitivties can later be reactivated)
it is most efficient to use <tt>CVodeSensToggleOff</tt>. 
<br><br>
The example code below (a modification of the CVODES example <tt>cvsfwddenx</tt>) demonstrates 
the use of <tt>CVodeSensToggleOff</tt>.
<br><br>
Recall that sensitivity calculations are enabled by <tt>CVodeSensMalloc</tt> and <tt>CVodeSensReInit</tt>
and are disabled by <tt>CVodeSensFree</tt> (after calling this one, they can be re-enabled <b>only</b> by 
calling <tt>CVodeSensMalloc</tt>) and <tt>CVodeSensToggleOff</tt>.
<br><br><br>

<h2>SOURCE CODE</h2>
<div class="fragment">
<pre>
<span class="comment">/*
 * -----------------------------------------------------------------
 * $Revision: 1.1 $
 * $Date: 2006-03-13 18:38:53 $
 * -----------------------------------------------------------------
 * Programmer: Radu Serban @ LLNL
 * -----------------------------------------------------------------
 * Modification of the cvsfwddendx to illustrate switching on and off
 * sensitivity computations.
 * -----------------------------------------------------------------
 */</span>

#<span class="builtin">include</span> <span class="string">&lt;stdio.h&gt;</span>
#<span class="builtin">include</span> <span class="string">&lt;stdlib.h&gt;</span>
#<span class="builtin">include</span> <span class="string">&lt;string.h&gt;</span>

#<span class="builtin">include</span> <span class="string">"cvodes.h"</span>
#<span class="builtin">include</span> <span class="string">"nvector_serial.h"</span>
#<span class="builtin">include</span> <span class="string">"cvodes_dense.h"</span>
#<span class="builtin">include</span> <span class="string">"sundials_types.h"</span>

<span class="comment">/* Accessor macros */</span>
#<span class="builtin">define</span> <span class="function-name">Ith</span>(v,i)    NV_Ith_S(v,i-1)
#<span class="builtin">define</span> <span class="function-name">IJth</span>(A,i,j) DENSE_ELEM(A,i-1,j-1)

<span class="comment">/* Problem Constants */</span>
#<span class="builtin">define</span> <span class="variable-name">MXSTEPS</span> 2000
#<span class="builtin">define</span> <span class="variable-name">T0</span>      RCONST(0.0)
#<span class="builtin">define</span> <span class="variable-name">T1</span>      RCONST(4.0e10)

#<span class="builtin">define</span> <span class="variable-name">ZERO</span>  RCONST(0.0)

<span class="comment">/* Type : UserData */</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> {
  booleantype sensi;
  booleantype errconS;
  booleantype fsDQ;
  <span class="type">int</span> <span class="variable-name">meth</span>;
  realtype p[3];
} *<span class="type">UserData</span>;

<span class="comment">/* Prototypes of functions by CVODES */</span>
<span class="keyword">static</span> <span class="type">int</span> <span class="function-name">f</span>(realtype t, N_Vector y, N_Vector ydot, <span class="type">void</span> *<span class="variable-name">f_data</span>);
<span class="keyword">static</span> <span class="type">int</span> <span class="function-name">Jac</span>(<span class="type">long</span> <span class="type">int</span> <span class="variable-name">N</span>, <span class="variable-name">DenseMat</span> J, <span class="variable-name">realtype</span> t,
               N_Vector y, N_Vector fy, <span class="type">void</span> *<span class="variable-name">jac_data</span>, 
               N_Vector tmp1, N_Vector tmp2, N_Vector tmp3);
<span class="keyword">static</span> <span class="type">int</span> <span class="function-name">fS</span>(<span class="type">int</span> <span class="variable-name">Ns</span>, <span class="variable-name">realtype</span> t, <span class="variable-name">N_Vector</span> y, <span class="variable-name">N_Vector</span> ydot, 
              <span class="type">int</span> <span class="variable-name">iS</span>, <span class="variable-name">N_Vector</span> yS, <span class="variable-name">N_Vector</span> ySdot, 
              <span class="type">void</span> *<span class="variable-name">fS_data</span>, <span class="variable-name">N_Vector</span> tmp1, <span class="variable-name">N_Vector</span> tmp2);

<span class="comment">/* Prototypes of private functions */</span>
<span class="keyword">static</span> <span class="type">int</span> <span class="function-name">runCVode</span>(<span class="type">void</span> *<span class="variable-name">cvode_mem</span>, <span class="variable-name">N_Vector</span> y, <span class="variable-name">N_Vector</span> *yS, <span class="variable-name">UserData</span> data);
<span class="keyword">static</span> <span class="type">void</span> <span class="function-name">PrintHeader</span>(UserData data);
<span class="keyword">static</span> <span class="type">void</span> <span class="function-name">PrintFinalStats</span>(<span class="type">void</span> *<span class="variable-name">cvode_mem</span>, <span class="variable-name">UserData</span> data);

<span class="comment">/* Readibility replacements */</span>
#<span class="builtin">define</span> <span class="variable-name">sensi</span>   data-&gt;sensi
#<span class="builtin">define</span> <span class="variable-name">errconS</span> data-&gt;errconS
#<span class="builtin">define</span> <span class="variable-name">fsDQ</span>    data-&gt;fsDQ
#<span class="builtin">define</span> <span class="variable-name">meth</span>    data-&gt;meth

<span class="comment">/*
 *--------------------------------------------------------------------
 * MAIN PROGRAM
 *--------------------------------------------------------------------
 */</span>

<span class="type">int</span> <span class="function-name">main</span>(<span class="type">int</span> <span class="variable-name">argc</span>, <span class="type">char</span> *<span class="variable-name">argv</span>[])
{
  UserData data;
  <span class="type">void</span> *<span class="variable-name">cvode_mem</span>;

  <span class="type">long</span> <span class="type">int</span> <span class="variable-name">Neq</span>;
  realtype reltol;
  N_Vector y0, y, abstol;

  <span class="type">int</span> <span class="variable-name">Ns</span>;
  realtype *pbar;
  <span class="type">int</span> <span class="variable-name">is</span>, *<span class="variable-name">plist</span>; 
  N_Vector *yS0, *yS;

  <span class="type">int</span> <span class="variable-name">flag</span>;

  <span class="comment">/* Allocate and initialize parameters in user data structure */</span>
  data = (UserData) malloc(<span class="keyword">sizeof</span> *data);
  data-&gt;p[0] = RCONST(0.04);
  data-&gt;p[1] = RCONST(1.0e4);
  data-&gt;p[2] = RCONST(3.0e7);

  <span class="comment">/* Problem size */</span>
  Neq = 3;

  <span class="comment">/* Allocate vectors */</span>
  y0 = N_VNew_Serial(Neq);      <span class="comment">/* initial conditions */</span>
  y = N_VNew_Serial(Neq);       <span class="comment">/* solution vector */</span>
  abstol = N_VNew_Serial(Neq);  <span class="comment">/* absolute tolerances */</span>

  <span class="comment">/* Set initial conditions */</span>
  Ith(y0,1) = RCONST(1.0);
  Ith(y0,2) = RCONST(0.0);
  Ith(y0,3) = RCONST(0.0);

  <span class="comment">/* Set integration tolerances */</span>
  reltol = RCONST(1e-6);
  Ith(abstol,1) = RCONST(1e-8);
  Ith(abstol,2) = RCONST(1e-14);
  Ith(abstol,3) = RCONST(1e-6);

  <span class="comment">/* Create, set, and allocate CVODES object*/</span>
  cvode_mem = CVodeCreate(CV_BDF, CV_NEWTON);
  flag = CVodeSetFdata(cvode_mem, data);
  flag = CVodeSetMaxNumSteps(cvode_mem, MXSTEPS);
  flag = CVodeMalloc(cvode_mem, f, T0, y0, CV_SV, reltol, abstol);

  <span class="comment">/* Attach linear solver */</span>
  flag = CVDense(cvode_mem, Neq);
  flag = CVDenseSetJacFn(cvode_mem, Jac, data);

  <span class="comment">/* Sensitivity-related settings */</span>

  sensi = TRUE;           <span class="comment">/* sensitivity ON */</span>
  meth = CV_SIMULTANEOUS; <span class="comment">/* simultaneous corrector method */</span>
  errconS = TRUE;         <span class="comment">/* full error control */</span>
  fsDQ = FALSE;           <span class="comment">/* user-provided sensitvity RHS */</span>

  Ns = 3;

  pbar = (realtype *) malloc(Ns * <span class="keyword">sizeof</span>(realtype));
  pbar[0] = data-&gt;p[0];
  pbar[1] = data-&gt;p[1];
  pbar[2] = data-&gt;p[2];

  plist = (<span class="type">int</span> *) malloc(Ns * <span class="keyword">sizeof</span>(<span class="type">int</span>));
  <span class="keyword">for</span> (is=0; is&lt;Ns; is++) plist[is] = is;

  yS0 = N_VCloneVectorArray_Serial(Ns, y);
  <span class="keyword">for</span> (is=0;is&lt;Ns;is++) N_VConst(ZERO, yS0[is]);

  yS = N_VCloneVectorArray_Serial(Ns, y);
  
  flag = CVodeSensMalloc(cvode_mem, Ns, meth, yS0);

  flag = CVodeSetSensParams(cvode_mem, data-&gt;p, pbar, plist);

  <span class="comment">/*
    Sensitivities are enabled
    Set full error control
    Set user-provided sensitivity RHS
    Run CVODES
  */</span>

  flag = CVodeSetSensErrCon(cvode_mem, errconS);
  flag = CVodeSetSensRhs1Fn(cvode_mem, fS, data);

  flag = runCVode(cvode_mem, y, yS, data);

  <span class="comment">/*
    Change parameters
    Toggle sensitivities OFF
    Reinitialize and run CVODES
  */</span>

  data-&gt;p[0] = RCONST(0.05);
  data-&gt;p[1] = RCONST(2.0e4);
  data-&gt;p[2] = RCONST(2.9e7);

  sensi = FALSE;

  flag = CVodeSensToggleOff(cvode_mem);
  flag = CVodeReInit(cvode_mem, f, T0, y0, CV_SV, reltol, abstol);
  flag = runCVode(cvode_mem, y, yS, data);

  <span class="comment">/*
    Change parameters
    Switch to internal DQ sensitivity RHS function
    Toggle sensitivities ON (reinitialize sensitivities)
    Reinitialize and run CVODES
  */</span>
  
  data-&gt;p[0] = RCONST(0.06);
  data-&gt;p[1] = RCONST(3.0e4);
  data-&gt;p[2] = RCONST(2.8e7);

  sensi = TRUE;
  fsDQ = TRUE;

  flag = CVodeSetSensRhs1Fn(cvode_mem, NULL, NULL);
  flag = CVodeSensReInit(cvode_mem, meth, yS0);
  flag = CVodeReInit(cvode_mem, f, T0, y0, CV_SV, reltol, abstol);
  flag = runCVode(cvode_mem, y, yS, data);

  <span class="comment">/*
    Switch to partial error control
    Switch back to user-provided sensitivity RHS
    Toggle sensitivities ON (reinitialize sensitivities)
    Change method to staggered
    Reinitialize and run CVODES
  */</span>

  sensi = TRUE;
  errconS = FALSE;
  fsDQ = FALSE;
  meth = CV_STAGGERED;

  flag = CVodeSetSensErrCon(cvode_mem, errconS);
  flag = CVodeSetSensRhs1Fn(cvode_mem, fS, data);
  flag = CVodeSensReInit(cvode_mem, meth, yS0);
  flag = CVodeReInit(cvode_mem, f, T0, y0, CV_SV, reltol, abstol);
  flag = runCVode(cvode_mem, y, yS, data);

  <span class="comment">/*
    Free sensitivity-related memory
    (CVodeSensToggle is not needed, as CVodeSensFree toggles sensitivities OFF)
    Reinitialize and run CVODES
  */</span>
  
  sensi = FALSE;

  CVodeSensFree(cvode_mem);
  flag = CVodeReInit(cvode_mem, f, T0, y0, CV_SV, reltol, abstol);
  flag = runCVode(cvode_mem, y, yS, data);
  
  <span class="comment">/* Free memory */</span>

  N_VDestroy_Serial(y0);                 <span class="comment">/* Free y0 vector */</span>
  N_VDestroy_Serial(y);                  <span class="comment">/* Free y vector */</span>
  N_VDestroy_Serial(abstol);             <span class="comment">/* Free abstol vector */</span>
  N_VDestroyVectorArray_Serial(yS0, Ns); <span class="comment">/* Free yS0 vector */</span>
  N_VDestroyVectorArray_Serial(yS, Ns);  <span class="comment">/* Free yS vector */</span>
  free(plist);                           <span class="comment">/* Free plist */</span>

  free(data);                            <span class="comment">/* Free user data */</span>
  CVodeFree(&amp;cvode_mem);                 <span class="comment">/* Free CVODES memory */</span>

  <span class="keyword">return</span>(0);

}

<span class="keyword">static</span> <span class="type">int</span> <span class="function-name">runCVode</span>(<span class="type">void</span> *<span class="variable-name">cvode_mem</span>, <span class="variable-name">N_Vector</span> y, <span class="variable-name">N_Vector</span> *yS, <span class="variable-name">UserData</span> data)
{
  realtype t;
  <span class="type">int</span> <span class="variable-name">flag</span>;

  <span class="comment">/* Print header for current run */</span>
  PrintHeader(data);

  <span class="comment">/* Call CVode in CV_NORMAL mode */</span>  
  flag = CVode(cvode_mem, T1, y, &amp;t, CV_NORMAL);

  <span class="comment">/* Print final statistics */</span>
  PrintFinalStats(cvode_mem, data);

  printf(<span class="string">"\n"</span>);

  <span class="keyword">return</span>(flag);

}

<span class="comment">/*
 *--------------------------------------------------------------------
 * FUNCTIONS CALLED BY CVODES
 *--------------------------------------------------------------------
 */</span>

<span class="comment">/*
 * f routine. Compute f(t,y). 
 */</span>

<span class="keyword">static</span> <span class="type">int</span> <span class="function-name">f</span>(realtype t, N_Vector y, N_Vector ydot, <span class="type">void</span> *<span class="variable-name">f_data</span>)
{
  realtype y1, y2, y3, yd1, yd3;
  UserData data;
  realtype p1, p2, p3;

  y1 = Ith(y,1); y2 = Ith(y,2); y3 = Ith(y,3);
  data = (UserData) f_data;
  p1 = data-&gt;p[0]; p2 = data-&gt;p[1]; p3 = data-&gt;p[2];

  yd1 = Ith(ydot,1) = -p1*y1 + p2*y2*y3;
  yd3 = Ith(ydot,3) = p3*y2*y2;
        Ith(ydot,2) = -yd1 - yd3;

  <span class="keyword">return</span>(0);
}


<span class="comment">/* 
 * Jacobian routine. Compute J(t,y). 
 */</span>

<span class="keyword">static</span> <span class="type">int</span> <span class="function-name">Jac</span>(<span class="type">long</span> <span class="type">int</span> <span class="variable-name">N</span>, <span class="variable-name">DenseMat</span> J, <span class="variable-name">realtype</span> t,
               N_Vector y, N_Vector fy, <span class="type">void</span> *<span class="variable-name">jac_data</span>, 
               N_Vector tmp1, N_Vector tmp2, N_Vector tmp3)
{
  realtype y1, y2, y3;
  UserData data;
  realtype p1, p2, p3;
 
  y1 = Ith(y,1); y2 = Ith(y,2); y3 = Ith(y,3);
  data = (UserData) jac_data;
  p1 = data-&gt;p[0]; p2 = data-&gt;p[1]; p3 = data-&gt;p[2];
 
  IJth(J,1,1) = -p1;  IJth(J,1,2) = p2*y3;          IJth(J,1,3) = p2*y2;
  IJth(J,2,1) =  p1;  IJth(J,2,2) = -p2*y3-2*p3*y2; IJth(J,2,3) = -p2*y2;
                      IJth(J,3,2) = 2*p3*y2;

  <span class="keyword">return</span>(0);
}
 
<span class="comment">/* 
 * fS routine. Compute sensitivity r.h.s. 
 */</span>

<span class="keyword">static</span> <span class="type">int</span> <span class="function-name">fS</span>(<span class="type">int</span> <span class="variable-name">Ns</span>, <span class="variable-name">realtype</span> t, <span class="variable-name">N_Vector</span> y, <span class="variable-name">N_Vector</span> ydot, 
              <span class="type">int</span> <span class="variable-name">iS</span>, <span class="variable-name">N_Vector</span> yS, <span class="variable-name">N_Vector</span> ySdot, 
              <span class="type">void</span> *<span class="variable-name">fS_data</span>, <span class="variable-name">N_Vector</span> tmp1, <span class="variable-name">N_Vector</span> tmp2)
{
  UserData data;
  realtype p1, p2, p3;
  realtype y1, y2, y3;
  realtype s1, s2, s3;
  realtype sd1, sd2, sd3;

  data = (UserData) fS_data;
  p1 = data-&gt;p[0]; p2 = data-&gt;p[1]; p3 = data-&gt;p[2];

  y1 = Ith(y,1);  y2 = Ith(y,2);  y3 = Ith(y,3);
  s1 = Ith(yS,1); s2 = Ith(yS,2); s3 = Ith(yS,3);

  sd1 = -p1*s1 + p2*y3*s2 + p2*y2*s3;
  sd3 = 2*p3*y2*s2;
  sd2 = -sd1-sd3;

  <span class="keyword">switch</span> (iS) {
  <span class="keyword">case</span> <span class="constant">0</span>:
    sd1 += -y1;
    sd2 +=  y1;
    <span class="keyword">break</span>;
  <span class="keyword">case</span> <span class="constant">1</span>:
    sd1 +=  y2*y3;
    sd2 += -y2*y3;
    <span class="keyword">break</span>;
  <span class="keyword">case</span> <span class="constant">2</span>:
    sd2 += -y2*y2;
    sd3 +=  y2*y2;
    <span class="keyword">break</span>;
  }
  
  Ith(ySdot,1) = sd1;
  Ith(ySdot,2) = sd2;
  Ith(ySdot,3) = sd3;

  <span class="keyword">return</span>(0);
}

<span class="comment">/*
 *--------------------------------------------------------------------
 * PRIVATE FUNCTIONS
 *--------------------------------------------------------------------
 */</span>

<span class="keyword">static</span> <span class="type">void</span> <span class="function-name">PrintHeader</span>(UserData data)
{
  <span class="comment">/* Print sensitivity control flags */</span>
  printf(<span class="string">"Sensitivity: "</span>);
  <span class="keyword">if</span> (sensi) {
    printf(<span class="string">"YES ("</span>);
    <span class="keyword">switch</span> (meth) {
    <span class="keyword">case</span> <span class="constant">CV_SIMULTANEOUS</span>:
      printf(<span class="string">"SIMULTANEOUS + "</span>);
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="constant">CV_STAGGERED</span>:
      printf(<span class="string">"STAGGERED + "</span>);
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="constant">CV_STAGGERED1</span>:
      printf(<span class="string">"STAGGERED-1 + "</span>);
      <span class="keyword">break</span>;
    }
    <span class="keyword">if</span> (errconS) printf(<span class="string">"FULL ERROR CONTROL + "</span>);
    <span class="keyword">else</span>         printf(<span class="string">"PARTIAL ERROR CONTROL + "</span>);
    <span class="keyword">if</span> (fsDQ)    printf(<span class="string">"DQ sensitivity RHS)\n"</span>);
    <span class="keyword">else</span>         printf(<span class="string">"user-provided sensitivity RHS)\n"</span>);
  } <span class="keyword">else</span> {
    printf(<span class="string">"NO\n"</span>);
  }

  <span class="comment">/* Print current problem parameters */</span>
  printf(<span class="string">"Parameters: [%8.4e  %8.4e  %8.4e]\n"</span>,data-&gt;p[0], data-&gt;p[1], data-&gt;p[2]);
}

<span class="comment">/* 
 * Print some final statistics from the CVODES memory.
 */</span>

<span class="keyword">static</span> <span class="type">void</span> <span class="function-name">PrintFinalStats</span>(<span class="type">void</span> *<span class="variable-name">cvode_mem</span>, <span class="variable-name">UserData</span> data)
{
  <span class="type">long</span> <span class="type">int</span> <span class="variable-name">nst</span>;
  <span class="type">long</span> <span class="type">int</span> <span class="variable-name">nfe</span>, <span class="variable-name">nsetups</span>, <span class="variable-name">nni</span>, <span class="variable-name">ncfn</span>, <span class="variable-name">netf</span>;
  <span class="type">long</span> <span class="type">int</span> <span class="variable-name">nfSe</span>, <span class="variable-name">nfeS</span>, <span class="variable-name">nsetupsS</span>, <span class="variable-name">nniS</span>, <span class="variable-name">ncfnS</span>, <span class="variable-name">netfS</span>;
  <span class="type">long</span> <span class="type">int</span> <span class="variable-name">njeD</span>, <span class="variable-name">nfeD</span>;
  <span class="type">int</span> <span class="variable-name">flag</span>;

  flag = CVodeGetNumSteps(cvode_mem, &amp;nst);
  flag = CVodeGetNumRhsEvals(cvode_mem, &amp;nfe);
  flag = CVodeGetNumLinSolvSetups(cvode_mem, &amp;nsetups);
  flag = CVodeGetNumErrTestFails(cvode_mem, &amp;netf);
  flag = CVodeGetNumNonlinSolvIters(cvode_mem, &amp;nni);
  flag = CVodeGetNumNonlinSolvConvFails(cvode_mem, &amp;ncfn);

  <span class="keyword">if</span> (sensi) {
    flag = CVodeGetNumSensRhsEvals(cvode_mem, &amp;nfSe);
    flag = CVodeGetNumRhsEvalsSens(cvode_mem, &amp;nfeS);
    flag = CVodeGetNumSensLinSolvSetups(cvode_mem, &amp;nsetupsS);
    flag = CVodeGetNumSensErrTestFails(cvode_mem, &amp;netfS);
    flag = CVodeGetNumSensNonlinSolvIters(cvode_mem, &amp;nniS);
    flag = CVodeGetNumSensNonlinSolvConvFails(cvode_mem, &amp;ncfnS);
  }

  flag = CVDenseGetNumJacEvals(cvode_mem, &amp;njeD);
  flag = CVDenseGetNumRhsEvals(cvode_mem, &amp;nfeD);

  printf(<span class="string">"Run statistics:\n"</span>);

  printf(<span class="string">"   nst     = %5ld\n"</span>, nst);
  printf(<span class="string">"   nfe     = %5ld\n"</span>,   nfe);
  printf(<span class="string">"   netf    = %5ld    nsetups  = %5ld\n"</span>, netf, nsetups);
  printf(<span class="string">"   nni     = %5ld    ncfn     = %5ld\n"</span>, nni, ncfn);

  printf(<span class="string">"   njeD    = %5ld    nfeD     = %5ld\n"</span>, njeD, nfeD);

  <span class="keyword">if</span>(sensi) {
    printf(<span class="string">"   -----------------------------------\n"</span>);
    printf(<span class="string">"   nfSe    = %5ld    nfeS     = %5ld\n"</span>, nfSe, nfeS);
    printf(<span class="string">"   netfs   = %5ld    nsetupsS = %5ld\n"</span>, netfS, nsetupsS);
    printf(<span class="string">"   nniS    = %5ld    ncfnS    = %5ld\n"</span>, nniS, ncfnS);
  }


}

</pre>
</div> <!--  END CODE FRAGMENT -->


</div> <!-- END FRAME -->


<!-- ------ -->

<!-- End content for this page -->
  </div>
  </td>

  <td background="../graphics/table_bck3.gif"></td>
  </tr>

  <tr valign="top">
  <td height="17" background="../graphics/table_bck4.gif"><img src="../graphics/table_bck4.gif" width="5" height="17"></td>
  <td width="116"><a HREF="http://www.llnl.gov/disclaimer.html" target="_top"><img SRC="../graphics/line_bl.gif" height="17" width="116" border="0"></a></td>
  <td width="720"><img SRC="../graphics/line_br.gif" height="17" width="720" border="0"></td>
  <td background="../graphics/table_bck4.gif"><img src="../graphics/table_bck4.gif" width="5" height="17"></td>
  </tr>

  </table>

</body>
</html>
