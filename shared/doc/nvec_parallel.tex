% This is a shared SUNDIALS TEX file with description of
% the parallel nvector implementation
%
The {\nvecp} implementation of the {\nvector} module
defines the {\em content} field of \id{NV\_Spec} to be a structure 
containing the local and global lengths of the vector, a pointer to the MPI\index{MPI}
communicator, and a flag showing if the user called \id{MPI\_Init}:
\begin{verbatim}
struct _NV_SpecContent_Parallel {
  MPI_Comm comm;
  integertype local_vec_length;
  integertype global_vec_length;
  int init_by_user;
};
\end{verbatim}
The {\em tag} field of \id{NV\_Spec} is set to \id{parallel}.
The content field of \id{N\_Vector} is defined to be a structure containing
the global and local lengths of the vector and a pointer to the beginning 
of a contiguous local data array:
\begin{verbatim} 
struct _N_VectorContent_Parallel {
  integertype local_length;
  integertype global_length;
  realtype   *data;
};
\end{verbatim}

The {\nvecp} implementation provides user-callable routines \ID{NV\_SpecInit\_Parallel} 
to create a structure of type \id{NV\_Spec} whose {\em content} field is
of type \id{struct \_NV\_SpecParallelContent}, and \ID{NV\_SpecFree\_Parallel} 
to deallocate the space used by such a structure. 

\noindent The form of the call to \id{NV\_SpecInit\_Parallel} is
\begin{verbatim}
nvspec = NV_SpecInit_Parallel(comm, local_vec_length, global vec_length,
                              argc, argv);
\end{verbatim}
Its arguments are:
\begin{itemize}
\item \id{comm} is a pointer to the MPI communicator, of type \id{MPI\_Comm}.
  Must be non-\id{NULL};
\item \id{local\_vec\_length} is the length of the piece of the vectors
  residing on this processor. If the active processor set is a proper
  subset of the full processor set assigned to the job, the value of \id{local\_vec\_length}
  should be 0 on the inactive processors. Otherwise, the two global length values,
  input and computed, may differ;
\item \id{global\_vec\_length} is the global length of the vectors.
  This must equal the sum of all local lengths over the active processor set.
  If not, a message is printed;
\item \id{argc}, \id{argv} are the command line arguments count
  and the command line argument character array from the main program,
  respectively. Dummy arguments are acceptable if \id{MPI\_Init} has
  already been called.
\end{itemize}
If successful, \id{NV\_SpecInit\_Parallel} returns a pointer of type
\id{NV\_Spec}. This pointer should in turn be passed in any user
calls to \id{N\_VNew} to create a new \id{N\_Vector} of this type.
A vector specification object \id{nvspec} returned by \id{NV\_SpecInit\_Parallel}
can be freed by calling:
\begin{verbatim}
NV_SpecFree_Parallel(nvspec);
\end{verbatim}
In addition to these two routines, {\nvecp} defines MPI\index{MPI} implementations of all 
vector kernels listed in Table \ref{t:nvecops}, as well as the following macros
that can be used to access the contents of \id{NV\_Spec} and \id{N\_Vector}
or to create and destroy \id{N\_Vector}'s with component array data allocated
by the user. The suffix \id{\_P} in the names denotes parallel version.

\begin{itemize}

\item \ID{NS\_CONTENT\_P}, \ID{NV\_CONTENT\_P}

      These macros give access to the contents of the parallel
      vector specification object and \id{N\_Vector}, respectively.           
                                                               
      The assignment \id{ns\_cont = NS\_CONTENT\_P(nvspec)} sets       
      \id{ns\_cont} to be a pointer to the parallel vector
      specification content structure (of type \id{struct \_NV\_SpecParallelContent}).

      The assignment \id{v\_cont = NV\_CONTENT\_P(v)} sets       
      \id{v\_cont} to be a pointer to the \id{N\_Vector} content    
      structure of type \id{struct \_N\_VectorParallelContent}.

\item \ID{NV\_DATA\_P}, \ID{NV\_LOCLENGTH\_P}, \ID{NV\_GLOBLENGTH\_P}

      These macros give individual access to the parts of    
      the content of a parallel \id{N\_Vector}.                        
                                                               
      The assignment \id{v\_data = NV\_DATA\_P(v)} sets \id{v\_data} to be     
      a pointer to the first component of the local data for the vector \id{v}. 
      The assignment \id{NV\_DATA\_P(v) = v\_data} sets the component array of 
      \id{v} to be \id{v\_data} by storing the pointer \id{v\_data}.                   
                                                               
      The assignment \id{v\_llen = NV\_LOCLENGTH\_P(v)} sets \id{v\_llen} to be     
      the length of the local part of \id{v}. 
      The call \id{NV\_LENGTH\_P(v) = llen\_v} sets      
      the local length of \id{v} to be \id{llen\_v}.

      The assignment \id{v\_glen = NV\_GLOBLENGTH\_P(v)} sets \id{v\_glen} to  
      be the global length of the vector \id{v}.                    
      The call \id{NV\_GLOBLENGTH\_P(v) = glen\_v} sets the global       
      length of \id{v} to be \id{glen\_v}.

\item \ID{NV\_Ith\_P}

      This macro gives access to the individual components of the local data
      array of an \id{N\_Vector}.

      The assignment \id{r = NV\_Ith\_P(v,i)} sets \id{r} to be the value of 
      the \id{i}-th component of the local part of \id{v}. 
      The assignment \id{NV\_Ith\_P(v,i) = r}   
      sets the value of the \id{i}-th component of the local part of \id{v} 
      to be \id{r}.        

\item \ID{NV\_MAKE\_P}, \ID{NV\_DISPOSE\_P}

      These companion macros are used to create and          
      destroy an \id{N\_Vector} with a component array vdata        
      allocated by the user.                                   
                                                               
      The call \id{NV\_MAKE\_P(v,v\_data,nvspec)} makes \id{v} an        
      \id{N\_Vector} with local component array \id{v\_data}. 
      The local and global lengths of the  
      vector \id{v} is taken from \id{nvspec}.                             
      \id{NV\_MAKE\_P} stores the pointer \id{v\_data} so that changes      
      made by the user to the elements of \id{v\_data} are           
      simultaneously reflected in \id{v}. There is no copying of    
      elements.                                                
                                                               
      The call \id{NV\_DISPOSE\_P(v)} frees all memory associated     
      with \id{v} except for its component array. This memory was   
      allocated by the user and, therefore, should be          
      deallocated by the user.   

\item \ID{NVS\_MAKE\_P}, \ID{NVS\_DISPOSE\_P}
                             
      These companion macros are used to create and destroy  
      an array of \id{N\_Vector}'s with component \id{vs\_data} 
      (of type \id{realtype **}) allocated by the user.                                                
                                                               
      The call \id{NVS\_MAKE\_P(vs,vs\_data,ns,nvspec)} makes   
      \id{vs} an array of \id{ns} \id{N\_Vector}'s, with \id{vs[i]} having
      local component array \id{vs\_data[i]} and local and global lengths taken 
      from \id{nvspec}.    
      \id{NVS\_MAKE\_P} stores the pointers \id{vs\_data[i]} so that        
      changes made by the user to the elements of \id{vs\_data} are  
      simultaneously reflected in \id{vs}. There is no copying of   
      elements.                                                
                                                               
      The call \id{NVS\_DISPOSE\_P(vs,ns)} frees all memory associated   
      with \id{vs} except for its components' component array.      
      This memory was allocated by the user and, therefore,    
      should be deallocated by the user.                       

\end{itemize}

\noindent{\bf Notes}                                                      
           
\begin{itemize}
                                        
\item
  Users who use the make/dispose macros must                 
  \id{\#include<stdlib.h>} since these macros expand to calls to     
  \id{malloc} and \id{free}.                                             
       
\item
  When looping over the components of an \id{N\_Vector} \id{v}, it is     
  more efficient to first obtain the local component array via       
  \id{v\_data = NV\_DATA\_P(v)} and then access \id{v\_data[i]} within the     
  loop than it is to use \id{NV\_Ith\_P(v,i)} within the loop.        
                                                               
  \id{NV\_MAKE\_P} and \id{NV\_DISPOSE\_P} are similar to \id{N\_VNew} and  
  \id{N\_VFree} implemented by {\nvecp}, while \id{NVS\_MAKE\_P} and 
  \id{NVS\_DISPOSE\_P}  are      
  similar to  \id{N\_VNew\_S} and \id{N\_VFree\_S}. The        
  difference is one of responsibility for component memory     
  allocation and deallocation. \id{N\_VNew} allocates memory  
  for the \id{N\_Vector} components and \id{N\_VFree} frees the     
  component memory allocated by \id{N\_VNew}. For \id{NV\_MAKE\_P}   
  and \id{NV\_DISPOSE\_P}, the component memory is allocated and      
  freed by the user of this package. Similar remarks hold for  
  \id{NVS\_MAKE\_P},  \id{NVS\_DISPOSE\_P} and \id{N\_VNew\_S},              
  \id{N\_VFree\_S}.                                            

\item
  To maximize efficiency, vector kernels in the {\nvecp} implementation
  that have more than one \id{N\_Vector} argument do not check for
  consistent internal representation of these vectors. It is the user's 
  responsability to ensure that such routines are called with \id{N\_Vector}
  arguments that were all created with the \id{NV\_Spec} structure returned
  by \id{NV\_SpecInit\_Parallel}.

\end{itemize}

