%% This is a shared SUNDIALS TEX file with description of
%% the serial nvector implementation
%%

The {\nvecs} implementation of the {\nvector} module defines the {\em content} 
field of \id{N\_Vector} to be a structure containing the length of the vector 
and a pointer to the beginning of a contiguous data array.
%%
\begin{verbatim} 
struct _N_VectorContent_Serial {
  long int length;
  realtype *data;
};
\end{verbatim}
%%
%%--------------------------------------------
%%
The following four macros are provided to access the content of a {\nvecs}
vector. The suffix \id{\_S} in the names denotes serial version.
%%
\begin{itemize}

\item \ID{NV\_CONTENT\_S}                             
    
  This routine gives access to the contents of the serial
  vector \id{N\_Vector}.
  
  The assignment \id{v\_cont} $=$ \id{NV\_CONTENT\_S(v)} sets           
  \id{v\_cont} to be a pointer to the serial \id{N\_Vector} content  
  structure.                                             
                                                            
  Implementation: 
  
  \verb|#define NV_CONTENT_S(v) ( (N_VectorContent_Serial)(v->content) )|
  
\item \ID{NV\_DATA\_S}, \ID{NV\_LENGTH\_S}                                 
                                                            
  These macros give individual access to the parts of    
  the content of a serial \id{N\_Vector}.                        
                                                               
  The assignment \id{v\_data = NV\_DATA\_S(v)} sets \id{v\_data} to be     
  a pointer to the first component of the data for the \id{N\_Vector} \id{v}. 
  The assignment \id{NV\_DATA\_S(v) = v\_data} sets the component array of \id{v} to     
  be \id{v\_data} by storing the pointer \id{v\_data}.                   
  
  The assignment \id{v\_len = NV\_LENGTH\_S(v)} sets \id{v\_len} to be     
  the length of \id{v}. On the other hand, the call \id{NV\_LENGTH\_S(v) = len\_v} 
  sets the length of \id{v} to be \id{len\_v}.
                                                            
  Implementation: 
  
  \verb|#define NV_DATA_S(v) ( NV_CONTENT_S(v)->data )|
  
  \verb|#define NV_LENGTH_S(v) ( NV_CONTENT_S(v)->length )|

\item \ID{NV\_Ith\_S}                                               
                                                            
  This macro gives access to the individual components of the data
  array of an \id{N\_Vector}.

  The assignment \id{r = NV\_Ith\_S(v,i)} sets \id{r} to be the value of 
  the \id{i}-th component of \id{v}. The assignment \id{NV\_Ith\_S(v,i) = r}   
  sets the value of the \id{i}-th component of \id{v} to be \id{r}.        
  
  Here $i$ ranges from $0$ to $n-1$ for a vector of length $n$.

  Implementation:

  \verb|#define NV_Ith_S(v,i) ( NV_DATA_S(v)[i] )|

\end{itemize}
%%
%%----------------------------------------------
%%
The {\nvecs} module defines serial implementations of all vector operations listed 
in Table \ref{t:nvecops} and provides the following user-callable routines:
%%
\begin{itemize}

\item \ID{N\_VNew\_Serial}

  This function creates and allocates memory for a serial \id{N\_Vector}.
  Its only argument is the vector length.

  Prototype

  \verb|N_Vector N_VNew_Serial(long int vec_length);|

\item \ID{N\_VNewEmpty\_Serial}

  This function creates a new serial \id{N\_Vector} with an empty (\id{NULL}) data array.

  Prototype

  \verb|N_Vector N_VNewEmpty_Serial(long int vec_length);|

\item \ID{N\_VMake\_Serial}

 This function creates and allocates memory for a serial vector
 with user-provided data array.

 Prototype

 \verb|N_Vector N_VMake_Serial(long int vec_length, realtype *v_data);|


\item \ID{N\_VNewVectorArray\_Serial}

 This function creates an array of \id{count} serial vectors.
 This array of \id{N\_Vector} can be freed with \id{N\_VDestroyVectorArray}
 (defined by the generic nvector module).

 Prototype

 \verb|N_Vector *N_VNewVectorArray_Serial(int count, long int vec_length);|


\item \ID{N\_VDispose\_Serial}

 This function frees a serial \id{N\_Vector} created with \id{N\_VMake\_Serial}.
 Note that deallocation of the {\em data} array is the user's
 responsibility. In other words, \id{N\_VDispose\_Serial} is identitical
 to \id{N\_VDestroyEmpty\_Serial} (defined by {\nvecs} as part of the {\em ops}
 structure).

 Prototype

 \verb|void N_VDispose_Serial(N_Vector v);|


\item \ID{N\_VPrint\_Serial}

 This function prints the content of a serial vector to \id{stdout}.

 Prototype
 
 \verb|void N_VPrint_Serial(N_Vector v);|

\end{itemize}
%%
%%------------------------------------
%%
\paragraph{\bf Notes}                                                      
           
\begin{itemize}
                                        
\item
  When looping over the components of an \id{N\_Vector} \id{v}, it is     
  more efficient to first obtain the component array via       
  \id{v\_data = NV\_DATA\_S(v)} and then access \id{v\_data[i]} within the     
  loop than it is to use \id{NV\_Ith\_S(v,i)} within the loop.        
                                     
\item                          
  \id{NV\_MAKE\_S} and \id{NV\_DISPOSE\_S} are similar to the \id{N\_VNew} and  
  \id{N\_VFree} implemented by {\nvecs}, while \id{NVS\_MAKE\_S} and 
  \id{NVS\_DISPOSE\_S}  are similar to  \id{N\_VNew\_S} and \id{N\_VFree\_S}. 
  The difference is one of responsibility for component memory     
  allocation and deallocation. \id{N\_VNew} allocates memory  
  for the \id{N\_Vector} components and \id{N\_VFree} frees the     
  component memory allocated by \id{N\_VNew}. For \id{NV\_MAKE\_S}   
  and \id{NV\_DISPOSE\_S}, the component memory is allocated and      
  freed by the user of this package. Similar remarks hold for  
  \id{NVS\_MAKE\_S},  \id{NVS\_DISPOSE\_S} and \id{N\_VNew\_S},              
  \id{N\_VFree\_S}.                                            

\item
  To maximize efficiency, vector operations in the {\nvecs} implementation
  that have more than one \id{N\_Vector} argument do not check for
  consistent internal representation of these vectors. It is the user's 
  responsibility to ensure that such routines are called with \id{N\_Vector}
  arguments that were all created with the \id{NV\_Spec} structure returned
  by \id{NV\_SpecInit\_Serial}.

\end{itemize}
