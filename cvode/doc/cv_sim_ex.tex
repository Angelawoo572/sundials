%===================================================================================
\section{Example Problems for IVP Solution}\label{s:sim_examples}
%===================================================================================

The {\cvode} distribution contains, in the \id{sundials/cvodes/examples\_ser}
directory, the following six serial examples (using the {\nvecs} module)
for ODE IVP solution:
\begin{itemize}
\item \id{cvdx}
  solves a chemical kinetics problem consisting of three rate equations.
  
  This program solves the problem with the BDF method, Newton          
  iteration with the {\cvdense} linear solver, and a user-supplied    
  Jacobian routine;
\item \id{cvbx}
  solves the semi-discrete form of an advection-diffusion equation in 2-D. 
  
  This program solves the problem with the BDF method, Newton          
  iteration with the {\cvband} linear solver, and a user-supplied     
  Jacobian routine;
\item \id{cvkx}
  solves the semi-discrete form of a two-species diurnal kinetics
  advection-diffusion PDE system in 2-D space. 

  The problem is solved with the BDF/GMRES method (i.e.    
  using the {\cvspgmr} linear solver) and the block-diagonal part of the  
  Newton matrix as a left preconditioner. A copy of the block-diagonal 
  part of the Jacobian is saved and conditionally reused within the    
  preconditioner setup routine;
\item \id{cvkxb}
  solves the same problem as \id{cvkx}, with the BDF/GMRES method 
  and a banded preconditioner, generated by difference quotients, 
  using the module {\cvbandpre}.
  The problem is solved twice, with left and right preconditioning;
\item \id{cvdemd}
  is a demonstration program for {\cvode} with direct linear solvers.

  Two separate problems are solved using both the Adams and BDF linear
  multistep methods in combination with functional and Newton
  iterations. 

  The first problem is the Van der Pol oscillator for which 
  the Newton iteration cases use the following types of Jacobian approximations:
  (1) dense, user-supplied, (2) dense, difference quotient approximation, 
  (3) diagonal approximation. The second problem is a linear ODE with a
  banded lower triangular matrix derived from a 2-D advection PDE. In this
  case, the Newton iteration cases use the following types of Jacobian
  approximation: (1) band, user-supplied, (2) band, difference       
  quotient approximation, (3) diagonal approximation.
\item \id{cvdemk}
  is a demonstration program for {\cvode} with the Krylov linear solver.

  This program solves a stiff ODE system that arises from a system     
  of partial differential equations.  The PDE system is a six-species
  food web population model, with predator-prey interaction and diffusion 
  on the unit square in two dimensions.

  The ODE system is solved using Newton iteration and the      
  {\cvspgmr} linear solver (scaled preconditioned GMRES).                  
                                                                        
  The preconditioner matrix used is the product of two matrices:         
  (1) a matrix, only defined implicitly, based on a fixed number of     
  Gauss-Seidel iterations using the diffusion terms only; and               
  (2) a block-diagonal matrix based on the partial derivatives of the   
  interaction terms only, using block-grouping.                          
                                                                        
  Four different runs are made for this problem.                        
  The product preconditoner is applied on the left and on the right.    
  In each case, both the modified and classical Gram-Schmidt options    
  are tested;
\end{itemize}

\noindent In the \id{sundials/cvodes/examples\_par} directory, the {\cvode} 
distribution contains the following three parallel examples for
IVP integration (using the {\nvecp} module):
\begin{itemize}
\item \id{pvnx}
  solves the semi-discrete form of an advection-diffusion equation in 1-D.

  This program solves the problem with the option for nonstiff systems,
  i.e. Adams method and functional iteration;
\item \id{pvkx}
  is the parallel implementation of \id{cvkx};
\item \id{pvkxb}
  solves the same problem as \id{pvkx}, with the BDF/GMRES method 
  and a block-diagonal matrix with banded blocks as a preconditioner 
  generated by difference quotients, using the module {\cvbbdpre}.
\end{itemize}

The next two sections describe in detail a serial example (\id{cvdx}) and
a parallel one (\id{pvkx}). For details on the other examples, the reader is
directed to the comments in their source files.

%-----------------------------------------------------------------------

\subsection{A Serial Sample Problem}\label{ss:serial_sim_ex}

As an initial illustration of the use of the {\cvode} package for the
integration of IVP ODEs, the following is a sample program provided as part 
of the package.  It uses the {\cvode} dense linear solver module {\cvdense} 
and the {\nvecs} module (which provides a serial implementation of {\nvector})
in the solution of a small chemical kinetics problem
For the source listed in \A\ref{ss:cvdx}, we give a rather detailed explanation of 
the parts of the program and their interaction with {\cvode}.

Following the initial comment block, this program has a number
of \id{\#include} lines, which allow access to useful items in {\cvode}
header files.  The \id{sundialstypes.h} file provides the definition of the
type \id{realtype} (see \S\ref{s:types} in the user guide for
details).  For now, it suffices to read \id{realtype} as \id{double}.
The \id{cvodes.h} file provides prototypes for the three {\cvode}
functions to be called (excluding the linear solver selection
function), and also a number of constants that are to be used in
dimensioning, setting input arguments, testing the return value of
\id{CVode}, and accessing the integer optional outputs.
The \id{cvdense.h} file provides the prototype for the \id{CVDense} 
function, and a constant \id{DENSE\_NJE} for accessing optional output 
specific to {\cvdense}.  
The \id{nvector\_serial.h} file is the header file for the serial implementation
of the {\nvector} module and includes definitions of the 
\id{N\_Vector} type, a macro to access vector components, and prototypes 
for the serial implementation specific machine environment memory allocation
and freeing functions.
Finally, the \id{dense.h} file provides the definition of the dense
matrix type \id{DenseMat} and a macro for accessing matrix elements.
We have explicitly included \id{dense.h}, but this is not necessary because 
it is included by \id{cvdense.h}.

This program includes two user-defined accessor macros,
\id{Ith} and \id{IJth}
that are useful in writing the problem functions in a form closely
matching the mathematical description of the ODE system, i.e. with
components numbered from 1 instead of from 0. 
The \id{Ith} macro is used to access components of a vector of type \id{N\_Vector}
with a serial implementation. 
It is defined using the {\nvecs} accessor macro \id{NV\_Ith\_S} which numbers components 
starting with 0. The \id{IJth} macro is used to access elements of a dense matrix of
type \id{DenseMat}. It is defined using the {\dense} accessor macro \id{DENSE\_ELEM}
which numbers matrix rows and columns starting with 0. The macros
\id{NV\_Ith\_S} and \id{DENSE\_ELEM} are fully described in  \S\ref{ss:nvec_ser} and
\S\ref{ss:djacFn} of the user guide, respectively.

Next, the program includes some problem-specific constants, which are
isolated to this early location to make it easy to change them as
needed.
The program prologue ends with the prototype of a private helper
function and the two user-supplied functions that are called by
{\cvode}.

The \id{main} function begins with some dimensions and type
declarations.  These make use of the constant \id{OPT\_SIZE} and the
type \id{N\_Vector}.  The first line initializes the serial machine environment
by calling the \id{M\_EnvInit\_Serial} routine implemented by {\nvecs}
(see \S\ref{ss:nvec_ser} in the user guide). The next two lines allocate memory for the
\id{y} and \id{abstol} vectors using \id{N\_VNew} with a length
argument of \id{NEQ} ($= 3$). The next several lines load the initial
values of the dependendent variable vector into \id{y} and set the
absolute tolerance vector \id{abstol} using the \id{Ith} macro.

The call to \id{CVodeMalloc} specifies the \id{BDF} integration
method with \id{NEWTON} iteration.  The \id{SV} argument specifies
a vector of absolute tolerances, and this is followed by the
address of the relative tolerance \id{reltol} and the absolute
tolerance vector \id{abstol}.
The \id{FALSE} argument indicates that no optional inputs are present
in \id{iopt} or \id{ropt}.
The two \id{NULL} actual parameters in the \id{CVodeMalloc} call 
are for features that are not used in this example. 
The first one is passed for the \id{CVodeMalloc} formal parameter 
\id{f\_data}.  This pointer is passed to \id{f} every time \id{f}
is called, and is intended to point to user problem data that might be
needed in \id{f}.  The second \id{NULL} forces {\cvode} error messages to
be sent to standard output; a file pointer (of type \id{FILE*}) may be
given in this position otherwise.  
The return value of \id{CVodeMalloc} is a pointer to a
{\cvode} solver memory block for the problem and solver options specified
by the inputs.  In the case of failure, the return value is \id{NULL}.
This pointer must be passed in the remaining calls to {\cvode} functions. 
See \S\ref{sss:cvodemalloc} for full details of the call to \id{CVodeMalloc}.

The call to \id{CVDense} with a non-\id{NULL} Jacobian function 
\id{Jac} specifies the {\cvdense} linear solver with an analytic
Jacobian supplied by the user-supplied function \id{Jac}. 
The \id{NULL} argument is passed for the \id{CVDense} 
formal parameter \id{jac\_data}.  In a role similar to \id{f\_data},
this pointer is passed to \id{Jac} every time \id{Jac} is called, 
and is intended to point to user problem data that might be needed 
in \id{Jac}.  See \S\ref{sss:lin_solv_init} for full details of the call
to \id{CVDense}.

The actual solution of the ODE initial value problem is accomplished
in the loop over values of \id{tout}.  For each value, the program
calls \id{CVode} in the \id{NORMAL} mode, meaning that the integrator
takes steps until it overshoots \id{tout} and then interpolates to 
$t = $\id{tout}, putting the computed value of $y$(\id{tout}) into
\id{y}.  The program prints \id{t} and \id{y}, and tests for a 
return value other than \id{SUCCESS} by \id{CVode}.  See 
\S\ref{sss:cvode} for full details of the call to \id{CVode}.

Finally, the main program calls \id{NV\_Free} to free the vectors
\id{y} and \id{abstol}, calls \id{CVodeFree} to free the {\cvode}
memory block, calls \id{M\_EnvFree\_Serial} to free the serial machine
environment memory block, and prints all of the statistical quantities in the
private helper function \id{PrintFinalStats}.
See \S\ref{ss:nvec_ser} in the user guide for details on \id{M\_EnvFree\_Serial}.

The function \id{PrintFinalStats} used here is actually suitable for
general use in connection with the use of {\cvode} for any problem with 
a dense Jacobian.  It prints the cumulative number of steps
(\id{nst}), the number of \id{f} evaluations (\id{nfe}), 
the number of matrix factorizations (\id{nsetups}), 
the number of \id{Jac} evaluations (\id{nje}), 
the number of nonlinear iterations (\id{nni}), 
the number of nonlinear convergence failures (\id{ncnf}), and 
the number of local error test failures (\id{netf}).
These optional outputs are described in \S\ref{ss:optional_input},
except for \id{nje = iopt[DENSE\_NJE]}, which is described in 
\S\ref{sss:lin_solv_init}.

The function \id{f} is a straightforward expression of the ODEs. 
It uses the user-defined macro \id{Ith}
to extract the components of \id{y} and load the components of \id{ydot}.
See \S\ref{ss:user_fct_sim} for a detailed specification of \id{f}.

The function \id{Jac} sets the nonzero elements of the Jacobian
as a dense matrix.  (Zero elements need not be set because \id{J}
is preset to zero.)  It uses the user-defined macro
\id{IJth}
to reference the elements of a dense matrix of type \id{DenseMat}.
Here the problem size is small, so we need not worry about the
inefficiency of using \id{NV\_Ith\_S} and \id{DENSE\_ELEM} to do
\id{N\_Vector} and \id{DenseMat} element accesses.
Note that in this example \id{Jac} only accesses the \id{y} and \id{J} arguments.
See \S\ref{ss:user_fct_sim} for a detailed description of the dense \id{Jac} function.

The output generated by \id{cvdx} is shown below.
%%
%%
\VerbatimInput[frame=single,framesep=0.1in,label={\tt cvdx} sample output,fontsize=\small]
{../examples_ser/cvdx.out}
%%
%%

%-----------------------------------------------------------------------------------

\subsection{A Parallel Sample Program}\label{ss:parallel_sim_ex}

As an example of using {\cvode} with the Krylov linear solver {\cvspgmr}
and the parallel MPI {\nvecp} module, we describe 
a test problem based on a two-dimensional system of two PDEs involving
diurnal kinetics, advection, and diffusion. 
These equations represent a simplified model for the transport, production,
and loss of the oxygen singlet and ozone in the upper atmosphere.
The PDEs can be written as 
\begin{equation}\label{e:pvkx:pde}
  \frac{\partial c^i}{\partial t}=K_h\frac{\partial^2 c^i}{\partial x^2}
  +V \frac{\partial c^i}{\partial x}
  + \frac{\partial} {\partial y} K_v(y) \frac{\partial c^i}{\partial y}
  + R^i(c^1,c^2,t) \quad (i=1,2),
\end{equation}
where the superscripts $i$ are used to distinguish the chemical species, and
where the reaction terms are given by 
\begin{equation}\label{e:pvkx:r}
\begin{split}
  R^1(c^1,c^2,t) & = -q_1c^1c^3-q_2c^1c^2+2q_3(t)c^3+q_4(t)c^2 \\
  R^2(c^1,c^2,t) & = q_1c^1c^3-q_2c^1c^2-q_4(t)c^2
\end{split}
\end{equation}
The spatial domain is $0 \leq x \leq 20,\;30 \leq y \leq 50$. The constants
and parameters for this problem are as follows: $K_h=4.0\times
10^{-6},\;V=10^{-3},\;K_v=10^{-8}\exp (y/5),\;q_1=1.63\times
10^{-16},\;q_2=4.66\times 10^{-16},\;c^3=3.7\times 10^{16},$ and the diurnal
rate constants are defined as follows: 
\begin{equation*}
q_i(t) = 
\begin{cases}
\exp [-a_i/\sin \omega t], & \mbox{for }\sin \omega t>0 \\
0, & \mbox{for }\sin \omega t\leq 0
\end{cases}
\end{equation*}
where $i=3,4,\;\omega =\pi /43200,\;a_3=22.62,\;a_4=7.601.$
The time interval of integration is $[0, 86400]$, representing 24
hours measured in seconds.

Homogeneous Neumann boundary conditions are imposed on each boundary and the
initial conditions are 
\begin{eqnarray*}
c^{1}(x,z,0) &=&10^{6}\alpha (x)\beta (y),\;c^{2}(x,z,0)=10^{12}\alpha
(x)\beta (y) \\
\alpha (x) &=&1-(0.1x-1)^{2}+(0.1x-1)^{4}/2 \\
\beta (y) &=&1-(0.1y-4)^{2}+(0.1y-4)^{4}/2
\end{eqnarray*}

We discretize the PDE system with central differencing, to obtain
an ODE system $\dot{u} = f(t,u)$ representing (\ref{e:pvkx:pde}). For this
example, we may think of the processors as being laid out in a rectangle,
and each processor being assigned a subgrid of size \id{MXSUB}$\times$\id{MYSUB} of
the $x-y$ grid. If there are \id{NPEX} processors in the $x$ direction and \id{NPEY}
processors in the $y$ direction then the overall grid size is \id{MX}$\times$\id{MY}
with \id{MX}$=$\id{NPEX}$\times$\id{MXSUB} and \id{MY}$=$\id{NPEY}$\times$\id{MYSUB}.
There are $2\times$\id{MX}$\times$\id{MY} equations in this system of ODEs. 
To compute $f$ in this setting, the processors pass and receive information as follows. 
The solution components for the bottom row of grid points in the current
processor are passed to the processor below it and the solution for the top
row of grid points is received from the processor below the current
processor. The solution for the top row of grid points for the current
processor is sent to the processor above the current processor, while the
solution for the bottom row of grid points is received from that processor
by the current processor. Similarly the solution for the first column of
grid points is sent from the current processor to the processor to its left
and the last column of grid points is received from that processor by the
current processor. The communication for the solution at the right edge of
the processor is similar. If this is the last processor in a particular
direction, then message passing and receiving are bypassed for that
direction.

The code listing for this example is given in \A\ref{ss:pvkx}. The purpose of this
code is to provide a more complicated example than Example 1, and to provide
a template for a stiff ODE system arising from a PDE system. The solution
method is BDF with Newton iteration and {\spgmr}. The left preconditioner is
the block-diagonal part of the Newton matrix, with $2 \times 2$ blocks, and
the corresponding diagonal blocks of the Jacobian are saved each time the
preconditioner is generated, for re-use later under certain conditions. 

The organization of the \id{pvkx} program deserves some comments. The
right-hand side routine \id{f} calls two other routines: \id{ucomm}, which
carries out inter-processor communication; and \id{fcalc} which operates on
local data only and contains the actual calculation of $f(t,u)$. The 
\id{ucomm} function in turn calls three routines which do, respectively,
non-blocking receive operations, blocking send operations, and
receive-waiting. All three use MPI, and transmit data from the local \id{u}
vector into a local working array \id{uext}, an extended copy of \id{u}.
The \id{fcalc} function copies \id{u} into \id{uext}, so that the
calculation of $f(t,u)$ can be done conveniently by operations on 
\id{uext} only.

Sample output from \id{pvkx} follows. The output will vary if the
number of processors is changed. The output is for four processors 
(in a $2 \times 2$ array) with a $5 \times 5$ subgrid on each processor.
%%
%%
\VerbatimInput[frame=single,framesep=0.1in,label={\tt pvkx} sample output,fontsize=\small]
{../examples_par/pvkx.out}
%%
%%