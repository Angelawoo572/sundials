%===============================================================================
\section{Serial example problems}\label{s:ex_serial}
%===============================================================================

\subsection{A dense example: \id{cvdx}}\label{ss:cvdx}

As an initial illustration of the use of the {\cvode} package for the
integration of IVP ODEs, the following is a sample program provided as part 
of the package.  It uses the {\cvode} dense linear solver module {\cvdense} 
and the {\nvecs} module (which provides a serial implementation of {\nvector})
in the solution of a small chemical kinetics problem.
For the source listed in Appendix A, we give a rather detailed explanation
of the parts of the program and their interaction with {\cvode}.

Following the initial comment block, this program has a number
of \id{\#include} lines, which allow access to useful items in {\cvode}
header files.  The \id{sundialstypes.h} file provides the definition of the
type \id{realtype} (see \S\ref{s:types} in the user guide for
details).  For now, it suffices to read \id{realtype} as \id{double}.
The \id{cvode.h} file provides prototypes for the {\cvode}
functions to be called (excluding the linear solver selection
function), and also a number of constants that are to be used in
setting input arguments and testing the return value of \id{CVode}.
The \id{cvdense.h} file provides the prototype for the \id{CVDense} function.
The \id{nvector\_serial.h} file is the header file for the serial
implementation of the {\nvector} module and includes definitions of the 
\id{N\_Vector} type, a macro to access vector components, and prototypes 
for the serial implementation specific machine environment memory allocation
and freeing functions.
Finally, the \id{dense.h} file provides the definition of the dense
matrix type \id{DenseMat} and a macro for accessing matrix elements.
We have explicitly included \id{dense.h}, but this is not necessary because 
it is included by \id{cvdense.h}.

This program includes two user-defined accessor macros, \id{Ith} and
\id{IJth} that are useful in writing the problem functions in a form
closely matching the mathematical description of the ODE system,
i.e. with components numbered from 1 instead of from 0.  The \id{Ith}
macro is used to access components of a vector of type \id{N\_Vector}
with a serial implementation.  It is defined using the {\nvecs}
accessor macro \id{NV\_Ith\_S} which numbers components starting with
0. The \id{IJth} macro is used to access elements of a dense matrix of
type \id{DenseMat}. It is defined using the {\dense} accessor macro
\id{DENSE\_ELEM} which numbers matrix rows and columns starting with
0. The macros \id{NV\_Ith\_S} and \id{DENSE\_ELEM} are fully described
in \S\ref{ss:nvec_ser} and \S\ref{ss:djacFn} of the user guide,
respectively.

Next, the program includes some problem-specific constants, which are
isolated to this early location to make it easy to change them as needed.  
The program prologue ends with prototypes of two private helper
functions and the three user-supplied functions that are called by {\cvode}.

The \id{main} program begins with some dimensions and type declarations,
including use of the type \id{N\_Vector}.  The next several lines
allocate memory for the \id{y} and \id{abstol} vectors using
\id{N\_VNew\_Serial} with a length argument of \id{NEQ} ($= 3$). The
lines following that load the initial values of the dependendent
variable vector into \id{y} and set the absolute tolerance vector
\id{abstol} using the \id{Ith} macro.

The calls to \id{N\_VNEW\_Serial}, and also later calls to \id{CVode***}
functions, make use of a private function, \id{check\_flag}, which examines
the return value and terminates the run if there was a failure.  The
\id{check\_flag} function was written to be used for any \id{SUNDIALS}
application.

The call to \id{CVodeCreate} creates the {\cvode} solver memory block,
specifying the \id{BDF} integration method with \id{NEWTON} iteration.
The return value of is a pointer to that memory block for this
problem.  In the case of failure, the return value is \id{NULL}.  This
pointer must be passed in the remaining calls to {\cvode} functions.

The call to \id{CVodeMalloc} allocates the solver memory block.
Its arguments include the name of the C function \id{f} defining the
right-hand side function $f(t,y)$, and the initial conditions $(t_0,y_0)$.
The argument \id{SV} specifies a vector of absolute tolerances, and
this is followed by the address of the relative tolerance \id{reltol}
and the absolute tolerance vector \id{abstol}.
See \S\ref{sss:cvodemalloc} for full details of this call.

The call to \id{CVodeRootInit} specifies that a rootfinding problem
is to be solved along with the integration of the ODE system, that the
root functions are specified in the function \id{g}, and that there are
two such functions.  Specifically, they are set so as to find the points
where the first and last dependent variables achieve the values $0.0001$
 and $0.01$, respectively.
See \S\ref{ss:root_uc} for a detailed description of this call.

The calls to \id{CVDense} and \id{CVDenseJacFn} specify the {\cvdense}
linear solver with an analytic Jacobian supplied by the user-supplied
function \id{Jac}.  See \S\ref{sss:lin_solv_init} and \S\ref{ss:djacFn}
for full details of these two calls.

The actual solution of the ODE initial value problem is accomplished in
the loop over values of the output time \id{tout}.  In each pass of the
loop, the program calls \id{CVode} in the \id{NORMAL} mode, meaning that
the integrator is to take steps until it overshoots \id{tout} and then
interpolate to $t = $\id{tout}, putting the computed value of $y$(\id{tout})
into \id{y}, with \id{t} = \id{tout}.  The return value in this case is
\id{CV\_SUCCESS}.  However, if \id{CVode} finds a root before reaching the next
value of \id{tout}, it returns \id{CV\_ROOT\_RETURN} and stores the root
location in \id{t} and the solution there in \id{y}.  In either case, the
program prints \id{t} and \id{y}.  In the case of a root, it calls
\id{CVodeGetRootInfo} to get a length-2 array \id{rootsfound} of bits showing
which root function was found to have a root.  If \id{CVode} returned any
negative value (indicating a failure), the program breaks out of the loop.  
In the case of a \id{CV\_SUCCESS} return, the value of \id{tout} is
advanced (multiplied by 10) and a counter (\id{iout}) is advanced, so
that the loop can be ended when that counter reaches the preset number
of output times, \id{NOUT} = 12.  See \S\ref{sss:cvode} for full
details of the call to \id{CVode}.

Finally, the main program calls \id{PrintFinalStats} to get and print
all of the relevant statistical quantities.  It then calls \id{NV\_Destroy}
to free the vectors \id{y} and \id{abstol}, and \id{CVodeFree} to free the 
{\cvode} memory block.

The function \id{PrintFinalStats} used here is actually suitable for
general use in connection with the use of {\cvode} for any problem with 
a dense Jacobian.  It prints the cumulative number of steps (\id{nst}), 
the number of \id{f} evaluations (\id{nfe}) (excluding those for
difference-quotient Jacobian evaluations),
the number of matrix factorizations (\id{nsetups}),
the number of \id{f} evaluations for Jacobian evaluations (\id{nfeD}
= 0 here),
the number of Jacoobian evaluations (\id{njeD}),
the number of nonlinear (Newton) iterations (\id{nni}),
the number of nonlinear convergence failures (\id{ncfn}),
the number of local error test failures (\id{netf}), and
the number of \id{g} (root function) evaluations (\id{nge}).
These optional outputs are described in \S\ref{ss:optional_output}.

The function \id{f} is a straightforward expression of the ODEs. 
It uses the user-defined macro \id{Ith} to extract the components of \id{y}
and to load the components of \id{ydot}.
See \S\ref{ss:rhsFn} for a detailed specification of \id{f}.

Similarly, the function \id{g} defines the two functions, $g_0$ and $g_1$,
whose roots are to be found.  See \S\ref{ss:root_us} for a detailed description
of the \id{g} function.

The function \id{Jac} sets the nonzero elements of the Jacobian as a
dense matrix.  (Zero elements need not be set because \id{J} is preset
to zero.)  It uses the user-defined macro \id{IJth} to reference the
elements of a dense matrix of type \id{DenseMat}.  Here the problem
size is small, so we need not worry about the inefficiency of using
\id{NV\_Ith\_S} and \id{DENSE\_ELEM} to access \id{N\_Vector} and
\id{DenseMat} elements.  Note that in this example, \id{Jac}
only accesses the \id{y} and \id{J} arguments.  See \S\ref{ss:djacFn}
for a detailed description of the dense \id{Jac} function.

The output generated by \id{cvdx} is shown below.  It shows the output
values at the 12 preset values of \id{tout}.  It also shows the two root
locations found, first at a root of $g_1$, and then at a root of $g_0$.
%%
\VerbatimInput[frame=single,framesep=0.1in,label={\tt cvdx} sample output,
  fontsize=\small]{../examples_ser/cvdx.out}
%%

%-------------------------------------------------------------------------------

\subsection{A banded example: \id{cvbx}}\label{ss:cvbx}

The \id{cvbx} program given below solves the semi-discretized form
of the 2-D advection-diffusion equation
\begin{equation}
\label{eq:adeqn}
\partial u / \partial t = \partial^2 u / \partial x^2
  + .5 \partial u / \partial x + \partial^2 u / \partial y^2
\end{equation}
on a rectangle, with zero Dirichlet boundary conditions. The PDE is 
discretized spatially with standard central finite differences 
on a (MX+2) $\times$ (MY+2) mesh, giving an ODE system of size MX*MY.  
The discrete value $u_{ij}$ approximates $u$ at $x = i \Delta x$,
$y = j \Delta y$. The ODEs are
\begin{equation}
\label{eq:cdiff}
{{du_{ij}} \over dt} = f_{ij} =
         {{u_{i-1,j} - 2 u_{ij} + u_{i+1,j}} \over {(\Delta x)^2}}
       + .5  {{u_{i+1,j} - u_{i-1,j}} \over {2 \Delta x}}
       + {{u_{i,j-1} - 2 u_{ij} + u_{i,j+1}} \over {(\Delta y)^2}},
\end{equation}
where $1 \leq i \leq $MX and $1 \leq j \leq $MY.  The boundary
conditions are imposed by taking $u_{ij} = 0$ above if $i = 0$
or MX$+1$, or if $j = 0$ or MY$+1$. 
If we set $v_{(j-1)+(i-1)*MY} = u_{ij}$, then the system Jacobian
$J = \partial f / \partial v$ is a band matrix with upper and lower
bandwidths both equal to MY.  In the example, we take \id{MX} $= 10$ and
\id{MY} $= 5$.

The \id{cvbx.c} program includes the files \id{cvband.h} and
\id{band.h} in order to use the CVBAND linear solver. The \id{cvband.h}
file contains the prototype for the \id{CVBand} routine. The \id{band.h}
file contains the definition for band matrix type \id{BandMat} and the
\id{BAND\_COL} and \id{BAND\_COL\_ELEM} macros for accessing matrix
elements. See Section~\ref{sec-refban}. We have explicitly included
\id{band.h}, but this is not necessary because it is included by
\id{cvband.h}.  The file \id{vector.h} is included for the
definition of the type \id{N\_Vector}.

The include lines at the top of the file are followed by definitions of
problem constants which include the $x$ and $y$ mesh dimensions, \id{MX} and
\id{MY}, the number of equations \id{NEQ}, the scalar absolute tolerance
\id{ATOL}, the initial time \id{T0}, and the initial output time \id{T1}.

Spatial discretization of the partial differential equation naturally
produces an ODE system in which equations are numbered by mesh
coordinates $(i,j)$. The user-defined macro
\id{IJth} isolates the
translation for the mathematical two-dimensional index to the
one-dimensional \id{N\_Vector} index and allows the user to write
clean, readable code to access components of the dependent
variable. The \id{NV\_DATA\_S} macro returns the component array for a
given \id{N\_Vector}, and this array is passed to \id{IJth}
in order to do the actual \id{N\_Vector} access.

The type \id{UserData} is a pointer to a structure containing
problem data that the user needs in his/her \id{f} and \id{Jac}
functions. This structure is allocated and initialized at the beginning
of \id{main}. The pointer to this structure, called \id{data},
is passed to both \id{CVodeMalloc} and \id{CVBand}. Passing \id{data}
to \id{CVodeMalloc} for the formal parameter \id{f\_data} means that
\id{data} will be passed to the \id{f} function each time \id{f} 
is called.  Passing \id{data} to \id{CVBand} for the formal parameter
\id{jac\_data} means that \id{data} will also be passed to the \id{Jac}
function each time \id{Jac} is called. The use of the \id{data}
pointer eliminates the need for global program data.

The four functions other than \id{main} in the \id{cvbx.c} file are
\id{SetIC}, \id{PrintFinalStats}, \id{f}, and \id{Jac}. The first
two functions are called only from within the \id{cvbx.c} file. The
\id{SetIC} function sets the initial dependent variable
vector, and \id{PrintFinalStats} prints out statistics at the end of
the run.  The latter include various counters,
such as the total number of steps (\id{nst}), \id{f} evaluations
(\id{nfe}), LU decompositions (\id{nsetups}), 
Jacobian evaluations (\id{nje}), and
nonlinear iterations (\id{nni}).
These optional outputs are described in Sections~\ref{sec-optio}
and \ref{sec-bstats}.

The \id{main} function is straightforward.
The \id{CVodeMalloc} call specifies the \id{BDF} method with
a \id{NEWTON} iteration. The \id{SS} actual parameter indicates scalar
relative and absolute tolerances, and pointers \id{\&reltol}
and \id{\&abstol} to these values are passed.
The call to \id{CVBand} with a non-\id{NULL} Jacobian function \id{Jac}
specifies the CVBAND linear solver with a user-supplied Jacobian. The constant
\id{MY} is passed for both the upper and lower bandwidths of the Jacobian.
See Section \ref{sec-blink} for full details on \id{CVBand}.
The actual solution of the problem is performed by the call to \id{CVode}
within the loop over the output times \id{tout}.  The max-norm of the
solution vector and the number of time steps is printed at each output time.
Finally, the calls to \id{N\_VFree}, \id{CVodeFree}, and \id{PrintFinalStats}
free problem memory and print statistics.

The user's \id{f} function implements the central difference approximation
(\ref{eq:cdiff}) with $u$ identically zero on the boundary. 

The user's \id{Jac} function is an expression of the derivatives
\begin{eqnarray*}
\partial f_{ij} / \partial u_{ij} &=&
         -2 [(\Delta x)^{-2} + (\Delta y)^{-2}] \\
\partial f_{ij} / \partial u_{i+1,j} &=& (\Delta x)^{-2} 
                  + .5 (2 \Delta x)^{-1}, ~~~~
\partial f_{ij} / \partial u_{i-1,j}  =  (\Delta x)^{-2} 
                  - .5 (2 \Delta x)^{-1} \\
\partial f_{ij} / \partial u_{i,j+1} &=& (\Delta y)^{-2}, ~~~~
\partial f_{ij} / \partial u_{i,j-1}  =  (\Delta y)^{-2} ~. 
\end{eqnarray*}
The values $(\Delta x)^{-2}$, $.5(2 \Delta x)^{-1}$, and 
$(\Delta y)^{-2}$  are computed only once at the beginning of 
\id{main}, and stored in the locations \id{data->hdcoef}, 
\id{data->hacoef}, and \id{data->vdcoef},
respectively. 
When \id{Jac} receives the \id{data} pointer, it pulls out these
values from storage in the local variables \id{hordc}, \id{horac}, and
\id{verdc}. The \id{Jac} function loads the Jacobian by columns.  
It loops over the mesh points (\id{i},\id{j}). For each such mesh
point, the one-dimensional index \id{k = j-1 + (i-1)*MY} is computed
and the \id{k}th column of the Jacobian matrix \id{J} is set. 
The row index $k'$ of each component $f_{i',j'}$ that depends on
$u_{i,j}$ must be identified in order to load the corresponding element.
The elements are loaded with the \id{BAND\_COL\_ELEM} macro.
Note that the formula for the global index $k$ implies that decreasing 
(increasing) \id{i} by $1$ corresponds to decreasing (increasing) 
\id{k} by \id{MY}, while decreasing (increasing) \id{j} by $1$ 
corresponds of decreasing (increasing) \id{k} by $1$. 
These statements are reflected in the calls to
\id{BAND\_COL\_ELEM}. The first argument passed to the 
\id{BAND\_COL\_ELEM} macro is a pointer to the diagonal element 
in the column to be accessed. This pointer is obtained via a call to 
the \id{BAND\_COL} macro and is stored in \id{kthCol} in
the \id{Jac} function. When setting the components of \id{J} we must be
careful not to index out of bounds. The guards \id{(i != 1)},
\id{(i != MX)}, \id{(j != 1)}, and \id{(j != MY)} in front of the
calls to \id{BAND\_COL\_ELEM} prevent illegal
indexing.

The output generated by \id{cvbx} is shown below.
%%
\VerbatimInput[frame=single,framesep=0.1in,label={\tt cvbx} sample output,fontsize=\small]
{../examples_ser/cvbx.out}
%%

%-----------------------------------------------------------------------------------

\subsection{A Krylov example: \id{cvkx}}\label{ss:cvkx}

We give here an example that illustrates the use of CVODE with the
Krylov method SPGMR, in the CVSPGMR module, as the linear system
solver.  Following the source are explanatory comments on the program.

The following program solves the semi-discretized form of a pair of
kinetics-advection-diffusion partial differential equations.  The
problem is defined on a rectangle, and discretized spatially with
standard central finite differences on a $10 \times 10$ mesh, giving
an ODE system of size $200$.

Among the initial \id{\#include} lines in this case are lines to
include \id{iterativ.h}, \id{cvspgmr.h}, and \id{llnlmath.h}.
The first two contain constants and function prototypes associated
with preconditioned Krylov methods, including the values of the
\id{pretype} argument to \id{CVSpgmr}.  The inclusion
of \id{llnlmath.h} is done to access the \id{SQR} macro for the
square of a \id{real} number.

The \id{main} function calls \id{CVodeMalloc} specifying \id{BDF} and
\id{NEWTON}, with scalar tolerances.  It calls \id{CVSpgmr} specifying
the CVSPGMR linear solver with left preconditioning, modified Gram-Schmidt
orthogonalization, default values
(indicated by zero arguments) for the optional inputs \id{maxl} and \id{delt},
and non-\id{NULL} preconditioner setup and solve functions, \id{Precond} and
\id{PSolve}. The \id{data} pointer passed to \id{CVSpgmr} is passed to
\id{Precond} and \id{PSolve} whenever these are called. See
Section \ref{sec-slink} for details on the \id{CVSpgmr} function.  
The preconditioner is the block-diagonal part of the true Newton matrix. 
Then for a sequence of tout values, \id{CVode} is called in the
\id{NORMAL} mode, sampled output is printed, and the return value is
tested for error conditions.  Finally, \id{CVodeFree} is called and
final statistics are printed.  The latter include various counters,
such as the total number of steps (\id{nst}), \id{f} evaluations
(\id{nfe}), nonlinear iterations (\id{nni}), and linear iterations
(\id{nli}), among others.  Also printed are the lengths of the
problem-dependent real and integer workspaces used by the main
integrator CVode, denoted \id{lenrw} and \id{leniw}, and those
used by CVSPGMR, denoted \id{llrw} and \id{lliw}.
These optional outputs are described in Sections~\ref{sec-optio}
and \ref{sec-sstats}.

Mathematically, the dependent variable has three dimensions: species
number, $x$ mesh point, and $y$ mesh point.  But in CVODE, a vector of
type \id{N\_Vector} works with a one-dimensional contiguous array of
data components. The macro \id{IJKth} isolates the translation from
three dimensions to one. Its use results in clearer code and makes it
easy to change the underlying layout of the three-dimensional
data. Here the problem size is $200$, so we use the \id{NV\_DATA\_S}
macro for efficient \id{N\_Vector} access.  The \id{NV\_DATA\_S} macro
gives a pointer to the first component of an \id{N\_Vector} which we
pass to the \id{IJKth} macro to do an \id{N\_Vector} access.

The preconditioner is generated and factored in the \id{Precond}
routine and backsolved in the \id{PSolve} routine.  
It is a block-diagonal matrix with $2 \times 2$ blocks that include the
interaction Jacobian elements and the diagonal contribution of the
diffusion Jacobian elements.  The block-diagonal part of the Jacobian
itself, $J_{bd}$, is saved in separate storage each time it is
generated, on calls to \id{Precond} with \id{jok}\id{ == FALSE}.
On calls with \id{jok}\id{ == TRUE}, signifying that saved Jacobian data
can be reused, the preconditioner $P = I - \gamma J_{bd}$ is formed from the
saved matrix $J_{bd}$ and factored.  (A call to \id{Precond} with
\id{jok}\id{ == TRUE} can only occur after a call with
\id{jok}\id{ == FALSE}.) In each case, we set the value of \id{jcur}, i.e.
\id{*jcurPtr}, to \id{TRUE} when $J_{bd}$ is re-evaluated,
and \id{FALSE} otherwise, to inform CVSPGMR of the status of Jacobian data.

We need to take a brief detour to explain one last important point about
the \id{cvkx.c} user program. As documented in \id{dense.h} and \id{band.h},
the generic DENSE and BAND solvers each contain two sets of routines: one
for large, potentially distributed matrices, and one for small matrices which
will always reside on a single processor. The ``large'' dense and band
routines work with the types \id{DenseMat} and \id{BandMat}, respectively.
The ``small''dense and band routines work with \id{real **} as the
underlying dense and band matrix types. The types \id{DenseMat} and 
\id{BandMat}, as well as their supporting functions, may be re-implemented
in order to use this generic DENSE solver in a distributed-memory
environment. The CVDENSE and CVBAND linear solvers use the types
\id{DenseMat} and \id{BandMat} for the $N \times N$ dense and band
Jacobian and Newton matrices, and call the large matrix routines. 
The small dense and band routines are available for CVODE user
programs, and are documented in Sections~\ref{sec-smalld} and 
\ref{sec-smallb}, respectively.
In \id{cvkx.c}, each of the blocks of the preconditioner is a 
$2 \times 2$ dense matrix. Thus the small dense matrix routines
\id{denalloc}, \id{dencopy}, \id{denscale}, \id{gefa}, \id{gesl}, 
\id{denaddI}, \id{denfree}, and \id{denfreepiv} are
used.
The macro \id{IJth}\index{macros (accessor):user-defined} defined near
the top of the file is used to access individual elements in each preconditioner 
block, numbered from 1.

The output generated by \id{cvkx.c} is shown below.  Note that the
number of preconditioner evaluations, \id{npe}, is much smaller than
the number of preconditioner setups, \id{nsetups}, as a result of the
Jacobian re-use scheme.
%%
\VerbatimInput[frame=single,framesep=0.1in,label={\tt cvkx} sample output,fontsize=\small]
{../examples_ser/cvkx.out}
%%

%-----------------------------------------------------------------------------------
