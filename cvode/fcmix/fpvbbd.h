/* File fpvbbd.h: Header file for the FPVBBD Interface Package
   Version of 5 March 2002 */

#ifndef _fpvbbd_h
#define _fpvbbd_h

/***************************************************************************

                  FPVBBD Interface Package

The FPVBBD Interface Package is a package of C functions which,
together with the FPVODE Interface Package, support the use of the
PVODE solver (MPI version) with the PVBBDPRE preconditioner module,
for the solution of ODE systems in a mixed Fortran/C setting.  The
combination of PVODE and PVBBDPRE solves systems dy/dt = f(t,y) with
the SPGMR (scaled preconditioned GMRES) method for the linear systems
that arise, and with a preconditioner that is block-diagonal with
banded blocks.  While PVODE and PVBBDPRE are written in C, it is
assumed here that the user's calling program and user-supplied
problem-defining routines are written in Fortran.

The user-callable functions in this package, with the corresponding
CVODE/PVODE and PVBBDPRE functions, are as follows: 
  FPVBBDIN0 and FPVBBDIN1  interface to PVBBDAlloc and CVSpgmr 
  FPVREINBBD0 and FPVREINBBD1 interface to PVReInitBBD and CVREInitSpgmr 
  FPVBBDOPT accesses optional outputs
  FPVBBDF   interfaces to PVBBDFree

In addition to the Fortran right-hand side function PVFUN, the
user-supplied functions used by this package, are listed below,
each with the corresponding interface function which calls it (and its
type within PVBBDPRE or PVODE):
  PVLOCFN  is called by the interface function PVgloc of type PVLocalFn
  PVCOMMF  is called by the interface function PVcfn of type PVCommFn
  PVJTIMES (optional) is called by the interface function CVJtimes of 
           type CVSpgmrJtimesFn
(The names of all user-supplied routines here are fixed, in order to
maximize portability for the resulting mixed-language program.)

Important note on portability.
In this package, the names of the interface functions, and the names of
the Fortran user routines called by them, appear as dummy names
which are mapped to actual values by a series of definitions in the
header file fpvbbd.h.  Those mapping definitions depend in turn on a
pair of parameters, CRAY and UNDERSCORE, defined in the header file
fcmixpar.h, which is machine-dependent.  The names into which the dummy
names are mapped are either upper or lower case, and may or may not have
an underscore appended, depending on these parameters.  Check, and if 
necessary modify, the file fcmixpar.h for a given machine environment.

****************************************************************************

              Usage of the FPVODE/FPVBBD Interface Packages

The usage of the combined interface packages FPVODE and FPVBBD requires
calls to seven to nine interface functions, and three or four user-supplied
routines which define the problem to be solved and indirectly define
the preconditioner.  These function calls and user routines are
summarized separately below.

Some details are omitted, and the user is referred to the PVODE and
CVODE user documents for more complete information.

(1) User-supplied right-hand side routine: PVFUN
The user must in all cases supply the following Fortran routine
      SUBROUTINE PVFUN (NLOC, T, Y, YDOT)
      DIMENSION Y(*), YDOT(*)
It must set the YDOT array to f(t,y), the right-hand side of the ODE
system, as function of T = t and the array Y = y.  Here Y and YDOT
are distributed vectors, and NLOC is the length of the segments local
to the current processor.

(2) User-supplied routines to define preconditoner: PVLOCFN and PVCOMMF

The routines in the PVBBDPRE module provide a preconditioner matrix
for PVODE that is block-diagonal with banded blocks.  The blocking
corresponds to the distribution of the dependent variable vector y
among the processors.  Each preconditioner block is generated from the
Jacobian of the local part (on the current processor) of a given
function g(t,y) approximating f(t,y).  The blocks are generated by a
difference quotient scheme on each processor independently, utilizing
an assumed banded structure with given half-bandwidths.  A separate
pair of half-bandwidths defines the band matrix retained.

(2.1) Local approximate function PVLOCFN.
The user must supply a subroutine of the form
      SUBROUTINE PVLOCFN (NLOC, T, YLOC, GLOC)
      DIMENSION YLOC(*), GLOC(*)
to compute the function g(t,y) which approximates the right-hand side
function f(t,y).  This function is to be computed locally, i.e. without 
inter-processor communication.  (The case where g is mathematically
identical to f is allowed.)  It takes as input the local vector length
NLOC, the independent variable value T = t, and the local real
dependent variable array YLOC.  It is to compute the local part of
g(t,y) and store this in the real array GLOC.

(2.2) Communication function PVCOMMF.
The user must also supply a subroutine of the form
      SUBROUTINE PVCOMMF (NLOC, T, YLOC)
      DIMENSION YLOC(*)
which is to perform all inter-processor communication necessary to
evaluate the approximate right-hand side function g described above.
This function takes as input the local vector length NLOC, the
independent variable value T = t, and the local real dependent
variable array YLOC.  It is expected to save communicated data in 
work space defined by the user, and made available to PVLOCFN.
Each call to the PVCOMMF is preceded by a call to PVFUN with the same
(t,y) arguments.  Thus PVCOMMF can omit any communications done by PVFUN
if relevant to the evaluation of g.

(3) Optional user-supplied Jacobian-vector product routine: PVJTIMES
As an option, the user may supply a routine that computes the product
of the system Jacobian J = df/dy and a given vector v.  If supplied, it
must have the following form:
      SUBROUTINE PVJTIMES (NLOC, V, FJV, T, Y, FY, VNRM, EWT, H, UROUND,
     1                     NFE, WORK, IER)
      DIMENSION V(*), FJV(*), Y(*), FY(*), EWT(*), WORK(*)
Typically this routine will use only NLOC, T, Y, V, and FJV.  It must
compute the product vector Jv, where the vector v is stored in V, and store
the product in FJV.  On return, set IER = 0 if PVJTIMES was successful,
and nonzero otherwise.

(4) Initialization:  FPVINITMPI, FPVMALLOC, FPVBBDIN0, and FPVBBDIN1.

(4.1) To initialize the use of the MPI (Message Passing Interface) library
by PVODE, the user must make the following call:
      CALL FPVINITMPI (NLOCAL, NGLOBAL, IER)
The arguments are:
NLOCAL  = local size of vectors on this processor
NGLOBAL = the ODE problem size, and the global size of vectors (the sum 
          of all values of NLOCAL)
IER     = return completion flag. Values are 0 = success, -1 = failure.
Note: If MPI was initialized by the user, the communicator must be
set to MPI_COMM_WORLD.  If not, this routine initializes MPI and sets
the communicator equal to MPI_COMM_WORLD.

(4.2) To set various problem and solution parameters and allocate
internal memory for PVODE, make the following call:
      CALL FPVMALLOC(NEQ, T0, Y0, METH, ITMETH, IATOL, RTOL, ATOL, INOPT,
     1               IOPT, ROPT, IER)
The arguments are:
NEQ    = the global problem size
T0     = initial value of t
Y0     = array of initial conditions
METH   = basic integration method: 1 = Adams (nonstiff), 2 = BDF (stiff)
ITMETH = nonlinear iteration method: 1 = functional iteration, 2 = Newton iter.
IATOL  = type for absolute tolerance ATOL: 1 = scalar, 2 = array
RTOL   = relative tolerance (scalar)
ATOL   = absolute tolerance (scalar or array)
INOPT  = optional input flag: 0 = none, 1 = inputs used
IOPT   = array of length 40 for integer optional inputs and outputs
         (declare as INTEGER*4 or INTEGER*8 according to C type long int)
ROPT   = array of length 40 for real optional inputs and outputs
         The optional inputs are MAXORD, MXSTEP, MXHNIL, SLDET, H0, HMAX,
         HMIN, stored in IOPT(1), IOPT(2), IOPT(3), IOPT(14), ROPT(1),
         ROPT(2), ROPT(3), respectively.  If any of these optional inputs
         are used, set the others to zero to indicate default values.
         The optional outputs are NST, NFE, NSETUPS, NNI, NCFN, NETF, QU, QCUR,
         LENRW, LENIW, NOR, HU, HCUR, TCUR, TOLSF, stored in IOPT(4) .. IOPT(13),
         IOPT(15), ROPT(4) .. ROPT(7), resp.  See the CVODE manual for details. 
IER    = return completion flag.  Values are 0 = success, and -1 = failure.
         See printed message for details in case of failure.

(4.3) To specify the SPGMR linear system solver, and to allocate memory 
and initialize data associated with the SPGMR method and the PVBBDPRE
preconditioner, make one of the following calls:
      CALL FPVBBDIN0 (MUDQ, MLDQ, MU, ML, DQRELY, IPRETYPE, IGSTYPE, MAXL,
     1                DELT, IER)                if PVJTIMES is not supplied;
      CALL FPVBBDIN1 (MUDQ, MLDQ, MU, ML, DQRELY, IPRETYPE, IGSTYPE, MAXL,
     1                DELT, IER)                if PVJTIMES is supplied.
In either case, the arguments are:
MUDQ,MLDQ = upper and lower half-bandwidths to be used in the computation
            of the local Jacobian blocks by difference quotients.
            These may be smaller than the true half-bandwidths of the
            Jacobian of the local block of g, when smaller values may
            provide greater efficiency.
MU, ML    = upper and lower half-bandwidths of the band matrix that 
            is retained as an approximation of the local Jacobian block.
            These may be smaller than MUDQ and MLDQ.
DQRELY    = relative increment factor in y for difference quotients
            (optional). 0.0 indicates the default, sqrt(unit roundoff).
IPRETYPE  = preconditioner type: 1 = left only, 2 = right only, 3 = both sides.
IGSTYPE   = Gram-schmidt process type: 0 = modified G-S, 1 = classical G-S.
MAXL      = maximum Krylov subspace dimension; 0 indicates default.
DELT      = linear convergence tolerance factor; 0.0 indicates default.
IER       = return completion flag.  Values are 0 = success, -1 = memory
            failure, -2 = illegal input.

(5) Re-initialization: FPVREINIT, FPVREINBBD0, FPVREINBBD1
If a sequence of problems of the same size is being solved using the SPGMR
linear solver in combination with the PVBBDPRE preconditioner, then the
PVODE package can be re-initialized for the second and subsequent problems
so as to avoid further memory allocation.  First, in place of the call
to FPVMALLOC, make the following call:
      CALL FPVREINIT(T0, Y0, METH, ITMETH, IATOL, RTOL, ATOL, INOPT,
     1               IOPT, ROPT, IER)
The arguments have the same names and meanings as those of FPVMALLOC,
except that NEQ has been omitted from the argument list (being unchanged
for the new problem).  FPVREINIT performs the same initializations as
FPVMALLOC, but does no memory allocation, using instead the existing
internal memory created by the previous FPVMALLOC call.
     Following the call to FPVREINIT, a call to either FPVBBDIN0 or FPVBBDIN1
may or may not be needed.  First, if the choice between these two options is
the same and the input arguments are the same, no FPVBBDIN* call is needed.
If a different choice of options is desired, or there is a change in input
arguments other than MU, ML or MAXL, then the user program should call one
of the routines FPVREINBBD0 or FPVREINBBD1.  This reinitializes the SPGMR
linear solver, but without reallocating its memory.  The arguments of each
FPVREINBBD* routine have the same names and meanings as the corresponding
FPVBBDIN* routine.  Finally, if the value of MU, ML, or MAXL is being
changed, then a call to FPVBBDIN0 or FPVBBDIN1 must be made, where again a
different choice of that routine is allowed; in this case the SPGMR memory
is reallocated.

(6) The integrator: FCVODE
Carrying out the integration is accomplished by making calls as follows:
      CALL FCVODE (TOUT, T, Y, ITASK, IER)
The arguments are:
TOUT  = next value of t at which a solution is desired (input)
T     = value of t reached by the solver on output
Y     = array containing the computed solution on output
ITASK = task indicator: 0 = normal mode (overshoot TOUT and interpolate)
        1 = one-step mode (return after each internal step taken)
IER   = completion flag: 0 = success, values -1 ... -8 are various
        failure modes (see CVODE User Guide).
The current values of the optional outputs are available in IOPT and ROPT.

(7) Optional outputs: FPVBBDOPT
Optional outputs specific to the SPGMR solver are NPE, NLI, NPS, NCFL,
LRW, and LIW, stored in IOPT(16) ... IOPT(21), respectively.
To obtain the optional outputs associated with the PVBBDPRE module, make
the following call:
      CALL FPVBBDOPT (LENRPW, LENIPW, NGE)
The arguments returned are:
LENRPW = length of real preconditioner work space, in real words.
         This size is local to the current processor.
LENIPW = length of integer preconditioner work space, in integer words.
         This size is local to the current processor.
NGE    = number of g(t,y) evaluations (calls to PVLOCFN) so far.

(8) Computing solution derivatives: FCVDKY
To obtain a derivative of the solution (optionally), of order up to
the current method order, make the following call:
      CALL FCVDKY (T, K, DKY)
The arguments are:
T   = value of t at which solution derivative is desired
K   = derivative order (0 .le. K .le. QU)
DKY = array containing computed K-th derivative of y on return

(9) Memory freeing: FPVBBDF, FCVFREE, and FPVFREEMPI
To the free the internal memory created by the calls to FPVINITMPI,
FPVMALLOC, FPVBBDIN0, and FPVBBDIN1, make the following calls, in this order:
      CALL FPVBBDF
      CALL FCVFREE
      CALL FPVFREEMPI

****************************************************************************/

#include "fcmixpar.h"   /* parameters for function name definitions */

/* Definitions of interface function names */

#if (CRAY)

#define FPV_BBDIN0  FPVBBDIN0
#define FPV_BBDIN1  FPVBBDIN1
#define FPV_REINBBD0  FPVREINBBD0
#define FPV_REINBBD1  FPVREINBBD1
#define FPV_BBDOPT  FPVBBDOPT
#define FPV_BBDF    FPVBBDF
#define FPV_GLOCFN  PVLOCFN
#define FPV_COMMFN  PVCOMMF

#elif (UNDERSCORE)

#define FPV_BBDIN0  fpvbbdin0_
#define FPV_BBDIN1  fpvbbdin1_
#define FPV_REINBBD0  fpvreinbbd0_
#define FPV_REINBBD1  fpvreinbbd1_
#define FPV_BBDOPT  fpvbbdopt_
#define FPV_BBDF    fpvbbdf_
#define FPV_GLOCFN  pvlocfn_
#define FPV_COMMFN  pvcommf_

#else

#define FPV_BBDIN0  fpvbbdin0
#define FPV_BBDIN1  fpvbbdin1
#define FPV_REINBBD0  fpvreinbbd0
#define FPV_REINBBD1  fpvreinbbd1
#define FPV_BBDOPT  fpvbbdopt
#define FPV_BBDF    fpvbbdf
#define FPV_GLOCFN  pvlocfn
#define FPV_COMMFN  pvcommf

#endif


/* CVODE header files  */

#include "llnltyps.h" /* definitions of types real and integer             */
#include "nvector.h"  /* definition of type N_Vector                       */


/* Prototypes: Functions Called by the PVBBDPRE Module */

void PVgloc(integer Nloc, real t, real *yloc, real *gloc, void *f_data);

void PVcfn(integer Nloc, real t, N_Vector y, void *f_data);


/* Declarations for global variables, shared among various routines */

void *PVBBD_Data;


#endif
