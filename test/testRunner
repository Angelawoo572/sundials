#!/usr/bin/env python3
# ---------------------------------------------------------------
# Programmer(s): Steven Smith @ LLNL
#                David J. Gardner @ LLNL
# ---------------------------------------------------------------
# Acknowledgment: Based on code from Chris White @ LLNL
# ---------------------------------------------------------------
# SUNDIALS Copyright Start
# Copyright (c) 2002-2022, Lawrence Livermore National Security
# and Southern Methodist University.
# All rights reserved.
#
# See the top-level LICENSE and NOTICE files for details.
#
# SPDX-License-Identifier: BSD-3-Clause
# SUNDIALS Copyright End
# ---------------------------------------------------------------
# Sundials test runner for CTest.
#
# All output from the test runner output will be collected in
# <build directory>/Testing/Temporary/LastTest.log
# ---------------------------------------------------------------

import argparse
import datetime
import os
import re
import subprocess
import sys


def main():

    parser = argparse.ArgumentParser(description='Run a CI test.')

    # Required inputs
    parser.add_argument('--testname', dest='testName', type=str, required=True,
                        help='name of the test')

    parser.add_argument('--executablename', dest='executableName', type=str,
                        required=True,
                        help='executable, including path')

    parser.add_argument('--outputdir', dest='outputDir', type=str,
                        required=True,
                        help='path to output directory')

    # Optional inputs
    parser.add_argument('--answerdir', dest='answerDir', type=str,
                        help='path to answers directory')

    parser.add_argument('--answerfile', dest='answerFile', type=str,
                        help='answer filename')

    parser.add_argument('--runcommand', dest='runCommand', type=str,
                        help='command used to run test executable, eg. mpirun')

    parser.add_argument('--runargs', dest='runArgs', type=str,
                        help='command line arguments for test executable')

    parser.add_argument('--floatprecision', dest='floatPrecision', type=int,
                        default=4,
                        help='''number of matching digits in floating point
                        comparisons''')

    parser.add_argument('--integerpercentage', dest='integerPercentage',
                        type=int, default=10,
                        help='percentage difference for integer comparisons')

    parser.add_argument('--nodiff', dest='CheckDiff', action='store_false',
                        help='''do not compare the output and answer files,
                        only check the test return value''')

    parser.add_argument('--profile', action='store_true',
                        help='''Gather profiling data (requires Caliper to be
                        enabled)''')

    parser.add_argument('-v', '--verbose', action='store_true',
                        help='run verbosely')

    args = parser.parse_args()

    if args.verbose:
        print("testName       = ", args.testName)
        print("executableName = ", args.executableName)
        print("answerDir      = ", args.answerDir)
        print("answerFile     = ", args.answerFile)
        print("outputDir      = ", args.outputDir)
        print("runCommand     = ", args.runCommand)
        print("runArgs        = ", args.runArgs)
        print("profile        = ", args.profile)

    # Check for output directory
    if not os.path.exists(args.outputDir):
        print("ERROR: Output directory does not exist!")
        sys.exit(1)

    if not os.path.isdir(args.outputDir):
        print("ERROR: Output directory is not a directory!")
        sys.exit(1)

    # Initialize testing result
    success = True

    # -------------------
    # Create test command
    # -------------------

    testCommand = [args.executableName]

    if args.runCommand:
        # remove all quotes
        runCommand = args.runCommand.replace("\"", "").split(" ")
        testCommand = runCommand + testCommand

    if args.runArgs:
        # remove first and last quote
        runArgs = re.sub(r'^"|"$', '', args.runArgs).split(" ")
        testCommand = testCommand + runArgs

    # ----------------------------------------------------
    # Setup CALI_CONFIG environment variable for profiling
    # ----------------------------------------------------

    if args.profile:
        dateTime = datetime.datetime.now().strftime("%m%d%Y_%H%M%S")
        profilePath = os.path.join(args.outputDir,
                                   args.testName+".%s.caliper" % dateTime)
        os.environ['SUNDIALS_VERSION'] = subprocess.check_output(
                ['git', 'describe', '--abbrev=12', '--dirty', '--always',
                 '--tags']).decode('UTF-8').strip()
        os.environ['CALI_SERVICES_ENABLE'] = 'env'
        os.environ['CALI_ENV_EXTRA'] = 'SUNDIALS_VERSION'
        os.environ['CALI_CONFIG'] = 'runtime-report,hatchet-region-profile,output=%s' % profilePath

    # --------
    # Run test
    # --------

    outputFile = os.path.join(args.outputDir, args.testName + ".out")
    outFile = open(outputFile, 'w')
    try:
        if args.verbose:
            print("Starting test...")
            print("  Command = " + ' '.join(testCommand))
            print("  Output File = " + outputFile)
            if args.profile:
                print("  CALI_CONFIG = " + os.environ['CALI_CONFIG'] + "\n")

        # run the test
        process = subprocess.Popen(testCommand, stdout=outFile, stderr=outFile)
        process.wait()

        # check test return value
        if process.returncode != 0:
            print("ERROR: Exited with error code " + str(process.returncode))
            success = False

        # check test output
        if args.CheckDiff:
            if args.answerDir:
                answerDir = args.answerDir
            else:
                answerDir = os.path.join(os.path.dirname(sys.argv[0]),
                                         "answers")
            if args.answerFile:
                answerFile = os.path.join(answerDir, args.answerFile)
            else:
                answerFile = os.path.join(answerDir, args.testName)

            if args.verbose:
                print("Comparing test output and answer files...")
                print("  Answer File = " + answerFile)
                print("  Floating Point Precision = " + str(args.floatPrecision))
                print("  Integer Precision = " + str(args.integerPercentage))

            if not os.path.exists(answerFile):
                print("ERROR: Answer file does not exist.", answerFile)
                success = False
            if not os.path.isfile(answerFile):
                print("ERROR: Answer file is not a file.", answerFile)
                success = False

            if not compare(outputFile, answerFile, args.integerPercentage,
                           args.floatPrecision):
                print("ERROR: Output and answer file do not match.")
                success = False
    finally:
        outFile.close()

    if success:
        print("Test passed.")
        sys.exit(0)
    else:
        print("Test failed.")
        sys.exit(1)


def compare(outputFile, answerFile, integerPercentage, floatPrecision):
    # Note: This functions strips all lines of leading and trailing whitespace
    # and blank lines. Then it compares the output against the answer file. It
    # allows fuzziness in floating points and integers.
    outFile = open(outputFile, 'r')
    try:
        outLines = stripLines(outFile.readlines())
    finally:
        outFile.close()
    answerFile = open(answerFile, 'r')
    try:
        answerLines = stripLines(answerFile.readlines())
    finally:
        answerFile.close()
    if len(outLines) != len(answerLines):
        print("ERROR: Line count is not equal (blank lines ignored):")
        print("  Output = " + str(len(outLines)) + "lines")
        print("  Answer = " + str(len(answerLines)) + "lines")
        return False
    diffCount = 0
    for i, outLine in enumerate(outLines):
        answerLine = answerLines[i]
        if not compareLines(outLine, answerLine, integerPercentage,
                            floatPrecision):
            diffCount += 1
            print("ERROR: Lines Differ:")
            print("  Output = " + outLine)
            print("  Answer = " + answerLine + "\n\n")
    if diffCount != 0:
        print("ERROR: " + str(diffCount) + " line differences found.")
        return False
    return True


def compareLines(outLine, answerLine, integerPercentage, floatPrecision):
    outTokens = tokenizeLine(outLine)
    answerTokens = tokenizeLine(answerLine)
    if len(outTokens) != len(answerTokens):
        print("DEBUG: number of tokens differs")
        print(answerTokens)
        print("----------")
        print(outTokens)
        print("----------")
        return False

    for i, outValue in enumerate(outTokens):
        answerValue = answerTokens[i]
        outIsInt, outInt = isInt(outValue)
        if outIsInt:
            answerIsInt, answerInt = isInt(answerValue)
            if not answerIsInt:
                print("ERROR: The output is a int but answer is not.")
                return False
            elif not intCompare(answerInt, outInt, integerPercentage):
                return False
        else:
            outIsFloat, outFloat = isFloat(outValue)
            if outIsFloat:
                answerIsFloat, answerFloat = isFloat(answerValue)
                if not answerIsFloat:
                    print("ERROR: The output is a float but answer is not.")
                    return False
                elif not floatCompare(answerFloat, outFloat, floatPrecision):
                    return False
            elif outValue != answerValue:
                print("Error: String difference found:")
                print("  Output = " + outValue)
                print("  Answer = " + answerValue)
                return False
    return True


def isInt(value):
    # Check if string can be converted to int
    try:
        return True, int(value)
    except ValueError:
        return False, 0


def intCompare(answer, value, percentage):
    # Check if integer error greater than the allowed percentage
    if answer == value:
        return True
    if percentage != 0:
        percentageOff = abs(int(100 - (float(value)/float(answer) * 100)))
        if percentageOff <= percentage:
            return True
    print("Error: Integer difference found:")
    print("  Output    = " + str(value))
    print("  Answer    = " + str(answer))
    print("  Allowance = " + str(percentage) + "%")
    return False


def isFloat(value):
    # Check if string can be converted to float
    try:
        return True, float(value)
    except ValueError:
        return False, 0


def floatCompare(answer, value, precision):
    # Check if floating point numbers match to a given number of digits
    if answer == value:
        return True
    if precision > 0:
        if round(answer, precision) == round(value, precision):
            return True
    print("Error: Floating point difference found:")
    print("  Output    = " + str(value))
    print("  Answer    = " + str(answer))
    print("  Allowance = " + str(precision) + " decimals")
    return False


def tokenizeLine(line):
    return tokenizeLine.pattern.split(line)


# Precompile a pattern since it will be used many times
tokenizeLine.pattern = re.compile(r';|,|\s+|=+|:|\|\(|\)')


def stripLines(lines):
    strippedLines = []
    for line in lines:
        strippedLine = line.strip()
        if strippedLine != "":
            strippedLines.append(strippedLine)
    return strippedLines


if __name__ == "__main__":
    main()
