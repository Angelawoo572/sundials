\section{Usage} 
\label{s:usage}

The new design and organization of SUNDIALS 
as described in Section~\ref{s:organization}
makes the codes surprisingly flexible and easy to use.
This versatility is primarily due to the control that the user has
over the modules that comprise SUNDIALS: the specification of vectors;
the linear solver and preconditioner methods; the basic solvers; and,
sensitivity analysis.
Default routines are provided for the NVECTOR specification and
computing Jacobian-vector approximations, for example. But for these
routines and other basic operations, SUNDIALS allows the user to provide
their own variants that may be better suited to their problem-solving
needs. 
Additionally, SUNDIALS provides the user with a fine level of control
over various algorithmic parameters, heuristic values, and data
structure pointers contained within the codes.
Finally, SUNDIALS provides optional routines for extracting the
solution, solver statistics and other useful information from the codes.

A general approach for using SUNDIALS is given below. 
The outline conveys the basic elements of what is needed to properly
specify and solve a problem, the order in which certain tasks must be
done, indicates the opportunities for providing user-supplied
routines or input values, and so on.
Complete details and additional examples are in the documentation that
accompanies each solver in SUNDIALS.

\begin{enumerate}

\item \label{sun_headers}
SUNDIALS contains header files that define various constants,
enumerations, macros, data types and function prototypes.  At a
minimum, the user must include header files that declare: the SUNDIALS
data types for real, integer, and boolean variables; the content and
operations that can be performed on vectors in either a serial or
parallel environment; and, the functions needed by the solver to
setup, compute, and extract the solution. Typically, additional header
files will be specified to declare the preconditioning and/or linear
solver methods to be used.

\item \label{sun_problem}
The user must provide a function for evaluating the equations to be
solved. Optionally, a user-defined data structure can be created and
passed to this function. The user must also initialize the vector
specification data structure, give the problem size and error
tolerances, provide a suitable initial guess or initial values, along
with other details for the problem.

\item \label{sun_create}
The next step is to call a routine for initializing a block of memory
that will be used in solving the problem. The memory block is created
with certain default values for the solver, such as the use of
standard output for writing warning and error messages, or {\tt NULL}
as a default value for the pointer to the user-specified data
structure to be passed in evaluating the user's function.

\item \label{sun_set}
At this stage, the default values in the solver memory block can be
changed if so desired. Choices and default values are given in the
following subsections for each of the basic solvers.

\item \label{sun_malloc}
The user now calls the appropriate routine to perform any required
memory allocation, after checking the initialized memory block for
errors in the default or optional inputs.

\item \label{sun_linear}
Typically, preconditioning and/or linear solver methods are needed for
solving the linear systems that may arise. These methods can now be
attached to the block of memory allocated for the solver.

\item \label{sun_solve}
Solve the problem. Information and solver statistics are available
through extraction functions.

\item \label{sun_reinit}
Re-initialization (SUNDIALS solver, linear solver)?

\item \label{sun_finalize}
To complete the process, the user must make the appropriate calls to
free memory that was allocated in the previous steps.

\end{enumerate}

For a parallel machine environment, the appropriate header file for
MPI must be specified in Step~\ref{sun_headers}; and, the MPI communicator,
active set of processors, local and global vectors lengths must be
initialized or given in Step~\ref{sun_problem}. Finally, in
Step~\ref{sun_finalize}, memory allocated for MPI must be freed.

For forward sensitivity analysis, the appropriate forward sensitivity
header file must be specified in Step~\ref{sun_headers} and the
definition of the sensitivity problem must be given before
Step~\ref{sun_solve}. To do so, the user must create an array of
real parameters upon which the problem solution depends; attach a pointer to
this array to the user-defined data structure f\_data; specify the
number of sensitivities to be computed; and, provide an array to
specify the parameters for which solution sensitivities are to be
computed. Memory allocated for sensitivity analysis should be freed in
Step~\ref{sun_finalize}.

{\sf For adjoint sensitivity analysis, we refer the interested reader to
the user's guide.}

\subsection{Optional inputs and outputs}\label{ss:optional_io}

Within SUNDIALS, an attempt is made to set reasonable defaults for the
various methods, heuristics, parameters and pointers used in the
codes. 
A key feature of SUNDIALS is that it provides a collection of optional
input and output routines so that default settings can be changed, or
various solver statistics and other information can be extracted.
These routines are available for each of the solvers as noted, and for
the linear solver and preconditioning methods that support them.

\subsubsection*{Basic Solvers} 
Table \ref{t:optional_io} lists in its top half the various optional 
inputs that the user can change to control the basic SUNDIALS solvers.
Under each solver column we give the default value for the optional 
input. Inputs marked with a ``-'' are not applicable to that particular 
solver. The bottom half of the table lists the various optional 
outputs that the user can access to monitor solver performance.
Optional outputs available for a solver are marked with a ``$\surd$''
and those not available are marked by a ``-''.

\begin{table}[tp]
\label{t:optional_io}
\centering
\caption{List of optional inputs and outputs for the basic solvers in SUNDIALS}
\medskip
\begin{tabular}{|p{2.75in}|c|c|c|}
\hline
{\bf Optional input} & CVODE  & IDA & KINSOL \\
\hline
Pointer to the user-defined data & NULL & NULL& NULL \\
Pointer to an error file & NULL & NULL & NULL \\
Maximum order for BDF method & 5 & 5 & - \\
Maximum order for Adams method& 12  & - & - \\
Maximum number of internal steps before $t_{out}$ & 500 & 500 & - \\
Maximum number of warnings for $h < U$ & 10 & - & - \\
Flag to activate stability limit detection & FALSE & - & - \\
Initial step size & est. & est. & - \\
Minimum absolute step size & 0.0 & - & - \\
Maximum absolute step size & $\infty$ & $\infty$ & - \\
Value of $t_{stop}$ & - & $\infty$ & - \\
Maximum number of Newton iterations & 3 & 3 & 200 \\
Maximum number of convergence failures & 10 & 10 & - \\
Maximum number of error test failures & 7 & 10 & - \\
Coefficient in the nonlinear convergence test & 0.1 & 0.33 & - \\
Flag to exclude algebraic variables from error test & - & FALSE & - \\
differential-algebraic identification vector & - & NULL & - \\
Vector with additional constraints & - & NULL & NULL \\
Level of printing & - & - & none \\
Flag to skip initial linear solver setup call & - & - & FALSE \\
Maximum number of prec. solves without setup & - & - & 10 \\
Flag for selection of $\eta$ computation & - & - & choice 1 \\
Constant $\eta$ value & - & - & 0.1 \\
Parameters $\alpha$ and $\gamma$ in $\eta$ choice 2 & - & - & $2.0$,$0.9$\\
Flag to control minimum value for $\epsilon$ & - & - & FALSE \\
Maximum length of Newton step & - & - & est. \\
Relative error in computing $F(u)$ & - & - & $U$ \\
%Constant to restrict solution update & - & - & $\infty$ \\
Stopping tolerance on residual & - & - & $U^{1/3}$ \\
Stopping tolerance on max. scaled step & - & - & $U^{2/3}$ \\
\hline
\hline
{\bf Optional output} &  &  & \\
\hline
Size of workspace allocated by the solver & $\surd$ & $\surd$ & $\surd$ \\
Cumulative number of internal steps taken & $\surd$ & $\surd$ & - \\
Number of calls to the user's function & $\surd$ & $\surd$ & $\surd$ \\
Number of calls to the linear solver's setup routine & $\surd$ & $\surd$ & - \\
Number of local error test failures that have occurred & $\surd$ & $\surd$ & - \\
Number of nonlinear solver iterations & $\surd$ & $\surd$ & $\surd$ \\
Number of nonlinear convergence failures & $\surd$ & $\surd$ & - \\
Order used during the last step & $\surd$ & $\surd$ & - \\
Order to be attempted on the next step & $\surd$ & $\surd$ & - \\
Order reductions due to stability limit detection & $\surd$ & - & - \\
Actual initial step size used & $\surd$ & $\surd$ & - \\
Step size used for the last step & $\surd$ & $\surd$ & - \\
Step size to be attempted on the next step & $\surd$ & $\surd$ & - \\
Current internal time reached by the solver & $\surd$ & $\surd$ & - \\
%Suggested factor for tolerance scaling & $\surd$ & - & - \\
Vector containing the error weights for state variables & $\surd$ & $\surd$ & - \\
Vector containing the est. local errors & $\surd$ & - & - \\
Number of backtrack operations during linesearch & - & $\surd$ & $\surd$ \\
Number of times the $\beta$ condition could not & - & - & $\surd$ \\
Scaled norm at a given iteration & - & - & $\surd$ \\
Last step length in the global strategy routine & - & - & $\surd$ \\
\hline
\end{tabular}
\end{table}

\subsubsection*{Sensitivity Analysis}

Each sensitivity solver (CVODES and IDAS) offers the complete list of
optional inputs and outputs as the corresponding basic solver (CVODE
and IDA, respectively). In addition, the user has control over various
inputs that affect sensitivity calculations. 
The following are examples of options that can be set by the user,
with the default given in parentheses: a user-supplied routine
to compute sensitivity ODEs or DAE sensitivity residuals (CVODES or
IDAS difference quotient approximation); a pointer to user data that
will be passed to this user-supplied ODE or DAE sensitivity routine (NULL); a
pointer to the sensitivity relative error tolerance scalar (same value as
for state variables); and, the type of error control (FULL).
For more options and details, see \cite{SeHi:03}, \cite{HiSe:02}.

\subsubsection*{Linear Solvers and Preconditioners}

For any of the linear solvers, the user can set optional inputs so 
that a user-supplied routine providing Jacobian-related information
is used instead of the default difference quotient routine. 
Also, a pointer can be set so that user data is passed each time this
user-supplied routine is called. In addition, for the SPGMR case,
the following can be optionally changed from their default values
(provided in parentheses): a classical Gram-Schmidt orthogonalization 
can be used (modified Gram-Schmidt), the factor by which the tolerance on the
nonlinear iteration is multiplied to get a tolerance on the linear
iteration (0.05), the preconditioner setup routine (NULL), the
preconditioner solver routine (NULL), and a pointer to the user
preconditioner data (NULL).

The optional outputs for any of the linear solvers are: the amount of 
integer and real workspace used; the number of calls made to the user-supplied 
Jacobian evaluation routine; and, the number of calls to the user's function 
due to the default difference quotient routine.
In addition, for the SPGMR case, the user can obtain the number of preconditioner
evaluations, the number of calls made to the preconditioner solve
routine, the number of linear iterations, and the number of linear
convergence failures.

For the band block diagonal preconditioner, the optional outputs are:
the amount of integer workspace used, the amount of real workspace
used; and, the number of calls to the local function that approximates
the user's function.

\subsection{Fortran Usage} 
\label{ss:Fortran_usage}

Some support is available for using Fortran77 applications with SUNDIALS.
In particular, a Fortran/C interface package is provided with CVODE
and KINSOL.
Each package is a collection of C header files and functions which
enables the user to write a main program and all user-supplied
routines in Fortran77, and use either CVODE or KINSOL to solve the
problem.
This mixed-language capability entails some compromises in
portability, such as requiring fixed names for the user-supplied
routines, but the restrictions are minor.
For complete details, see the user documentation for each of the solvers 
in SUNDIALS (\cite{HiSe:03a}, \cite{HiSe:03c}).
