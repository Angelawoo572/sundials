\section{Usage}

A general approach for using SUNDIALS is given below. 
The outline conveys the basic elements of what is needed to properly
specify and solve a problem, the order in which certain tasks must be
done, the options available for modifying certain solver parameters,
heuristics and algorithms, and the options for extracting the solution
and/or solver statistics.
Complete details and additional examples are in the documentation that
accompanies each solver in SUNDIALS.

\begin{enumerate}

\item SUNDIALS contains header files that define various
constants, enumerations, macros, data types and function prototypes.
At a minimum, the user must include header files that declare: the
SUNDIALS data types for real, integer, and boolean variables; the
content and operations that can be performed on vectors in either a
serial or parallel environment; and, the functions needed
by the solver to setup, compute, and extract the solution. 
Typically, additional header files will be specified to declare the
preconditioning and/or linear solver methods to be used.

\item The user must provide a function for evaluating the equations to
be solved. Optionally, a user-defined data structure can be created
and passed to this function. The user must also provide a suitable
initial guess or initial values, specify error tolerances, along with
other details for the problem.

\item The next step is to call a routine for initializing a block of
memory that will be used in solving the specified problem. The memory
block is created with certain default values for the solver, such as
the use standard output for writing warning and error messages, or
{\tt NULL} as a default value for the pointer to the user-specified
data structure to be passed in evaluating the user's function.

\item At this stage, the default values in the solver memory block can
be changed if so desired. Choices and default values are given in the
following subsections for each of the basic solvers.

\item The user now calls the appropriate routine to perform
any required memory allocation, after checking the initialized memory
block for errors in the default or optional inputs.

\item Typically, preconditioning and/or linear solver methods are
needed for solving the linear systems that may arise. These methods
can now be attached to the block of memory allocated for the solver.

\item Solve the problem. Information and solver statistics are
available through extraction functions.

\item (Re-initialize the problem?)

\item To complete the process, the user must make the appropriate calls to
free memory that was allocated in the previous steps.

\end{enumerate}

How do the steps change for parallel machine environments? \\
How do the steps change for forward sensitivity analysis? \\
How do the steps change for adjoint sensitivity analysis? \\
Give the set() and get() routines for the subsections below. \\

\subsection{CVODE}

The following options can be set by the user; otherwise, the option
retains the default setting that appears in the brackets {\tt []}:
a pointer to the user-defined data structure that is passed to the
user's $f$ routine [{\tt NULL}]; a pointer to an error file where all
warning and error messages will be written [{\tt NULL} means standard
output]; the maximum order used by the Adams method [12] or BDF method
[5]; the maximum number of internal steps to be taken in its attempt
to reach the next output time [500]; the maximum number of warning
messages issued when the internal step size is below machine epsilon
[10]; a flag to activate stability limit detection [{\tt FALSE}]; the
initial step size [estimated by the solver]; the minimum absolute step
size value allowed [0.0]; the maximum absolute step size value allowed
[infinity]; and, the independent variable value past which the
solution is not to proceed [infinity].

If desired, the user can request the following information from the
solver: the amount of integer workspace allocated by CVODE; the amount
of real workspace allocated by CVODE; the cumulative number of
internal steps taken; the number of calls to the user's
f function; the number of calls made to the linear solver's setup
routine; the number of local error test failures that have occurred;
the order used during the last internal step; the number of order
reductions due to stability limit detection; the actual initial step
size used; the step size used for the last internal step; the step
size to be attempted on the next internal step; the current internal
time reached by the solver; a suggested factor by which the user's
tolerances should be scaled when too much accuracy has been requested
for some internal time steps; the vector containing the error weights
for the state variables; and, the vector containing the estimated
local errors at the current internal time step.

\subsection{KINSOL}

(draft) \\
The following options can be set by the user; otherwise, the option
retains the default setting that appears in the brackets {\tt []}:
a pointer to the user data that will be passed to the user's $F$
routine [{\tt NULL}]; a pointer to an error file where all
warning and error messages will be written [{\tt NULL} means standard
output]; an integer value between 0--3 to indicated the desired amount
of convergence-related output [{\tt 0} means no statistics printed];
the maximum allowable number of nonlinear iterations [{\tt
MXITER\_DEFAULT}]; a flag to control the initial call to the
preconditioner setup routine [{\tt FALSE} forces the initial call];
the maximum number of steps calling the preconditioner solve without
calling the preconditioner setup [10]; a flag indicating which of
three methods to use for computing the coefficient ($\eta$) in the linear
solver convergence tolerance epsilon~(?) [{\tt ETACHOICE1}]; the
constant value of $\eta$ for {\tt ETACONSTANT} [0.1]; the parameter
values for $\eta$ in the case {\tt ETACHOICE2} [egamma=0.9,
ealpha=2.0]; the flag to control the lower bound on the linear solver
convergence tolerance ($\epsilon$) [{\tt FALSE}]; the maximum
allowable length of a Newton step [{\tt default}]; the relative error
in computing {\tt func(uu)} [{\tt unit roundoff}]; a scalar constant
which restricts the update of uu [{\tt infinity}]; a real scalar value
containing the stopping tolerance; a real scalar value containing the
stopping tolerance on the maximum scaled step [{\tt default}]; a
pointer to an array of constraints on uu [{\tt NULL}].

If desired, the user can request the following information from the
solver: the amount of integer workspace allocated by KINSOL; the
amount of real workspace allocated by KINSOL; the number of calls to
the user's {\tt func} function; the number of nonlinear iterations
performed; the total number of times the $\beta$ condition could not
be met in the line search algorithm; the number of backtrack
operations done in the linesearch algorithm; the scaled norm at a
given iteration; and, the last step length in the global strategy
routine.

\subsection{IDA}

The following options can be set by the user; otherwise, the option
retains the default setting that appears in the brackets {\tt []}:
a pointer to the user data structure that will be passed to the user's
$F$ routine [{\tt NULL}]; a file pointer to an error file where
all warning and error messages will be written [{\tt NULL}]; the
maximum order used by the BDF method [5]; the maximum number of
internal steps to be taken in an attempt to reach the next output time
[500]; the initial step size [estimated by the solver]; the maximum
absolute step size allowed [{\tt infinity}]; the independent variable
value past which the solution is not to proceed [{\tt infinity}]; the
factor in nonlinear convergence test for use during integration [1.0];
a flag to indicate whether or not to suppress algebraic variables in
the local error test [{\tt FALSE}]; a vector which indicates whether a
given component is either an algebraic or differential variable [0.0
and 1.0 indicate algebraic and differential variables, respectively];
a vector defining inequality constraints for each component of the
solution vector [0.0 means the corresponding component has no
constraint; etc.].

If desired, the user can request the following information from the
solver: the amount of integer workspace allocated by IDA; the amount
of real workspace allocated by IDA; the cumulative number of internal
steps taken; the number of calls to the user's {\tt res} function; the
number of calls made to the linear solver's setup routine; the number
of local error test failures that have occurred; the number of
backtrack operations done in the linesearch algorithm of the
consistent initialization routine; the order used during the last
internal step; the order to be used on the next internal step; the
actual initial step size used; the step size for the last internal
step, or the last value of the artificial step size in calculating
consistent initial conditions; the step size to be attempted on the
next internal step; the current internal time reached; a suggested
factor by which the user's tolerances should be scaled when too much
accuracy has been requested for some internal step; the vector
containing the error weights for the state variables; and, the vector
containing the estimated local error at the current internal time steps.

\subsection{Fortran Usage}

For two of the SUNDIALS solvers -- CVODE and KINSOL, users with
Fortran applications are accommodated.  This is done with a set of
interface routines that connect the C solver with the user's Fortran
routines.

In order to achieve portability for these interfaces, all of the
Fortran user-supplied routines have fixed names.

These interfaces are provided as separate modules, called FCVODE and
FKINSOL, for CVODE and KINSOL, respectively.  In each case, small
examples programs are provided.

For complete details,
see the user documentation for each of the solvers in SUNDIALS.




