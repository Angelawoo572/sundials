\section{Usage}
\label{s:usage}

A brief outline is given for using the serial version of CVODE to solve
a nonstiff initial-value problem.
This example conveys the basic elements of including appropriate
header files; declaring function prototypes and user-supplied data
structures; creating, manipulating, and freeing N\_Vector and CVODE
memory; 
calling CVODE to solve the initial-value problem; etc.
Complete details and additional examples are in the documentation that
accompanies each solver in SUNDIALS.

\begin{enumerate}
\item With a {\bf \#include} statement, the following header files must be
specified for this example: {\bf ``sundialstypes.h''} for defining
real, integer and boolean types; {\bf ``nvector\_serial.h''} for
defining the content and operations that can be performed on vectors
in a serial machine environment; and, {\bf ``cvode.h''} for defining
operations involving CVODE memory. Of course, if the solution process
requires the use of preconditioning and/or linear solver methods then
the appropriate set of header files must also be added.

\item In defining a C routine that calculates the derivatives
$u'=f(t,u)$, the right-hand side function must have the prototype \\
{\bf static void f(realtype t, N\_Vector u, N\_Vector udot, void
*f\_data);} \\
in which {f\_data} is an optional user-defined data structure
that may be used in calculating the derivative values returned in {udot}.

\item Within the main program, the user should begin with declarations such as
\\
{\bf realtype t;~},{\bf NV\_Spec nvSpec;~}, {\bf N\_Vector u;~}, {\bf
void *cvode\_mem;~} \\
for defining the time variable $t$, the vector specification data structure, the
solution $u$, and a pointer to CVODE memory, respectively.
Additional declarations may include loop counters or status flags of
type {int}, absolute and relative ODE error tolerances of type
{N\_Vector} and/or {realtype}, and user-defined data structures
for preconditioning and/or evaluating $f(t,u)$.

\item The routines {\bf NV\_SpecInit\_Serial} and {\bf N\_VNew} must be called for
allocating memory for the vector specification data structure (nvSpec)
and any N\_Vector types such as u.  The argument list and user
description of each routine is given in the header files
``nvector\_serial.h'' and ``nvector.h''.

\item Before leaving this step, the ODE problem to be solved should be completely
specified: the initial value for time $t$, initial conditions for $u$,
absolute and relative error tolerances (atol, rtol), and the next time
($t_{\rm out}$) at which output is desired.

\item The next phase initializes CVODE memory and
allows the user to set different default values for the solver.
As described in ``cvode.h'', CVODE memory can be initialized with \\
{\bf cvode\_mem = CVodeCreate(ADAMS, FUNCTIONAL)}\\
if we want functional iteration to be used within Adams method for
solving the nonstiff initial-value problem.
By default, the maximum order used for the Adams method is 12 but 
{\bf CVodeSetMaxOrd} can be called to set it to a lower value.
CVODE contains eight other optional set routines, including
{\bf CVodeSetFdata} for passing the optional user-defined data
structure f\_data to the user's f() routine.
The CVODE memory allocation is finalized with a call such as \\
{\bf flag = CVodeMalloc(cvode\_mem, f, t0, u, SS, \&rtol, \&atol,
nvSpec);} \\
in which $t0$ and $u$ define the initial conditions.

\item Although not needed in this example involving functional
iteration (i.e., no linear systems are solved), typically this step
involves the specification and attachment of desired preconditioning
and/or linear solver methods to CVODE memory. To do so, the
appropriate set of header files need to be specified in Step 1 with
calls made at this step according to the descriptions provided in
those header files.

\item At this point, {\bf CVode} can be called to integrate the
problem in the direction from $t$ to $t_{\rm out}$. The call to the
integrator includes an option to specify either one-step mode (take
one step and return) or normal mode (take steps until passing 
$t_{\rm out}$ and interpolate).
For the latter, \\
{\bf flag = CVode(cvode\_mem, tout, u, \&t, NORMAL);} \\
computes the solution $u$ at time $t_{\rm out}$. Note that to compute
solutions at additional points in time, the call to CVode can be
embedded in a for-loop.

\item At each output time or before exiting the program, the solution
and solver statistics can be obtained by using various routines such
as {\bf CVodeGetNumSteps} to determine the cumulative number of
internal time steps taken taken by the solver, or {\bf
CVodeGetNumRhsEvals} to determine the number of calls to the user's
f() routine. A total of 16 such routines are given in ``cvode.h''.

\item The memory allocated in Steps 4--6 can be freed by at least calling
{\bf CVodeFree(cvode\_mem);~}, {\bf N\_VFree(u);~}, and {\bf
NV\_SpecFree\_Serial(nvSpec);}. Of course, the user must free other
allocated memory or user-defined data structures if necessary---and do so in the
correct order.

\end{enumerate}


\section{Fortran Usage}

For two of the SUNDIALS solvers -- CVODE and KINSOL, users with
Fortran applications are accommodated.  This is done with a set of
interface routines that connect the C solver with the user's Fortran
routines.

The cross-language calls go in both directions:
\newline \hspace*{.5in} user's Fortran Main $\longrightarrow$
interfaces $\longrightarrow$ solver routines, and
\newline \hspace*{.5in} Solver routines $\longrightarrow$ interfaces
$\longrightarrow$ user's {\tt f} routine etc.

In order to achieve portability for these interfaces, all of the
Fortran user-supplied routines have fixed names.

These interfaces are provided as separate modules, called FCVODE and
FKINSOL, for CVODE and KINSOL, respectively.  In each case, small
examples programs are provided.


