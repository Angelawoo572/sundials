%includefile "/home/balos1/.local/share/swig/4.0.0/swig.swg" %beginfile
/* -----------------------------------------------------------------------------
 * swig.swg
 *
 * Common macro definitions for various SWIG directives.  This file is always 
 * included at the top of each input file.
 * ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
 * User Directives 
 * ----------------------------------------------------------------------------- */

/* Deprecated SWIG-1.1 directives */













/* Code insertion directives such as %wrapper %{ ... %} */







/* Class extension */



/* %ignore directive */




/* Access control directives */









/* Generation of default constructors/destructors (old form, don't use) */





/* Disable the generation of implicit default constructor */




/* Disable the generation of implicit default destructor (dangerous) */




/* Enable the generation of copy constructor */




/* Force the old nodefault behavior, ie disable both constructor and destructor */




/* the %exception directive */








/* the %allowexception directive allows the %exception feature to
   be applied to set/get variable methods */




/* the %exceptionvar directive, as %exception but it is only applied
   to set/get variable methods. You don't need to use the
   %allowexception directive when using %exceptionvar.
*/








/* the %catches directive */



/* the %exceptionclass directive */




/* the %newobject directive */




/* the %delobject directive */




/* the %refobject/%unrefobject directives */








/* Directives for callback functions (experimental) */




/* the %nestedworkaround directive (deprecated) */




/* the %flatnested directive */




/* the %fastdispatch directive */




/* directors directives */




/* naturalvar directives */




/* nspace directives */




/* valuewrapper directives */





/* Contract support - Experimental and undocumented */




/* Macro for setting a dynamic cast function */






/* aggregation support */
/*
  This macro performs constant aggregation.  Basically the idea of
  constant aggregation is that you can group a collection of constants
  together.  For example, suppose you have some code like this:

       #define UP  1
       #define DOWN 2
       #define LEFT 3
       #define RIGHT 4

  Now, suppose you had a function like this:

       int move(int direction)

  In this case, you might want to restrict the direction argument to
  one of the supplied constant names. To do this, you could write some
  typemap code by hand.  Alternatively, you can use the
  %aggregate_check macro defined here to create a simple check
  function for you.  Here is an example:

    %aggregate_check(int, check_direction, UP, DOWN, LEFT, RIGHT);

  Now, using a typemap

    %typemap(check) int direction {
      if (!check_direction($1)) SWIG_exception(SWIG_ValueError,"Bad direction.");
    }

  or a contract (better)

    %contract move(int x) {
    require:
        check_direction(x);
    }

*/
   















/* -----------------------------------------------------------------------------
 * %rename predicates
 * ----------------------------------------------------------------------------- */
/* 
   Predicates to be used with %rename, for example:

   - to rename all the functions:

     %rename("%(utitle)s", %$isfunction) "";

   - to rename only the member methods:

     %rename("m_%(utitle)s", %$isfunction, %$ismember) "";

   - to rename only the global functions:

      %rename("m_%(utitle)s", %$isfunction, %$not %$ismember) "";

     or

      %rename("g_%(utitle)s", %$isfunction, %$isglobal) "";

   - to ignore the enumitems in a given class:

     %rename("$ignore", %$isenumitem, %$classname="MyClass") "";

   we use the prefix '%$' to avoid clashes with other swig
   macros/directives.

*/

 









  /* %constant definition */































/* -----------------------------------------------------------------------------
 * Common includes for warning labels, macros, fragments etc
 * ----------------------------------------------------------------------------- */

%includefile "/home/balos1/.local/share/swig/4.0.0/swigwarnings.swg" %beginfile
/*
  Include the internal swig macro codes. These macros correspond to
  the one found in Source/Include/swigwarn.h plus the 'SWIG' prefix.
  
  For example, in the include file 'swigwarn.h' you will find

    #define WARN_TYPEMAP_CHARLEAK ...

  and in the 'swigwarn.swg' interface, you will see

    %define SWIGWARN_TYPEMAP_CHARLEAK ...

  This code can be used in warning filters as follows:

    %warnfilter(SWIGWARN_TYPEMAP_CHARLEAK);

  Warnings messages used in typemaps. Message names will be the same
  as those in Lib/swigwarn.swg but with the suffix _MSG.
   
  For example, for the code SWIGWARN_TYPEMAP_CHARLEAK, once you use

    %typemapmsg(CHARLEAK,<msg>);

  you use the message in your typemap as

    %typemap(varin,warning=SWIGWARN_TYPEMAP_CHARLEAK_MSG) char * 

  while you suppress the warning using

    %warnfilter(SWIGWARN_TYPEMAP_CHARLEAK);

  as described above.
*/

/* -----------------------------------------------------------------------------
 * SWIG warning codes
 * ----------------------------------------------------------------------------- */

%includefile "/home/balos1/.local/share/swig/4.0.0/swigwarn.swg" %beginfile
/* SWIG warning codes */




/* -- Deprecated features -- */




























/* -- Preprocessor -- */








/* -- C/C++ Parser -- */





























  /* redundant now */
  /* redundant now */


	/* new */
	/* delete */
	/* + */
	/* - */
	/* * */
	/* / */
	/* % */
	/* ^ */
	/* & */
	/* | */
	/* ~ */
	/* ! */
	/* = */
	/* < */
	/* > */
	/* += */
	/* -= */
	/* *= */
	/* /= */
	/* %= */
	/* ^= */
	/* &= */
	/* |= */
	/* << */
	/* >> */
	/* <<= */
	/* >>= */
	/* == */
	/* != */
	/* <= */
	/* >= */
	/* && */
	/* || */
	/* ++ */
	/* -- */
	/* , */
	/* ->* */
	/* -> */
	/* () */
	/* [] */
	/* + */
	/* - */
	/* * */
	/* & */
	/* new [] */
	/* delete [] */
	/* operator *() */

/* 394-399 are reserved */

/* -- Type system and typemaps -- */























	/* mostly used in directorout typemaps */








/* -- Fragments -- */


/* -- General code generation -- */

























/* -- Doxygen comments -- */








/* -- Reserved (600-799) -- */

/* -- Language module specific warnings (700 - 899) -- */

















/* please leave 700-719 free for D */



/* please leave 720-739 free for Scilab */



/* please leave 740-759 free for Python */












/* please leave 760-779 free for Fortran */




/* please leave 800-809 free for Ruby */



















/* please leave 810-829 free for Java */



















/* please leave 830-849 free for C# */













/* please leave 850-869 free for Modula 3 */





/* please leave 870-889 free for PHP */



/* please leave 890-899 free for Go */

/* -- User defined warnings (900 - 999) -- */

%endoffile

/* -----------------------------------------------------------------------------
 * Auxiliary macros
 * ----------------------------------------------------------------------------- */

/* Macro to define warning messages */



/* -----------------------------------------------------------------------------
 *  Typemap related warning messages
 * ----------------------------------------------------------------------------- */







/* -----------------------------------------------------------------------------
 * Operator related warning messages 
 * ----------------------------------------------------------------------------- */



















































/* -----------------------------------------------------------------------------
 * Macros for keyword and built-in names 
 * ----------------------------------------------------------------------------- */





/* -----------------------------------------------------------------------------
 * Warning filter feature
 * ----------------------------------------------------------------------------- */






%endoffile
%includefile "/home/balos1/.local/share/swig/4.0.0/swigfragments.swg" %beginfile
/* -----------------------------------------------------------------------------
 * swigfragments.swg
 *
 * Common fragments
 * ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
 * Fragments for C header files
 * ----------------------------------------------------------------------------- */

%fragment("<float.h>", "header") %{
#include <float.h>
%}

/* Default compiler options for gcc allow long_long but not LLONG_MAX. 
 * Define SWIG_NO_LLONG_MAX if this added limits support is not wanted. */
%fragment("<limits.h>", "header") %{
#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif
%}

%fragment("<math.h>", "header") %{
#include <math.h>
%}

%fragment("<string.h>", "header") %{
#include <string.h>
%}

%fragment("<stddef.h>", "header") %{
#include <stddef.h>
%}

%fragment("<stdio.h>", "header") %{
#include <stdio.h>
#if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
# ifndef snprintf
#  define snprintf _snprintf
# endif
#endif
%}

%fragment("<stdlib.h>", "header") %{
#include <stdlib.h>
#ifdef _MSC_VER
# ifndef strtoull
#  define strtoull _strtoui64
# endif
# ifndef strtoll
#  define strtoll _strtoi64
# endif
#endif
%}

%fragment("<wchar.h>", "header") %{
#include <wchar.h>
#include <limits.h>
#ifndef WCHAR_MIN
#  define WCHAR_MIN 0
#endif
#ifndef WCHAR_MAX
#  define WCHAR_MAX 65535
#endif
%}

/* -----------------------------------------------------------------------------
 * Fragments for C++ header files
 * ----------------------------------------------------------------------------- */

%fragment("<algorithm>", "header") %{
#include <algorithm>
%}

%fragment("<stdexcept>", "header") %{
#include <stdexcept>
%}

%fragment("<string>", "header") %{
#include <string>
%}

%fragment("<memory>", "header") %{
#include <memory>
%}

%fragment("<utility>", "header") %{
#include <utility>
%}

%fragment("<cctype>", "header") %{
#include <cctype>
%}
%endoffile

/* -----------------------------------------------------------------------------
 * Overloading support
 * ----------------------------------------------------------------------------- */

/*
 * Function/method overloading support.   This is done through typemaps,
 * but also involves a precedence level.
 */

/* Macro for overload resolution */



/* Macros for precedence levels */





































































/* -----------------------------------------------------------------------------
 * Default handling of certain overloaded operators 
 * ----------------------------------------------------------------------------- */


%rename("$ignore:"        "350:operator new ignored"  )     operator new;
%rename("$ignore:"     "351:operator delete ignored"  )  operator delete;
%rename("$ignore:"     "394:operator new[] ignored"  )  operator new[];
%rename("$ignore:"     "395:operator delete[] ignored"  )  operator delete[];

/* add C++ operator aliases */
%rename("operator &&") operator and;    // `and'    `&&'
%rename("operator ||") operator or;     // `or'     `||'
%rename("operator !")  operator not;    // `not'     `!'
%rename("operator &=") operator and_eq; // `and_eq'  `&='
%rename("operator &")  operator bitand; // `bitand'  `&'
%rename("operator |")  operator bitor;  // `bitor'   `|'
%rename("operator ~")  operator compl;  // `compl'   `~'
%rename("operator !=") operator not_eq; // `not_eq'  `!='
%rename("operator |=") operator or_eq;  // `or_eq'   `|='
%rename("operator ^")  operator xor;    // `xor'     `^'
%rename("operator ^=") operator xor_eq; // `xor_eq'  `^='

/* Smart pointer handling */

%rename(__deref__) *::operator->;
%rename(__ref__)   *::operator*();
%rename(__ref__)   *::operator*() const;

/* Define std namespace */
namespace std {
  /* Warn about std::initializer_list usage. The constructor/method where used should probably be ignored. See docs. */
  template<typename T> class initializer_list {};
  %typemap(in, warning="476:Initialization using std::initializer_list." ) initializer_list<T> ""
  %typemap(typecheck, precedence=      0     ) initializer_list<T> ""
}


/* -----------------------------------------------------------------------------
 * Default char * and C array typemaps
 * ----------------------------------------------------------------------------- */

/* Set up the typemap for handling new return strings */


%typemap(newfree) char * "delete [] $1;";




/* Default typemap for handling char * members */


%typemap(memberin,fragment="<string.h>") char * {
  delete [] $1;
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(memberin,warning=        "451:Setting a const char * variable may leak memory." ,fragment="<string.h>") const char * {
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(globalin,fragment="<string.h>") char * {
  delete [] $1;
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(globalin,warning=        "451:Setting a const char * variable may leak memory." ,fragment="<string.h>") const char * {
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}






































/* Character array handling */

%typemap(memberin,fragment="<string.h>") char [ANY] {
  if($input) {
    strncpy((char*)$1, (const char *)$input, $1_dim0-1);
    $1[$1_dim0-1] = 0;
  } else {
    $1[0] = 0;
  }
}

%typemap(globalin,fragment="<string.h>") char [ANY] {
  if($input) {
    strncpy((char*)$1, (const char *)$input, $1_dim0-1);
    $1[$1_dim0-1] = 0;
  } else {
    $1[0] = 0;
  }
}

%typemap(memberin,fragment="<string.h>") char [] {
  if ($input) strcpy((char *)$1, (const char *)$input);
  else $1[0] = 0;
}

%typemap(globalin,fragment="<string.h>") char [] {
  if ($input) strcpy((char *)$1, (const char *)$input);
  else $1[0] = 0;
}

/* memberin/globalin typemap for arrays. */

%typemap(memberin,fragment="<string.h>") SWIGTYPE [ANY] {
  size_t ii;
  $1_basetype *b = ($1_basetype *) $1;
  for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
}

%typemap(globalin,fragment="<string.h>") SWIGTYPE [ANY] {
  size_t ii;
  $1_basetype *b = ($1_basetype *) $1;
  for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
}

/* memberin/globalin typemap for double arrays. */

%typemap(memberin,fragment="<string.h>") SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$1_dim1] = ($basetype (*)[$1_dim1])($input);
  $basetype (*dest)[$1_dim1] = ($basetype (*)[$1_dim1])($1);
  size_t ii = 0;
  for (; ii < $1_dim0; ++ii) {
    $basetype *ip = inp[ii];
    $basetype *dp = dest[ii];
    size_t jj = 0;
    for (; jj < $1_dim1; ++jj) dp[jj] = ip[jj];
  }
}

%typemap(globalin,fragment="<string.h>") SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$1_dim1] = ($basetype (*)[$1_dim1])($input);
  $basetype (*dest)[$1_dim1] = ($basetype (*)[$1_dim1])($1);
  size_t ii = 0;
  for (; ii < $1_dim0; ++ii) {
    $basetype *ip = inp[ii];
    $basetype *dp = dest[ii];
    size_t jj = 0;
    for (; jj < $1_dim1; ++jj) dp[jj] = ip[jj];
  }
}

/* -----------------------------------------------------------------------------
 *  Runtime code
 * ----------------------------------------------------------------------------- */

/*  The SwigValueWrapper class  */

/*  
 * This template wrapper is used to handle C++ objects that are passed or 
 * returned by value.   This is necessary to handle objects that define
 * no default-constructor (making it difficult for SWIG to properly declare
 * local variables).
 *
 * The wrapper is used as follows.  First consider a function like this:
 *
 *      Vector cross_product(Vector a, Vector b)
 *
 * Now, if Vector is defined as a C++ class with no default constructor, 
 * code is generated as follows:
 *
 *     Vector *wrap_cross_product(Vector *inarg1, Vector *inarg2) {
 *          SwigValueWrapper<Vector>  arg1;
 *          SwigValueWrapper<Vector>  arg2;
 *          SwigValueWrapper<Vector> result;
 *
 *          arg1 = *inarg1;
 *          arg2 = *inarg2;
 *          ...            
 *          result = cross_product(arg1,arg2);
 *          ...
 *          return new Vector(result);
 *    }
 *         
 * In the wrappers, the template SwigValueWrapper simply provides a thin
 * layer around a Vector *.  However, it does this in a way that allows
 * the object to be bound after the variable declaration (which is not possible
 * with the bare object when it lacks a default constructor).  
 *
 * An observant reader will notice that the code after the variable declarations
 * is *identical* to the code used for classes that do define default constructors.
 * Thus, this neat trick allows us to fix this special case without having to
 * make massive changes to typemaps and other parts of the SWIG code generator.
 *
 * Note: this code is not included when SWIG runs in C-mode, when classes
 * define default constructors, or when pointers and references are used.
 * SWIG tries to avoid doing this except in very special circumstances.
 *
 * Note: This solution suffers from making a large number of copies
 * of the underlying object.  However, this is needed in the interest of
 * safety and in order to cover all of the possible ways in which a value
 * might be assigned.  For example:
 *
 *       arg1 = *inarg1;       // Assignment from a pointer
 *       arg1 = Vector(1,2,3); // Assignment from a value  
 *
 * The class offers a strong guarantee of exception safety.
 * With regards to the implementation, the private SwigMovePointer nested class is 
 * a simple smart pointer with move semantics, much like std::auto_ptr.
 *
 * This wrapping technique was suggested by William Fulton and is henceforth
 * known as the "Fulton Transform" :-).
 */


%insert("runtime") %{
#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};%}

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
%insert("runtime") %{
template <typename T> T SwigValueInit() {
  return T();
}
#endif
%}


/*  The swiglabels  */

%insert("runtime") "swiglabels.swg"


%endoffile

%includefile "/home/balos1/.local/share/swig/4.0.0/python/python.swg" %beginfile
/* ------------------------------------------------------------
 * python.swg
 *
 * Python configuration module.
 * ------------------------------------------------------------ */

/* ------------------------------------------------------------
 *  Inner macros
 * ------------------------------------------------------------ */
%includefile "/home/balos1/.local/share/swig/4.0.0/python/pymacros.swg" %beginfile
%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/swigmacros.swg" %beginfile
/* -----------------------------------------------------------------------------
 * SWIG API. Portion only visible from SWIG
 * ----------------------------------------------------------------------------- */
/*
  This file implements the internal macros of the 'SWIG API', which
  are useful to implement all the SWIG target languages.

  Basic preprocessor macros:
  --------------------------

    %arg(Arg)               Safe argument wrap
    %str(Arg)               Stringify the argument
    %begin_block            Begin an execution block
    %end_block              End an execution block
    %block(Block)           Execute Block as an execution block
    %define_as(Def, Val)    Define 'Def' as 'Val', expanding Def and Val first
    %ifcplusplus(V1, V2)    if C++ Mode; then V1; else V2; fi


  Casting Operations:
  -------------------

  SWIG provides the following casting macros, which implement the
  corresponding C++ casting operations:

    %const_cast(a, Type)         const_cast<Type >(a)
    %static_cast(a, Type)      	 static_cast<Type >(a)
    %reinterpret_cast(a, Type) 	 reinterpret_cast<Type >(a)
    %numeric_cast(a, Type)     	 static_cast<Type >(a)
    %as_voidptr(a)            	 const_cast<void *>(static_cast<const void *>(a))
    %as_voidptrptr(a)        	 reinterpret_cast<void **>(a)

  or their C unsafe versions. In C++ we use the safe version unless
  SWIG_NO_CPLUSPLUS_CAST is defined


  Memory allocation:
  ------------------

  These allocation/freeing macros are safe to use in C or C++ and
  dispatch the proper new/delete/delete[] or free/malloc calls as
  needed.

    %new_instance(Type)             Allocate a new instance of given Type
    %new_copy(value,Type)           Allocate and initialize a new instance with 'value'
    %new_array(size,Type)           Allocate a new array with given size and Type and zero initialize
    %new_copy_array(cptr,size,Type) Allocate and initialize a new array from 'cptr'
    %delete(cptr)                   Delete an instance
    %delete_array(cptr)             Delete an array


  Auxiliary loop macros:
  ----------------------

    %formacro(Macro, Args...) or %formacro_1(Macro, Args...)
       for i in Args
       do
          Macro($i)
       done

    %formacro_2(Macro2, Args...)
       for i,j in Args
       do
          Macro2($i, $j)
       done


  Flags and conditional macros:
  -----------------------------

     %mark_flag(flag)
       flag := True

     %evalif(flag,expr)
       if flag; then
         expr
       fi

     %evalif_2(flag1 flag2,expr)
       if flag1 and flag2; then
         expr
       fi


*/
/* -----------------------------------------------------------------------------
 * Basic preprocessor macros
 * ----------------------------------------------------------------------------- */











/* define a new macro */


/* include C++ or else value */








/* insert the SWIGVERSION in the interface and the wrapper code */

%insert("header") {
#define SWIGVERSION 0x040000 
#define SWIG_VERSION SWIGVERSION
}




/* -----------------------------------------------------------------------------
 * Casting operators
 * ----------------------------------------------------------------------------- */

















%insert("header") {
#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 
}


/* -----------------------------------------------------------------------------
 * Allocating/freeing elements
 * ----------------------------------------------------------------------------- */

















/* -----------------------------------------------------------------------------
 * SWIG names and mangling
 * ----------------------------------------------------------------------------- */








/* -----------------------------------------------------------------------------
 * Auxiliary loop macros
 * ----------------------------------------------------------------------------- */


/* for loop for macro with one argument */






/* for loop for macro with one argument */



/* for loop for macro with two arguments */






/* for loop for macro with two arguments */


/* -----------------------------------------------------------------------------
 * SWIG flags
 * ----------------------------------------------------------------------------- */

/*
  mark a flag, ie, define a macro name but ignore it in
  the interface.

  the flag can be later used with %evalif
*/




/*
  %evalif and %evalif_2 are use to evaluate or process
  an expression if the given predicate is 'true' (1).
*/
















%endoffile



%endoffile


/* ------------------------------------------------------------
 *  The runtime part
 * ------------------------------------------------------------ */
%includefile "/home/balos1/.local/share/swig/4.0.0/python/pyruntime.swg" %beginfile
%insert(runtime) %{
#if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
/* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
# include <math.h>
#endif

#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
/* Use debug wrappers with the Python release dll */
# undef _DEBUG
# include <Python.h>
# define _DEBUG 1
#else
# include <Python.h>
#endif
%}

%insert(runtime) "swigrun.swg";         /* SWIG API */
%insert(runtime) "swigerrors.swg";      /* SWIG errors */   
%insert(runtime) "pyhead.swg";          /* Python includes and fixes */
%insert(runtime) "pyerrors.swg";        /* Python errors */
%insert(runtime) "pythreads.swg";       /* Python thread code */
%insert(runtime) "pyapi.swg";           /* Python API */
%insert(runtime) "pyrun.swg";           /* Python run-time code */




%endoffile

/* ------------------------------------------------------------
 *  Special user directives
 * ------------------------------------------------------------ */
%includefile "/home/balos1/.local/share/swig/4.0.0/python/pyuserdir.swg" %beginfile
/* -------------------------------------------------------------------------
 *  Special user directives
 * ------------------------------------------------------------------------- */

/* ------------------------------------------------------------------------- */

/* shadow code */





/* ------------------------------------------------------------------------- */
/* 
Use the "nondynamic" feature to make a wrapped class behave as a "nondynamic"
one, ie, a python class that doesn't dynamically add new attributes.

For example, for the class

%pythonnondynamic A;
struct A
{
  int a;
  int b;
};

you will get:

 aa = A()
 aa.a = 1  # Ok
 aa.b = 1  # Ok
 aa.c = 3  # error

Since nondynamic is a feature, if you use it like

 %pythonnondynamic;

it will make all the wrapped classes nondynamic ones.

The implementation is based on this recipe:

   http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252158

*/







/* ------------------------------------------------------------------------- */
/*

Use %pythonmaybecall to flag a method like __add__ or __radd__.  These
don't produce an error when called, they just return NotImplemented.

These methods "may be called" if needed.

*/





/* ------------------------------------------------------------------------- */
/*
  The %pythoncallback feature produce a more natural callback wrapper
  than the %callback mechanism, ie, it uses the original name for
  the callback and callable objects. 

  Just use it as

    %pythoncallback(1) foo;
    int foo(int a);

    %pythoncallback(1) A::foo;
    struct A {
     static int foo(int a);
    };

    int bar(int, int (*pf)(int));

  then, you can use it as:

   a = foo(1)
   b = bar(2, foo)

   c = A.foo(3)
   d = bar(4, A.foo)


   If you use it with a member method
   %pythoncallback(1) A::foom;
   struct A {
      int foom(int a);
   };

   then you can use it as

     r = a.foom(3)             # eval the method
     mptr = A.foom_cb_ptr      # returns the callback pointer

   where the '_cb_ptr' suffix is added for the callback pointer.

*/





/* ------------------------------------------------------------------------- */
/*
  Support for the old %callback directive name
*/
















/* ------------------------------------------------------------------------- */
/*
  Thread support - Advance control
  
*/














/* ------------------------------------------------------------------------- */
/*
  Implicit Conversion using the C++ constructor mechanism
*/






/* ------------------------------------------------------------------------- */
/*
  Enable keywords parameters
*/





/* ------------------------------------------------------------------------- */
/*
  Add python code to the proxy/shadow code 
  
   %pythonprepend   - Add code before the C++ function is called
   %pythonappend    - Add code after the C++ function is called
*/








/* ------------------------------------------------------------------------- */
/* 
   %extend_smart_pointer extend the smart pointer support.

   For example, if you have a smart pointer as:
	    
     template <class Type> class RCPtr {
     public:
       ...
       RCPtr(Type *p);
   	Type * operator->() const;
   	...
     };
     
   you use the %extend_smart_pointer directive as:
   
     %extend_smart_pointer(RCPtr<A>);
     %template(RCPtr_A)  RCPtr<A>;
   
   then, if you have something like:

     RCPtr<A> make_ptr();
     int foo(A *);

   you can do the following:

     a = make_ptr();
     b = foo(a);

   ie, swig will accept a RCPtr<A> object where a 'A *' is
   expected.

   Also, when using vectors
   
     %extend_smart_pointer(RCPtr<A>);
     %template(RCPtr_A) RCPtr<A>;
     %template(vector_A) std::vector<RCPtr<A> >;
   	
   you can type

     a = A();
     v = vector_A(2)
     v[0] = a

   ie, an 'A *' object is accepted, via implicit conversion, 
   where a RCPtr<A> object is expected. Additionally

     x = v[0]

   returns (and sets 'x' as) a copy of v[0], making reference
   counting possible and consistent.
*/






%endoffile

/* ------------------------------------------------------------
 *  Typemap specializations
 * ------------------------------------------------------------ */
%includefile "/home/balos1/.local/share/swig/4.0.0/python/pytypemaps.swg" %beginfile
/* ------------------------------------------------------------
 *  Typemap specializations for Python
 * ------------------------------------------------------------ */

/* ------------------------------------------------------------
 *  Fragment section
 * ------------------------------------------------------------ */






/* Include fundamental fragment definitions */
%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg" %beginfile
/*
  Fragments
  =========
  See the "Typemap fragments" section in the documentation for understanding
  fragments. Below is some info on how fragments and automatic type
  specialization is used.

  Macros that make the automatic generation of typemaps easier are provided.

  Consider the following code:

      %fragment(SWIG_From_frag(bool), "header") {     
      static PyObject*		      
      SWIG_From_dec(bool)(bool value)	       
      {					       
        PyObject *obj = value ? Py_True : Py_False;  
        Py_INCREF(obj);			       
        return obj;				       
      }					       
      }					       
      					 
      %typemap(out, fragment=SWIG_From_frag(bool)) bool {
        $result = SWIG_From(bool)($1));
      }

  Here the macros

      SWIG_From_frag  => fragment 
      SWIG_From_dec   => declaration 
      SWIG_From       => call 
      
  allow you to define/include a fragment, and declare and call the
  'from-bool' method as needed. In the simpler case, these macros 
  just return something like

      SWIG_From_frag(bool)  => "SWIG_From_bool"
      SWIG_From_dec(bool)   =>  SWIG_From_bool
      SWIG_From(bool)       =>  SWIG_From_bool

  But they are specialized for the different languages requirements,
  such as perl or tcl that requires passing the interpreter pointer,
  and also they can manage C++ ugly types, for example:
  
      SWIG_From_frag(std::complex<double>)  => "SWIG_From_std_complex_Sl_double_Sg_"
      SWIG_From_dec(std::complex<double>)   =>  SWIG_From_std_complex_Sl_double_Sg_
      SWIG_From(std::complex<double>)       =>  SWIG_From_std_complex_Sl_double_Sg_


  Hence, to declare methods to use with typemaps, always use the
  SWIG_From* macros. In the same way, the SWIG_AsVal* and SWIG_AsPtr*
  set of macros are provided.
    
*/


/* -----------------------------------------------------------------------------
 * Define the basic macros to 'normalize' the type fragments
 * ----------------------------------------------------------------------------- */




































/* ------------------------------------------------------------
 * common fragments 
 * ------------------------------------------------------------ */

%fragment("SWIG_isfinite","header",fragment="<math.h>,<float.h>") %{
/* Getting isfinite working pre C99 across multiple platforms is non-trivial. Users can provide SWIG_isfinite on older platforms. */
#ifndef SWIG_isfinite
/* isfinite() is a macro for C99 */
# if defined(isfinite)
#  define SWIG_isfinite(X) (isfinite(X))
# elif defined(__cplusplus) && __cplusplus >= 201103L
/* Use a template so that this works whether isfinite() is std::isfinite() or
 * in the global namespace.  The reality seems to vary between compiler
 * versions.
 *
 * Make sure namespace std exists to avoid compiler warnings.
 *
 * extern "C++" is required as this fragment can end up inside an extern "C" { } block
 */
namespace std { }
extern "C++" template<typename T>
inline int SWIG_isfinite_func(T x) {
  using namespace std;
  return isfinite(x);
}
#  define SWIG_isfinite(X) (SWIG_isfinite_func(X))
# elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2))
#  define SWIG_isfinite(X) (__builtin_isfinite(X))
# elif defined(__clang__) && defined(__has_builtin)
#  if __has_builtin(__builtin_isfinite)
#   define SWIG_isfinite(X) (__builtin_isfinite(X))
#  endif
# elif defined(_MSC_VER)
#  define SWIG_isfinite(X) (_finite(X))
# elif defined(__sun) && defined(__SVR4)
#  include <ieeefp.h>
#  define SWIG_isfinite(X) (finite(X))
# endif
#endif
%}

%fragment("SWIG_Float_Overflow_Check","header",fragment="<float.h>,SWIG_isfinite") %{
/* Accept infinite as a valid float value unless we are unable to check if a value is finite */
#ifdef SWIG_isfinite
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX) && SWIG_isfinite(X))
#else
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX))
#endif
%}

/* -----------------------------------------------------------------------------
 * special macros for fragments
 * ----------------------------------------------------------------------------- */

/* Macros to derive numeric types */








































/* Macro for 'signed long' derived types */






/* Macro for 'unsigned long' derived types */







/* Macro for floating point derived types (original macro) */






/* Macro for floating point derived types */







/* Macros for missing fragments */















%endoffile

/* Look for user fragments file. */
%includefile "/home/balos1/.local/share/swig/4.0.0/python/pyfragments.swg" %beginfile
/*

  Create a file with this name, 'pyfragments.swg', in your working
  directory and add all the %fragments you want to take precedence
  over the default ones defined by swig.

  For example, if you add:
  
  %fragment(SWIG_AsVal_frag(int),"header") {
   SWIGINTERNINLINE int
   SWIG_AsVal(int)(PyObject *obj, int *val)
   { 
     <your code here>;
   }
  }
  
  this will replace the code used to retrieve an integer value for all
  the typemaps that need it, including:
  
    int, std::vector<int>, std::list<std::pair<int,int> >, etc.

    
*/
%endoffile

/* Python fragments for fundamental types */
%includefile "/home/balos1/.local/share/swig/4.0.0/python/pyprimtypes.swg" %beginfile
/* ------------------------------------------------------------
 * Primitive Types
 * ------------------------------------------------------------ */

/* boolean */

%fragment("SWIG_" "From" "_" {bool},"header") {
SWIGINTERNINLINE PyObject*
  SWIG_From_bool  (bool value)
{
  return PyBool_FromLong(value ? 1 : 0);
}
}
















%fragment("SWIG_" "AsVal" "_" {bool},"header",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_bool (PyObject *obj, bool *val)
{
  int r;
  if (!PyBool_Check(obj))
    return SWIG_ERROR;
  r = PyObject_IsTrue(obj);
  if (r == -1)
    return SWIG_ERROR;
  if (val) *val = r ? true : false;
  return SWIG_OK;
}
}


/* int */

%fragment("SWIG_" "From" "_" {int},"header") {
SWIGINTERNINLINE PyObject*
  SWIG_From_int  (int value)
{
  return PyInt_FromLong((long) value);
}
}

/* unsigned int */

%fragment("SWIG_" "From" "_" {unsigned int},"header") {
SWIGINTERNINLINE PyObject*
  SWIG_From_unsigned_SS_int  (unsigned int value)
{
  return PyInt_FromSize_t((size_t) value);
}
}

/* long */

%fragment("SWIG_" "From" "_" {long},"header") {
  #define SWIG_From_long   PyInt_FromLong 
}

%fragment("SWIG_" "AsVal" "_" {long},"header",
	  fragment="SWIG_CanCastAsInteger") {
SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else
#endif
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}
}

/* unsigned long */

%fragment("SWIG_" "From" "_" {unsigned long},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) : PyInt_FromLong(static_cast< long >(value));
}
}

%fragment("SWIG_" "AsVal" "_" {unsigned long},"header",
	  fragment="SWIG_CanCastAsInteger") {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else
#endif
  if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}
}

/* long long */

%fragment("SWIG_" "From" "_" {long long},"header",
	  fragment="SWIG_LongLongAvailable") {
#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE PyObject* 
SWIG_From_long_SS_long  (long long value)
{
  return ((value < LONG_MIN) || (value > LONG_MAX)) ?
    PyLong_FromLongLong(value) : PyInt_FromLong(static_cast< long >(value));
}
#endif
}

%fragment("SWIG_" "AsVal" "_" {long long},"header",
	  fragment="SWIG_" "AsVal" "_" {long},
	  fragment="SWIG_CanCastAsInteger",
	  fragment="SWIG_LongLongAvailable") {
#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_long_SS_long (PyObject *obj, long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    long long v = PyLong_AsLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    long v;
    res = SWIG_AsVal_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    const double mant_min = -mant_max;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, mant_min, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, mant_min, mant_max)) {
      if (val) *val = (long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif
}

/* unsigned long long */

%fragment("SWIG_" "From" "_" {unsigned long long},"header",
	  fragment="SWIG_LongLongAvailable") {
#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLongLong(value) : PyInt_FromLong(static_cast< long >(value));
}
#endif
}

%fragment("SWIG_" "AsVal" "_" {unsigned long long},"header",
	  fragment="SWIG_" "AsVal" "_" {unsigned long},
	  fragment="SWIG_CanCastAsInteger",
	  fragment="SWIG_LongLongAvailable") {
#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_unsigned_SS_long_SS_long (PyObject *obj, unsigned long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    unsigned long long v = PyLong_AsUnsignedLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, 0, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, mant_max)) {
      if (val) *val = (unsigned long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif
}

/* double */

%fragment("SWIG_" "From" "_" {double},"header") {
  #define SWIG_From_double   PyFloat_FromDouble 
}

%fragment("SWIG_" "AsVal" "_" {double},"header") {
SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
#if PY_VERSION_HEX < 0x03000000
  } else if (PyInt_Check(obj)) {
    if (val) *val = (double) PyInt_AsLong(obj);
    return SWIG_OK;
#endif
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}
}



%endoffile

/* Python fragments for char* strings */
%includefile "/home/balos1/.local/share/swig/4.0.0/python/pystrings.swg" %beginfile
/* ------------------------------------------------------------
 *  utility methods for char strings 
 * ------------------------------------------------------------ */
%fragment("SWIG_AsCharPtrAndSize","header",fragment="SWIG_pchar_descriptor") {
SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
  if (PyBytes_Check(obj))
#else
  if (PyUnicode_Check(obj))
#endif
#else  
  if (PyString_Check(obj))
#endif
  {
    char *cstr; Py_ssize_t len;
    int ret = SWIG_OK;
#if PY_VERSION_HEX>=0x03000000
#if !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    if (!obj)
      return SWIG_TypeError;
    if (alloc)
      *alloc = SWIG_NEWOBJ;
#endif
    PyBytes_AsStringAndSize(obj, &cstr, &len);
#else
    PyString_AsStringAndSize(obj, &cstr, &len);
#endif
    if (cptr) {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = reinterpret_cast< char* >(memcpy(new char[len + 1], cstr, sizeof(char)*(len + 1)));
	  *alloc = SWIG_NEWOBJ;
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
	*cptr = PyBytes_AsString(obj);
#else
	assert(0); /* Should never reach here with Unicode strings in Python 3 */
#endif
#else
	*cptr = SWIG_Python_str_AsChar(obj);
        if (!*cptr)
          ret = SWIG_TypeError;
#endif
      }
    }
    if (psize) *psize = len + 1;
#if PY_VERSION_HEX>=0x03000000 && !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    Py_XDECREF(obj);
#endif
    return ret;
  } else {
#if defined(SWIG_PYTHON_2_UNICODE)
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
#error "Cannot use both SWIG_PYTHON_2_UNICODE and SWIG_PYTHON_STRICT_BYTE_CHAR at once"
#endif
#if PY_VERSION_HEX<0x03000000
    if (PyUnicode_Check(obj)) {
      char *cstr; Py_ssize_t len;
      if (!alloc && cptr) {
        return SWIG_RuntimeError;
      }
      obj = PyUnicode_AsUTF8String(obj);
      if (!obj)
        return SWIG_TypeError;
      if (PyString_AsStringAndSize(obj, &cstr, &len) != -1) {
        if (cptr) {
          if (alloc) *alloc = SWIG_NEWOBJ;
          *cptr = reinterpret_cast< char* >(memcpy(new char[len + 1], cstr, sizeof(char)*(len + 1)));
        }
        if (psize) *psize = len + 1;

        Py_XDECREF(obj);
        return SWIG_OK;
      } else {
        Py_XDECREF(obj);
      }
    }
#endif
#endif

    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}
}

%fragment("SWIG_FromCharPtrAndSize","header",fragment="SWIG_pchar_descriptor") {
SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_InternalNewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
      return PyBytes_FromStringAndSize(carray, static_cast< Py_ssize_t >(size));
#else
      return PyUnicode_DecodeUTF8(carray, static_cast< Py_ssize_t >(size), "surrogateescape");
#endif
#else
      return PyString_FromStringAndSize(carray, static_cast< Py_ssize_t >(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}
}

%endoffile

/* Backward compatibility output helper */
%fragment("t_output_helper","header") %{
#define t_output_helper SWIG_Python_AppendOutput
%}


/* ------------------------------------------------------------
 *  Unified typemap section
 * ------------------------------------------------------------ */

/* directors are supported in Python */





/* Python types */



/* Python allows implicit conversion */



/* Overload of the output/constant/exception/dirout handling */

/* append output */


/* set constant */






/* raise */


/* Include the unified typemap library */
%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/swigtypemaps.swg" %beginfile
/* -----------------------------------------------------------------------------
 * swigtypemaps.swg
 *
 * Unified Typemap Library frontend
 * ----------------------------------------------------------------------------- */

/*
  This file provides the frontend to the Unified Typemap Library.

  When using this library in a SWIG target language, you need to
  define a minimum set of fragments, specialize a couple of macros,
  and then include this file.

  Typically you will create a 'mytypemaps.swg' file in each target
  language, where you will have the following sections:

    === mytypemaps.swg ===

    //  Fragment section 
    %include <typemaps/fragments.swg>
    <include target language fragments>

    // Unified typemap section 
    <specialized the typemap library macros>
    %include <typemaps/swigtypemaps.swg>

    // Local typemap section 
    <add/replace extra target language typemaps>

    === mytypemaps.swg ===

  While we add more docs, please take a look at the following cases
  to see how you specialized the unified typemap library for a new
  target language:

      Lib/python/pytypemaps.swg
      Lib/tcl/tcltypemaps.swg
      Lib/ruby/rubytypemaps.swg
      Lib/perl5/perltypemaps.swg
    
*/



/* -----------------------------------------------------------------------------
 *   Language specialization section. 
 *
 *   Tune these macros for each language as needed.
 * ----------------------------------------------------------------------------- */

/*
  The SWIG target language object must be provided.
  For example in python you define:

    #define SWIG_Object PyObject *
*/





/*==== flags for new/convert methods ====*/














/*==== set output ====*/


/* simple set output operation */



/*==== set variable output  ====*/


/* simple set varoutput operation */



/*==== append output ====*/



/* simple append operation */






/*==== set constant ====*/



/* simple set constant operation */






/*==== raise an exception ====*/



/* simple raise operation */






/*==== director output exception ====*/








/* -----------------------------------------------------------------------------
 *  Language independent definitions
 * ----------------------------------------------------------------------------- */













/* -----------------------------------------------------------------------------
 *  All the typemaps
 * ----------------------------------------------------------------------------- */



%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/exception.swg" %beginfile
/* -----------------------------------------------------------------------------
 * exceptions.swg
 *
 * This SWIG library file provides language independent exception handling
 * ----------------------------------------------------------------------------- */




/* macros for error manipulation */












/* setting an error */





%insert("runtime") {

#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 

}


/*
  You can use the SWIG_CATCH_STDEXCEPT macro with the %exception
  directive as follows:

  %exception {
    try {
      $action
    }
    catch (my_except& e) {
      ...
    }
    SWIG_CATCH_STDEXCEPT // catch std::exception
    catch (...) {
     SWIG_exception_fail(SWIG_UnknownError, "Unknown exception");
    }
  }
*/

%fragment("<stdexcept>");






























%endoffile
%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/swigtype.swg" %beginfile
/* -----------------------------------------------------------------------------
 * --- Input arguments --- 
 * ----------------------------------------------------------------------------- */
/* Pointers and arrays */
%typemap(in, noblock=1) SWIGTYPE *(void  *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp,$descriptor, $disown |  0 );
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
  $1 = reinterpret_cast< $ltype >(argp);
}
%typemap(freearg) SWIGTYPE * "";

%typemap(in, noblock=1) SWIGTYPE [] (void *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp,$descriptor, $disown |  0 );
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  } 
  $1 = reinterpret_cast< $ltype >(argp);
}
%typemap(freearg) SWIGTYPE [] "";


%typemap(in, noblock=1) SWIGTYPE *const&  (void *argp = 0, int res = 0, $*1_ltype temp) {
  res = SWIG_ConvertPtr($input, &argp, $*descriptor, $disown |  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'"); 
  }
  temp = reinterpret_cast< $*ltype >(argp);
  $1 = reinterpret_cast< $1_ltype >(&temp);
}
%typemap(freearg) SWIGTYPE *const& "";


/* Reference */
%typemap(in, noblock=1) SWIGTYPE & (void *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
  if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
  $1 = reinterpret_cast< $ltype >(argp);
}
%typemap(freearg) SWIGTYPE & "";


%typemap(in,noblock=1,implicitconv=1) const SWIGTYPE & (void *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $descriptor,  0  | $implicitconv);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
  if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
  $1 = reinterpret_cast< $ltype >(argp);
}
%typemap(freearg,noblock=1,match="in",implicitconv=1) const SWIGTYPE &
{
  if (SWIG_IsNewObj(res$argnum)) delete $1;
}











/* Rvalue reference */
%typemap(in, noblock=1) SWIGTYPE && (void *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
  if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
  $1 = reinterpret_cast< $ltype >(argp);
}
%typemap(freearg) SWIGTYPE && "";


%typemap(in,noblock=1,implicitconv=1) const SWIGTYPE && (void *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $descriptor,  0  | $implicitconv);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
  if (!argp) { SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); }
  $1 = reinterpret_cast< $ltype >(argp);
}
%typemap(freearg,noblock=1,match="in",implicitconv=1) const SWIGTYPE &&
{
  if (SWIG_IsNewObj(res$argnum)) delete $1;
}











/* By value */

%typemap(in,implicitconv=1) SWIGTYPE (void *argp, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $&descriptor,  0  | $implicitconv);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }  
  if (!argp) { 
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  } else {
    $&ltype temp = reinterpret_cast< $&ltype >(argp);
    $1 = *temp;
    if (SWIG_IsNewObj(res)) delete temp;
  }
}















/* -----------------------------------------------------------------------------
 * --- Output arguments --- 
 * ----------------------------------------------------------------------------- */

/* Pointers, references */
%typemap(out,noblock=1) SWIGTYPE *, SWIGTYPE &, SWIGTYPE &&, SWIGTYPE[] {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr($1), $descriptor, $owner |  0 );
}

%typemap(out, noblock=1) SWIGTYPE *const& {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr(*$1), $*descriptor, $owner |  0 );
}

/* Return by value */
%typemap(out, noblock=1) SWIGTYPE {
  $result = SWIG_NewPointerObj((new $ltype(static_cast< const $ltype& >($1))), $&descriptor, SWIG_POINTER_OWN |  0 );
}

/* -----------------------------------------------------------------------------
 * --- Variable input --- 
 * ----------------------------------------------------------------------------- */

/* memberin/globalin/varin, for fix arrays. */

%typemap(memberin) SWIGTYPE [ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) *($1_basetype *)&$1[ii] = *(($1_basetype *)$input + ii);
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

%typemap(globalin) SWIGTYPE [ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) *($1_basetype *)&$1[ii] = *(($1_basetype *)$input + ii);
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

%typemap(varin) SWIGTYPE [ANY] {
  $basetype *inp = 0;
  int res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&inp), $descriptor,  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  } else if (inp) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) *($1_basetype *)&$1[ii] = *(($1_basetype *)inp + ii);
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}


/* memberin/globalin/varin, for fix double arrays. */

%typemap(memberin) SWIGTYPE [ANY][ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) {
      if ($input[ii]) {
	size_t jj = 0;
	for (; jj < (size_t)$1_dim1; ++jj) $1[ii][jj] = $input[ii][jj];
      } else {
	SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
      }
    }
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

%typemap(globalin) SWIGTYPE [ANY][ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) {
      if ($input[ii]) {
	size_t jj = 0;
	for (; jj < (size_t)$1_dim1; ++jj) $1[ii][jj] = $input[ii][jj];
      } else {
	SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
      }
    }
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

%typemap(varin) SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$1_dim1] = 0;
  int res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&inp), $descriptor,  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  } else if (inp) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) {
      if (inp[ii]) {
	size_t jj = 0;
	for (; jj < (size_t)$1_dim1; ++jj) $1[ii][jj] = inp[ii][jj];
      } else {
	SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
      }
    }
  } else {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
}

/* Pointers, references, and variable size arrays */

%typemap(varin,warning=    "454:Setting a pointer/reference variable may leak memory." ) SWIGTYPE * {
  void *argp = 0;
  int res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );  
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  $1 = reinterpret_cast< $ltype >(argp);
}

%typemap(varin,noblock=1,warning="462:Unable to set dimensionless array variable") SWIGTYPE []
{
  SWIG_exception_fail(SWIG_ArgError(SWIG_AttributeError), "in variable '""read-only $name""' of type '""$type""'");
}

%typemap(varin,warning=    "454:Setting a pointer/reference variable may leak memory." ) SWIGTYPE & {
  void *argp = 0;
  int res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if (!argp) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
  $1 = *(reinterpret_cast< $ltype >(argp));
}

%typemap(varin,warning=    "454:Setting a pointer/reference variable may leak memory." ) SWIGTYPE && {
  void *argp = 0;
  int res = SWIG_ConvertPtr($input, &argp, $descriptor,  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if (!argp) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  }
  $1 = *(reinterpret_cast< $ltype >(argp));
}


%typemap(varin,implicitconv=1) SWIGTYPE {
  void *argp = 0;
  int res = SWIG_ConvertPtr($input, &argp, $&descriptor,  0  | $implicitconv);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if (!argp) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""$name""' of type '""$type""'");
  } else {
    $&type temp;
    temp  = reinterpret_cast< $&type >(argp);
    $1 = *temp;
    if (SWIG_IsNewObj(res)) delete temp;
  }
}















/* -----------------------------------------------------------------------------
 * --- Variable output --- 
 * ----------------------------------------------------------------------------- */

/* Pointers and arrays */
%typemap(varout, noblock=1) SWIGTYPE * {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr($1), $descriptor,  0 );
}

%typemap(varout, noblock=1) SWIGTYPE [] {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr($1), $descriptor,  0 );
}

/* References */
%typemap(varout, noblock=1) SWIGTYPE & {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr(&$1), $descriptor,  0 );
}

%typemap(varout, noblock=1) SWIGTYPE && {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr(&$1), $descriptor,  0 );
}

/* Value */
%typemap(varout, noblock=1) SWIGTYPE {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr(&$1), $&descriptor,  0 );
}

/* ------------------------------------------------------------
 * --- Typechecking rules ---
 * ------------------------------------------------------------ */

%typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE * {
  void *vptr = 0;
  int res = SWIG_ConvertPtr($input, &vptr, $descriptor, 0);
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE *const& {
  void *vptr = 0;
  int res = SWIG_ConvertPtr($input, &vptr, $*descriptor, 0);
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE & {
  void *vptr = 0;
  int res = SWIG_ConvertPtr($input, &vptr, $descriptor, SWIG_POINTER_NO_NULL);
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=      0     ,noblock=1) SWIGTYPE && {
  void *vptr = 0;
  int res = SWIG_ConvertPtr($input, &vptr, $descriptor, SWIG_POINTER_NO_NULL);
  $1 = SWIG_CheckState(res);
}


%typemap(typecheck,precedence=      0     ,noblock=1,implicitconv=1) const SWIGTYPE & {
  int res = SWIG_ConvertPtr($input, 0, $descriptor, SWIG_POINTER_NO_NULL | $implicitconv);
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=      0     ,noblock=1,implicitconv=1) const SWIGTYPE && {
  int res = SWIG_ConvertPtr($input, 0, $descriptor, SWIG_POINTER_NO_NULL | $implicitconv);
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=      0     ,noblock=1,implicitconv=1) SWIGTYPE {
  int res = SWIG_ConvertPtr($input, 0, $&descriptor, SWIG_POINTER_NO_NULL | $implicitconv);
  $1 = SWIG_CheckState(res);
}



















/* -----------------------------------------------------------------------------
 * --- Director typemaps --- *  
 * ----------------------------------------------------------------------------- */



/* directorin */

%typemap(directorin,noblock=1) SWIGTYPE {
  $input = SWIG_NewPointerObj(SWIG_as_voidptr(new $1_ltype((const $1_ltype &)$1)), $&descriptor, SWIG_POINTER_OWN |  0 );
}

%typemap(directorin,noblock=1) SWIGTYPE * {
  $input = SWIG_NewPointerObj(SWIG_as_voidptr($1), $descriptor,  0 );
}

%typemap(directorin,noblock=1) SWIGTYPE *const& {
  $input = SWIG_NewPointerObj(SWIG_as_voidptr($1), $*descriptor,  0 );
}

%typemap(directorin,noblock=1) SWIGTYPE & {
  $input = SWIG_NewPointerObj(SWIG_as_voidptr(&$1), $descriptor,  0 );
}

%typemap(directorin,noblock=1) SWIGTYPE && {
  $input = SWIG_NewPointerObj(SWIG_as_voidptr(&$1_name), $descriptor,  0 );
}

/* directorout */


%typemap(directorout,noblock=1,implicitconv=1) SWIGTYPE (void * swig_argp, int swig_res = 0) {
  swig_res = SWIG_ConvertPtr($input,&swig_argp,$&descriptor,  0  | $implicitconv);
  if (!SWIG_IsOK(swig_res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
  }
  $result = *(reinterpret_cast< $&ltype >(swig_argp));
  if (SWIG_IsNewObj(swig_res)) delete reinterpret_cast< $&ltype >(swig_argp);
}










%typemap(directorout,noblock=1,warning= "473:Returning a pointer or reference in a director method is not recommended." ) 
  SWIGTYPE *(void *swig_argp, int swig_res, swig_owntype own) {
  swig_res = SWIG_ConvertPtrAndOwn($input, &swig_argp, $descriptor,  0  | SWIG_POINTER_DISOWN, &own);
  if (!SWIG_IsOK(swig_res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
  }
  $result = reinterpret_cast< $ltype >(swig_argp);
  swig_acquire_ownership_obj(SWIG_as_voidptr($result), own /* & TODO: SWIG_POINTER_OWN */);
}
%typemap(directorfree,noblock=1,match="directorout") SWIGTYPE * {
  if (director) {
    SWIG_AcquirePtr($result, director->swig_release_ownership(SWIG_as_voidptr($input)));
  }
}

%typemap(directorout,noblock=1,warning= "473:Returning a pointer or reference in a director method is not recommended." ) 
  SWIGTYPE *const&(void *swig_argp, int swig_res, swig_owntype own) {
  swig_res = SWIG_ConvertPtrAndOwn($input, &swig_argp, $*descriptor,  0  | SWIG_POINTER_DISOWN, &own);
  if (!SWIG_IsOK(swig_res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
  }
  $1_ltype swig_temp = new $*1_ltype(($*1_ltype)swig_argp);
  swig_acquire_ownership(swig_temp);
  $result = swig_temp;
}
%typemap(directorfree,noblock=1,match="directorout") SWIGTYPE *const& {
  if (director) {
    SWIG_AcquirePtr($result, director->swig_release_ownership(SWIG_as_voidptr(*$input)));
  }
}

%typemap(directorout,noblock=1,warning= "473:Returning a pointer or reference in a director method is not recommended." ) 
  SWIGTYPE &(void *swig_argp, int swig_res, swig_owntype own) {
  swig_res = SWIG_ConvertPtrAndOwn($input, &swig_argp, $descriptor,  0  | SWIG_POINTER_DISOWN, &own);
  if (!SWIG_IsOK(swig_res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
  }
  if (!swig_argp) { Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ValueError), "invalid null reference " "in output value of type '""$type""'"); }
  $result = reinterpret_cast< $ltype >(swig_argp);
  swig_acquire_ownership_obj(SWIG_as_voidptr($result), own /* & TODO: SWIG_POINTER_OWN */);
}
%typemap(directorfree,noblock=1,match="directorout") SWIGTYPE & {
  if (director) {
    SWIG_AcquirePtr($result, director->swig_release_ownership(SWIG_as_voidptr($input)));
  }
}

%typemap(directorout,noblock=1,warning= "473:Returning a pointer or reference in a director method is not recommended." ) 
  SWIGTYPE &&(void *swig_argp, int swig_res, swig_owntype own) {
  swig_res = SWIG_ConvertPtrAndOwn($input, &swig_argp, $descriptor,  0  | SWIG_POINTER_DISOWN, &own);
  if (!SWIG_IsOK(swig_res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
  }
  if (!swig_argp) { Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ValueError), "invalid null reference " "in output value of type '""$type""'"); }
  $result = reinterpret_cast< $ltype >(swig_argp);
  swig_acquire_ownership_obj(SWIG_as_voidptr($result), own /* & TODO: SWIG_POINTER_OWN */);
}
%typemap(directorfree,noblock=1,match="directorout") SWIGTYPE && {
  if (director) {
    SWIG_AcquirePtr($result, director->swig_release_ownership(SWIG_as_voidptr($input)));
  }
}




/* ------------------------------------------------------------
 * --- Constants ---
 * ------------------------------------------------------------ */

%typemap(constcode,noblock=1) SWIGTYPE *, SWIGTYPE &, SWIGTYPE &&, SWIGTYPE [] {
  SWIG_Python_SetConstant(d, "$symname",SWIG_NewPointerObj(SWIG_as_voidptr($value),$descriptor, 0 ));
}

%typemap(constcode,noblock=1) SWIGTYPE {
  SWIG_Python_SetConstant(d, "$symname",SWIG_NewPointerObj(SWIG_as_voidptr(&$value),$&descriptor, 0 ));
}

/* ------------------------------------------------------------
 * --- Exception handling ---
 * ------------------------------------------------------------ */

%typemap(throws,noblock=1) SWIGTYPE {
  SWIG_Python_Raise(SWIG_NewPointerObj((new $ltype(static_cast< const $ltype& >($1))),$&descriptor,SWIG_POINTER_OWN), "$type", $&descriptor); SWIG_fail;
}

%typemap(throws,noblock=1) SWIGTYPE * {
  SWIG_Python_Raise(SWIG_NewPointerObj(SWIG_as_voidptr($1),$descriptor,0), "$type", $descriptor); SWIG_fail;
}

%typemap(throws,noblock=1) SWIGTYPE [ANY] {
  SWIG_Python_Raise(SWIG_NewPointerObj(SWIG_as_voidptr($1),$descriptor,0), "$type", $descriptor); SWIG_fail;
}

%typemap(throws,noblock=1) SWIGTYPE & {
  SWIG_Python_Raise(SWIG_NewPointerObj(SWIG_as_voidptr(&$1),$descriptor,0), "$type", $descriptor); SWIG_fail;
}

%typemap(throws,noblock=1) SWIGTYPE && {
  SWIG_Python_Raise(SWIG_NewPointerObj(SWIG_as_voidptr(&$1),$descriptor,0), "$type", $descriptor); SWIG_fail;
}

%typemap(throws,noblock=1) (...) {
  SWIG_exception_fail(SWIG_RuntimeError,"unknown exception");
}

/* ------------------------------------------------------------
 * --- CLASS::* typemaps --- 
 * ------------------------------------------------------------ */

%typemap(in) SWIGTYPE (CLASS::*) {  
  int res = SWIG_ConvertMember($input, SWIG_as_voidptr(&$1), sizeof($type),$descriptor);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
}

%typemap(out,noblock=1) SWIGTYPE (CLASS::*) {
  $result = SWIG_NewMemberObj(SWIG_as_voidptr(&$1), sizeof($type), $descriptor);
}

%typemap(varin) SWIGTYPE (CLASS::*) {
  int res = SWIG_ConvertMember($input,SWIG_as_voidptr(&$1), sizeof($type), $descriptor);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'"); 
  }
}

%typemap(varout,noblock=1) SWIGTYPE (CLASS::*) {
  $result = SWIG_NewMemberObj(SWIG_as_voidptr(&$1), sizeof($type), $descriptor);
}

%typemap(constcode,noblock=1) SWIGTYPE (CLASS::*) {
  SWIG_Python_SetConstant(d, "$symname",SWIG_NewMemberObj(SWIG_as_voidptr(&$value), sizeof($type), $descriptor));
}



/* directorin */

%typemap(directorin,noblock=1) SWIGTYPE (CLASS::*) {
  $input = SWIG_NewMemberObj(SWIG_as_voidptr(&$1), sizeof($type), $descriptor);
}

/* directorout */

%typemap(directorout) SWIGTYPE (CLASS::*) {
  int swig_res = SWIG_ConvertMember($input,SWIG_as_voidptr(&$result), sizeof($type), $descriptor);
  if (!SWIG_IsOK(swig_res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
  }
}


%apply SWIGTYPE (CLASS::*) { SWIGTYPE (CLASS::*const) }
%apply SWIGTYPE & { SWIGTYPE (CLASS::*const&) }

/* ------------------------------------------------------------
 * --- function ptr typemaps --- 
 * ------------------------------------------------------------ */

/*
  ISO C++ doesn't allow direct casting of a function ptr to a object
  ptr. So, maybe the ptr sizes are not the same, and we need to take
  some providences.
 */
%typemap(in) SWIGTYPE ((*)(ANY)) {
  int res = SWIG_ConvertFunctionPtr($input, (void**)(&$1), $descriptor);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
}

 %typemap(typecheck, precedence=      0     ,noblock=1)  SWIGTYPE ((*)(ANY)) {
  void *ptr = 0;
  int res = SWIG_ConvertFunctionPtr($input, &ptr, $descriptor);
  $1 = SWIG_CheckState(res);
}


%typemap(out, noblock=1) SWIGTYPE ((*)(ANY)) {
  $result = SWIG_NewFunctionPtrObj((void *)($1), $descriptor);
}

%typemap(varin) SWIGTYPE ((*)(ANY)) {
  int res = SWIG_ConvertFunctionPtr($input, (void**)(&$1), $descriptor);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'"); 
  }
}

%typemap(varout,noblock=1) SWIGTYPE ((*)(ANY)) {  
  $result = SWIG_NewFunctionPtrObj((void *)($1), $descriptor);
}

%typemap(constcode, noblock=1) SWIGTYPE ((*)(ANY)){
  SWIG_Python_SetConstant(d, "$symname",SWIG_NewFunctionPtrObj((void *)$value, $descriptor));
}
%typemap(constcode) SWIGTYPE ((* const)(ANY)) = SWIGTYPE ((*)(ANY));



/* directorin */

%typemap(directorin,noblock=1) SWIGTYPE ((*)(ANY)) {
  $input = SWIG_NewFunctionPtrObj((void*)($1), $descriptor);
}

/* directorout */

%typemap(directorout) SWIGTYPE ((*)(ANY)) {
  int swig_res = SWIG_ConvertFunctionPtr($input,(void**)(&$result),$descriptor);
  if (!SWIG_IsOK(swig_res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
  }
}


%apply SWIGTYPE ((*)(ANY)) { SWIGTYPE ((* const)(ANY)) }

%apply SWIGTYPE * { SWIGTYPE *const }

/* ------------------------------------------------------------
 * --- Special typemaps ---
 * ------------------------------------------------------------ */

/* DISOWN typemap */

%typemap(in, noblock=1) SWIGTYPE *DISOWN (int res = 0) {
  res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&$1), $descriptor, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
}

%typemap(varin) SWIGTYPE *DISOWN {
  void *temp = 0;
  int res = SWIG_ConvertPtr($input, &temp, $descriptor, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  $1 = ($ltype) temp;
}

/* DYNAMIC typemap */

%typemap(out,noblock=1) SWIGTYPE *DYNAMIC, SWIGTYPE &DYNAMIC {
  $result = SWIG_NewPointerObj(SWIG_as_voidptr($1), SWIG_TypeDynamicCast($descriptor, SWIG_as_voidptrptr(&$1)), $owner |  0 );
}

/* INSTANCE typemap */

%typemap(out,noblock=1) SWIGTYPE INSTANCE {
  $result = SWIG_NewInstanceObj((new $1_ltype(static_cast< const $1_ltype& >($1))), $&1_descriptor, SWIG_POINTER_OWN | 0 );
}

%typemap(out,noblock=1) SWIGTYPE *INSTANCE, SWIGTYPE &INSTANCE, SWIGTYPE INSTANCE[] {
  $result = SWIG_NewInstanceObj(SWIG_as_voidptr($1), $1_descriptor, $owner | 0 );
}

%typemap(varout,noblock=1) SWIGTYPE *INSTANCE, SWIGTYPE INSTANCE[] {
  $result = SWIG_NewInstanceObj(SWIG_as_voidptr($1), $1_descriptor, 0 );
}

%typemap(varout,noblock=1) SWIGTYPE &INSTANCE {
  $result = SWIG_NewInstanceObj(SWIG_as_voidptr($1), $1_descriptor, 0 );
}

%typemap(varout,noblock=1) SWIGTYPE INSTANCE {
  $result = SWIG_NewInstanceObj(SWIG_as_voidptr(&$1), $&1_descriptor, 0 );
}

%endoffile
%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/void.swg" %beginfile
/* ------------------------------------------------------------
 * Void * -  Accepts any kind of pointer
 * ------------------------------------------------------------ */

/* in */

%typemap(in,noblock=1) void * (int res) {
  res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1), 0, $disown);
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'"); 
  }
}
%typemap(freearg) void * "";

%typemap(in,noblock=1) void * const& ($*ltype temp = 0, int res) {
  res = SWIG_ConvertPtr($input, SWIG_as_voidptrptr(&temp), 0, $disown);
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "Stype""'"); 
  }
  $1 =  &temp;
}
%typemap(freearg) void * const& "";


/* out */


%typemap(out,noblock=1) void { $result = SWIG_Py_Void(); }




/* varin */

%typemap(varin) void * {
  void *temp = 0;
  int res = SWIG_ConvertPtr($input, &temp, 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  $1 = ($1_ltype) temp;
}

/* typecheck */

 %typemap(typecheck, precedence=      10    ,noblock=1)  void *
{
  void *ptr = 0;
  int res = SWIG_ConvertPtr($input, &ptr, 0, 0);
  $1 = SWIG_CheckState(res);
}



/* directorin */

%typemap(directorin,noblock=1) void *, void const*, void *const, void const *const, 
  void const *&, void *const &, void const *const & {
  $input = SWIG_NewPointerObj(SWIG_as_voidptr($1), $descriptor,  0 );
}

/* directorout */

%typemap(directorout,noblock=1) void * (void *argp, int res) {
  res = SWIG_ConvertPtr($input, &argp, 0, 0);
  if (!SWIG_IsOK(res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
  }
  $result = reinterpret_cast< $ltype >(argp);
}

%typemap(directorout,noblock=1,warning= "473:Returning a pointer or reference in a director method is not recommended." ) void * const& (void *argp, int res) {
  res = SWIG_ConvertPtr($input, &argp, 0, $disown);
  if (!SWIG_IsOK(res)) { 
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
  }
  static $*ltype temp = reinterpret_cast< $*ltype >(argp);
  $result =  &temp;
}





%endoffile
%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/swigobject.swg" %beginfile
/* ------------------------------------------------------------
 * Language Object *  - Just pass straight through unmodified
 * ------------------------------------------------------------ */

%typemap(in)   PyObject * "$1 = $input;";

%typemap(in,noblock=1)   PyObject * const & ($*ltype temp)
{
  temp = static_cast< $*ltype >($input);
  $1 = &temp;
}

%typemap(out,noblock=1) PyObject * {
  $result = $1;
}

%typemap(out,noblock=1)  PyObject * const & {
  $result = *$1;
}

 %typemap(typecheck, precedence=       5000    )  PyObject * "$1 = ($input != 0);";

%typemap(throws,noblock=1) PyObject * {
  SWIG_Python_Raise($1, "$type", 0); SWIG_fail;
}

%typemap(constcode,noblock=1) PyObject * {
  SWIG_Python_SetConstant(d, "$symname",$value);
}



%typemap(directorin) PyObject * "$input = $1;";
%typemap(directorout) PyObject * "$result = $input;";



%endoffile
%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg" %beginfile
/*---------------------------------------------------------------------
 * Value typemaps (Type, const Type&) for value types, such as
 * fundamental types (int, double), that define the AsVal/From
 * methods.
 *
 * To apply them, just use one of the following macros:
 *
 *   %typemaps_from(FromMeth, FromFrag, Type)
 *   %typemaps_asval(CheckCode, AsValMeth, AsValFrag, Type)
 *   %typemaps_asvalfrom(CheckCode, AsValMeth, FromMeth, AsValFrag, FromFrag, Type)
 *
 * or the simpler and normalize form:
 *
 *   %typemaps_asvalfromn(CheckCode, Type)
 *
 * Also, you can use the individual typemap definitions:
 *
 *    %value_in_typemap(asval_meth,frag,Type)
 *    %value_varin_typemap(asval_meth,frag,Type)
 *    %value_typecheck_typemap(checkcode,asval_meth,frag,Type)
 *    %value_directorout_typemap(asval_meth,frag,Type)
 *
 *    %value_out_typemap(from_meth,frag,Type)
 *    %value_varout_typemap(from_meth,frag,Type)
 *    %value_constcode_typemap(from_meth,frag,Type)
 *    %value_directorin_typemap(from_meth,frag,Type)
 *    %value_throws_typemap(from_meth,frag,Type)
 *
 *---------------------------------------------------------------------*/

/* in */





















/* out */










/* varin */












/* varout */







/* constant installation code */










/* directorin */










/* directorout */











































/* throws */







/* typecheck */








/*---------------------------------------------------------------------
 * typemap definition for types with AsVal methods
 *---------------------------------------------------------------------*/









/*---------------------------------------------------------------------
 * typemap definition for types with from method
 *---------------------------------------------------------------------*/










/*---------------------------------------------------------------------
 * typemap definition for types with alval/from method
 *---------------------------------------------------------------------*/









/*---------------------------------------------------------------------
 * typemap definition for types  with for 'normalized' asval/from methods
 *---------------------------------------------------------------------*/








%endoffile
%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/ptrtypes.swg" %beginfile
/* -----------------------------------------------------------------------------
 * ptrtypes.swg
 *
 * Value typemaps (Type, const Type&) for "Ptr" types, such as swig
 * wrapped classes, that define the AsPtr/From methods
 *
 * To apply them, just use one of the following macros:
 *
 *    %typemaps_asptr(CheckCode, AsPtrMeth, AsPtrFrag, Type)
 *    %typemaps_asptrfrom(CheckCode, AsPtrMeth, FromMeth, AsPtrFrag, FromFrag, Type)
 *
 * or the simpler and normalize form:
 *
 *    %typemaps_asptrfromn(CheckCode, Type)
 *
 * Also, you can use the individual typemap definitions:
 *
 *    %ptr_in_typemap(asptr_meth,frag,Type)
 *    %ptr_varin_typemap(asptr_meth,frag,Type)
 *    %ptr_typecheck_typemap(check,asptr_meth,frag,Type)
 *    %ptr_directorout_typemap(asptr_meth,frag,Type)
 * ----------------------------------------------------------------------------- */



/* in */
























/* varin */














/* directorout */










































































/* typecheck */














/*---------------------------------------------------------------------
 * typemap definition for types with asptr method
 *---------------------------------------------------------------------*/



























/*---------------------------------------------------------------------
 * typemap definition for types with asptr/from methods
 *---------------------------------------------------------------------*/








/*---------------------------------------------------------------------
 * typemap definition for types  with for 'normalized' asptr/from methods
 *---------------------------------------------------------------------*/









%endoffile
%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg" %beginfile
/*  ------------------------------------------------------------
 *
 * Define the IN/OUTPUT typemaps assuming the output parameters are
 * returned in a list, i.e., they are not directly modified.
 *
 * The user should provide the %append_output(result, obj) method,
 * via a macro, which append a particular object to the result.
 *
 *
 * In Tcl, for example, the file is used as:
 *
 *   #define %append_output(obj) Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),obj);
 *   %include <typemaps/inoutlist.swg>
 *
 * while in Python it is used as:
 *
 *   #define %append_output(obj) $result = SWIG_Python_AppendResult($result, obj)
 *   %include <typemaps/inoutlist.swg>
 *
 * where the method SWIG_Python_AppendResult is defined inside the
 * %append_output fragment.
 *
 * If you forget to define %append_output, this file will generate
 * an error.
 *
 * ------------------------------------------------------------ */


//
// Uncomment the following definition if you don't want the in/out
// typemaps by default, ie, you prefer to use typemaps.i.
//
//#define SWIG_INOUT_NODEF

//
// Use the following definition to enable the INPUT parameters to
// accept both 'by value' and 'pointer' objects.
//


// ------------------------------------------------------------------------
// Pointer handling
//
// These mappings provide support for input/output arguments and common
// uses for C/C++ pointers.
// ------------------------------------------------------------------------

// INPUT typemaps.
// These remap a C pointer to be an "INPUT" value which is passed by value
// instead of reference.

/* 
The following methods can be applied to turn a pointer into a simple
"input" value.  That is, instead of passing a pointer to an object,
you would use a real value instead.
         
To use these, suppose you had a C function like this :

        double fadd(double *a, double *b) {
               return *a+*b;
        }

You could wrap it with SWIG as follows :

        double fadd(double *INPUT, double *INPUT);

or you can use the %apply directive :

        %apply double *INPUT { double *a, double *b };
        double fadd(double *a, double *b);

*/







































































// OUTPUT typemaps.   These typemaps are used for parameters that
// are output only.   The output value is appended to the result as
// a list element.

/* 
The following methods can be applied to turn a pointer into an "output"
value.  When calling a function, no input value would be given for
a parameter, but an output value would be returned.  In the case of
multiple output values, they are returned in the form of a list.

         
For example, suppose you were trying to wrap the modf() function in the
C math library which splits x into integral and fractional parts (and
returns the integer part in one of its parameters):

        double modf(double x, double *ip);

You could wrap it with SWIG as follows :

        double modf(double x, double *OUTPUT);

or you can use the %apply directive :

        %apply double *OUTPUT { double *ip };
        double modf(double x, double *ip);

The output of the function would be a list containing both output
values.

*/


















// INOUT
// Mappings for an argument that is both an input and output
// parameter

/*
The following methods can be applied to make a function parameter both
an input and output value.  This combines the behavior of both the
"INPUT" and "OUTPUT" methods described earlier.  Output values are
returned in the form of a list.  
         
For example, suppose you were trying to wrap the following function :

        void neg(double *x) {
             *x = -(*x);
        }

You could wrap it with SWIG as follows :

        void neg(double *INOUT);

or you can use the %apply directive :

        %apply double *INOUT { double *x };
        void neg(double *x);

Unlike C, this mapping does not directly modify the input value.
Rather, the modified input value shows up as the return value of the
function.  Thus, to apply this function to a variable you might do
this :

       x = neg(x)

Note : previous versions of SWIG used the symbol 'BOTH' to mark
input/output arguments.   This is still supported, but will be slowly
phased out in future releases.

*/















































/*----------------------------------------------------------------------
  Front ends.
  
  use the following macros to define your own IN/OUTPUT/INOUT typemaps
  
  ------------------------------------------------------------------------*/















%endoffile
%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/primtypes.swg" %beginfile
/* ------------------------------------------------------------
 * Primitive type fragments and macros 
 * ------------------------------------------------------------ */

/*
  This file provide fragments and macros for the C/C++ primitive types. 

  The file defines default fragments for the following types:

    bool
    signed char
    unsigned char
    signed wchar_t     // in C++
    unsigned wchar_t   // in C++
    short
    unsigned short
    int
    unsigned int
    float
    size_t
    ptrdiff_t

  which can always be redefined in the swig target language if needed.
  
  The fragments for the following types, however, always need to be
  defined in the target language:

    long
    unsigned long
    long long
    unsigned long long
    double
 
  If they are not provided, an #error directive will appear in the
  wrapped code.

  --------------------------------------------------------------------
  
  This file provides the macro

    %typemaps_primitive(CheckCode, Type)

  which generates the typemaps for a primitive type with a given
  checkcode. It is assumed that the primitive type is 'normalized' and
  the corresponding SWIG_AsVal(Type) and SWIG_From(Type) methods are
  provided via fragments.
  
   
  The following auxiliary macros (explained with bash pseudo code) are
  also defined:

    %apply_ctypes(Macro)
      for i in C Type
      do
        Macro($i)
      done

    %apply_cpptypes(Macro)
      for i in C++ Type
      do
        Macro($i)
      done

    %apply_ctypes_2(Macro2)
       for i in C Type
       do
         for j in C Type
         do
            Macro_2($i, $j)
         done
       done

    %apply_cpptypes_2(Macro2)
       for i in C++ Type
       do
         for j in C++ Type
         do
            Macro_2($i, $j)
         done
       done

    %apply_checkctypes(Macro2)
       for i in Check Type
       do
         Macro2(%checkcode($i), $i)
       done

*/


/* ------------------------------------------------------------
 * Primitive type fragments 
 * ------------------------------------------------------------ */
/* boolean */

%fragment("SWIG_" "From" "_" {bool},"header",fragment="SWIG_" "From" "_" {long}) {
SWIGINTERN PyObject *
SWIG_From_bool  (bool value)
{    
  return SWIG_From_long  (value ? 1 : 0);
}
}

%fragment("SWIG_" "AsVal" "_" {bool},"header",fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_bool (PyObject * obj, bool *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res)) {    
    if (val) *val = v ? true : false;
    return res;
  }  
  return SWIG_TypeError;
}
}

/* signed/unsigned char */

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,192,%numeric_slong@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,151,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {signed char},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_signed_SS_char  (signed char value)
{    
  return SWIG_From_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,162,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {signed char},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_signed_SS_char (PyObject * obj, signed char *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SCHAR_MIN || v > SCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< signed char >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,199,%numeric_ulong@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,151,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {unsigned char},"header",
	  fragment="SWIG_" "From" "_" {unsigned long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_unsigned_SS_char  (unsigned char value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,162,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {unsigned char},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_char (PyObject * obj, unsigned char *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned char >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/

/* short/unsigned short */

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,192,%numeric_slong@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,151,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {short},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_short  (short value)
{    
  return SWIG_From_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,162,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {short},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_short (PyObject * obj, short *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SHRT_MIN || v > SHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< short >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,199,%numeric_ulong@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,151,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {unsigned short},"header",
	  fragment="SWIG_" "From" "_" {unsigned long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_unsigned_SS_short  (unsigned short value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,162,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {unsigned short},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_short (PyObject * obj, unsigned short *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > USHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned short >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/

/* int/unsigned int */

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,192,%numeric_slong@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,151,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {int},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,162,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {int},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,199,%numeric_ulong@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,151,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {unsigned int},"header",
	  fragment="SWIG_" "From" "_" {unsigned long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,162,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {unsigned int},"header",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/

/* signed/unsigned wchar_t */


/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,192,%numeric_slong@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,151,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {signed wchar_t},"header",
	  fragment="SWIG_" "From" "_" {long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_signed_SS_wchar_t  (signed wchar_t value)
{    
  return SWIG_From_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,162,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {signed wchar_t},"header",
	  fragment="<wchar.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_signed_SS_wchar_t (PyObject * obj, signed wchar_t *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < WCHAR_MIN || v > WCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< signed wchar_t >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,199,%numeric_ulong@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,151,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {unsigned wchar_t},"header",
	  fragment="SWIG_" "From" "_" {unsigned long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_unsigned_SS_wchar_t  (unsigned wchar_t value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}
}
/*@SWIG@*/
 /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,162,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {unsigned wchar_t},"header",
	  fragment="<wchar.h>",
	  fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERN int
SWIG_AsVal_unsigned_SS_wchar_t (PyObject * obj, unsigned wchar_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UWCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned wchar_t >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/


/* float */

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,214,%numeric_float@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,151,%numeric_type_from@*/
%fragment("SWIG_" "From" "_" {float},"header",
	  fragment="SWIG_" "From" "_" {double}) {
SWIGINTERNINLINE PyObject *
SWIG_From_float  (float value)
{    
  return SWIG_From_double  (value);
}
}
/*@SWIG@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,162,%numeric_type_asval@*/
%fragment("SWIG_" "AsVal" "_" {float},"header",
	  fragment="SWIG_Float_Overflow_Check",
	  fragment="SWIG_" "AsVal" "_" {double}) {
SWIGINTERN int
SWIG_AsVal_float (PyObject * obj, float *val)
{
  double v;
  int res = SWIG_AsVal_double (obj, &v);
  if (SWIG_IsOK(res)) {
    if (SWIG_Float_Overflow_Check(v)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< float >(v);
    }
  }  
  return res;
}
}
/*@SWIG@*/
/*@SWIG@*/

/* long/unsigned long */

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,228,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {long},"header") {
#error "SWIG language implementation must provide a SWIG_From_frag(long) fragment"
}
%fragment("SWIG_" "AsVal" "_" {long},"header") {
#error "SWIG language implementation must provide a SWIG_AsVal_frag(long) fragment"
}
/*@SWIG@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,228,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {unsigned long},"header") {
#error "SWIG language implementation must provide a SWIG_From_frag(unsigned long) fragment"
}
%fragment("SWIG_" "AsVal" "_" {unsigned long},"header") {
#error "SWIG language implementation must provide a SWIG_AsVal_frag(unsigned long) fragment"
}
/*@SWIG@*/

/* long long/unsigned long long */

%fragment("SWIG_LongLongAvailable","header", fragment="<limits.h>") %{
#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif
%}

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,228,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {long long},"header") {
#error "SWIG language implementation must provide a SWIG_From_frag(long long) fragment"
}
%fragment("SWIG_" "AsVal" "_" {long long},"header") {
#error "SWIG language implementation must provide a SWIG_AsVal_frag(long long) fragment"
}
/*@SWIG@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,228,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {unsigned long long},"header") {
#error "SWIG language implementation must provide a SWIG_From_frag(unsigned long long) fragment"
}
%fragment("SWIG_" "AsVal" "_" {unsigned long long},"header") {
#error "SWIG language implementation must provide a SWIG_AsVal_frag(unsigned long long) fragment"
}
/*@SWIG@*/

/* double */

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,228,%ensure_type_fragments@*/
%fragment("SWIG_" "From" "_" {double},"header") {
#error "SWIG language implementation must provide a SWIG_From_frag(double) fragment"
}
%fragment("SWIG_" "AsVal" "_" {double},"header") {
#error "SWIG language implementation must provide a SWIG_AsVal_frag(double) fragment"
}
/*@SWIG@*/

/* size_t */

%fragment("SWIG_" "From" "_" {size_t},"header",fragment="SWIG_" "From" "_" {unsigned long},fragment="SWIG_" "From" "_" {unsigned long long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_size_t  (size_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(size_t) <= sizeof(unsigned long long) */
    return SWIG_From_unsigned_SS_long_SS_long  (static_cast< unsigned long long >(value));
  }
#endif
}
}

%fragment("SWIG_" "AsVal" "_" {size_t},"header",fragment="SWIG_" "AsVal" "_" {unsigned long},fragment="SWIG_" "AsVal" "_" {unsigned long long}) {
SWIGINTERNINLINE int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
    unsigned long long v;
    res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  }
#endif
  return res;
}
}

/* ptrdiff_t */

%fragment("SWIG_" "From" "_" {ptrdiff_t},"header",fragment="SWIG_" "From" "_" {long},fragment="SWIG_" "From" "_" {long long}) {
SWIGINTERNINLINE PyObject *
SWIG_From_ptrdiff_t  (ptrdiff_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(ptrdiff_t) <= sizeof(long)) {
#endif
    return SWIG_From_long  (static_cast< long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(ptrdiff_t) <= sizeof(long long) */
    return SWIG_From_long_SS_long  (static_cast< long long >(value));
  }
#endif
}
}

%fragment("SWIG_" "AsVal" "_" {ptrdiff_t},"header",fragment="SWIG_" "AsVal" "_" {long},fragment="SWIG_" "AsVal" "_" {long long}) {
SWIGINTERNINLINE int
SWIG_AsVal_ptrdiff_t (PyObject * obj, ptrdiff_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(ptrdiff_t) <= sizeof(long)) {
#endif
    long v;
    res = SWIG_AsVal_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(ptrdiff_t) <= sizeof(long long)) {
    long long v;
    res = SWIG_AsVal_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
  }
#endif
  return res;
}
}


%fragment("SWIG_CanCastAsInteger","header",
	  fragment="SWIG_" "AsVal" "_" {double},
	  fragment="<float.h>",
	  fragment="<math.h>") {
SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}
}

/* ------------------------------------------------------------
 * Generate the typemaps for primitive type 
 * ------------------------------------------------------------ */



/* ------------------------------------------------------------
 * Primitive Type Macros
 * ------------------------------------------------------------ */

/* useful macros to derive typemap declarations from primitive types */









/* Apply macro to the C-types */




















/* apply the Macro2(Type1, Type2) to all  C types  */



/* apply the Macro(Type) to all  C++ types  */










/* apply the Macro2(Type1, Type2) to all  C++ types  */


/* apply the Macro2(CheckCode,Type) to all  Checked Types */





















/* ------------------------------------------------------------
 * Generate the typemaps for all the primitive types with checkcode
 * ------------------------------------------------------------ */

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/primtypes.swg,341,%apply_checkctypes@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool (bool val, int ecode = 0) {
    ecode = SWIG_AsVal_bool($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) bool "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) const bool & ($*ltype temp, bool val, int ecode = 0) {  
    ecode = SWIG_AsVal_bool($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const bool& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {bool}) bool {
    bool val;
    int res = SWIG_AsVal_bool($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool *DIRECTOROUT(bool swig_val, int swig_res) {
    swig_res = SWIG_AsVal_bool($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool {
    bool swig_val;
    int swig_res = SWIG_AsVal_bool($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {bool},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const bool& {  
    bool swig_val;
    int swig_res = SWIG_AsVal_bool($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const bool & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {bool}) bool &DIRECTOROUT = bool
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=15,fragment="SWIG_" "AsVal" "_" {bool}) bool, const bool& {
    int res = SWIG_AsVal_bool($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      bool val; 
      int ecode = SWIG_AsVal_bool($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {bool}) bool &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      bool val;
      int ecode = SWIG_AsVal_bool($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") bool *INPUT, bool &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=15,fragment="SWIG_" "AsVal" "_" {bool}) bool *INPUT, bool &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_bool($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool, const bool {
    $result = SWIG_From_bool(static_cast< bool >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {bool}) const bool& {
    $result = SWIG_From_bool(static_cast< bool >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool, const bool&  {
    $result = SWIG_From_bool(static_cast< bool >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_bool(static_cast< bool >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool *DIRECTORIN {
    $input = SWIG_From_bool(static_cast< bool >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool, const bool& {
    $input = SWIG_From_bool(static_cast< bool >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool {
    SWIG_Python_Raise(SWIG_From_bool(static_cast< bool >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   bool *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   bool &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {bool}) bool *OUTPUT, bool &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_bool((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) bool *INOUT = bool *INPUT;
 %typemap(in) bool &INOUT = bool &INPUT;
 %typemap(typecheck) bool *INOUT = bool *INPUT;
 %typemap(typecheck) bool &INOUT = bool &INPUT;
 %typemap(argout) bool *INOUT = bool *OUTPUT;
 %typemap(argout) bool &INOUT = bool &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char (signed char val, int ecode = 0) {
    ecode = SWIG_AsVal_signed_SS_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) signed char "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) const signed char & ($*ltype temp, signed char val, int ecode = 0) {  
    ecode = SWIG_AsVal_signed_SS_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const signed char& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {signed char}) signed char {
    signed char val;
    int res = SWIG_AsVal_signed_SS_char($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char *DIRECTOROUT(signed char swig_val, int swig_res) {
    swig_res = SWIG_AsVal_signed_SS_char($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char {
    signed char swig_val;
    int swig_res = SWIG_AsVal_signed_SS_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const signed char& {  
    signed char swig_val;
    int swig_res = SWIG_AsVal_signed_SS_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const signed char & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {signed char}) signed char &DIRECTOROUT = signed char
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=25,fragment="SWIG_" "AsVal" "_" {signed char}) signed char, const signed char& {
    int res = SWIG_AsVal_signed_SS_char($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      signed char val; 
      int ecode = SWIG_AsVal_signed_SS_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {signed char}) signed char &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      signed char val;
      int ecode = SWIG_AsVal_signed_SS_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") signed char *INPUT, signed char &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=25,fragment="SWIG_" "AsVal" "_" {signed char}) signed char *INPUT, signed char &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_signed_SS_char($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char, const signed char {
    $result = SWIG_From_signed_SS_char(static_cast< signed char >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {signed char}) const signed char& {
    $result = SWIG_From_signed_SS_char(static_cast< signed char >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char, const signed char&  {
    $result = SWIG_From_signed_SS_char(static_cast< signed char >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_signed_SS_char(static_cast< signed char >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char *DIRECTORIN {
    $input = SWIG_From_signed_SS_char(static_cast< signed char >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char, const signed char& {
    $input = SWIG_From_signed_SS_char(static_cast< signed char >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char {
    SWIG_Python_Raise(SWIG_From_signed_SS_char(static_cast< signed char >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   signed char *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   signed char &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {signed char}) signed char *OUTPUT, signed char &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_signed_SS_char((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) signed char *INOUT = signed char *INPUT;
 %typemap(in) signed char &INOUT = signed char &INPUT;
 %typemap(typecheck) signed char *INOUT = signed char *INPUT;
 %typemap(typecheck) signed char &INOUT = signed char &INPUT;
 %typemap(argout) signed char *INOUT = signed char *OUTPUT;
 %typemap(argout) signed char &INOUT = signed char &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char (unsigned char val, int ecode = 0) {
    ecode = SWIG_AsVal_unsigned_SS_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) unsigned char "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) const unsigned char & ($*ltype temp, unsigned char val, int ecode = 0) {  
    ecode = SWIG_AsVal_unsigned_SS_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned char& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char {
    unsigned char val;
    int res = SWIG_AsVal_unsigned_SS_char($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char *DIRECTOROUT(unsigned char swig_val, int swig_res) {
    swig_res = SWIG_AsVal_unsigned_SS_char($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char {
    unsigned char swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned char& {  
    unsigned char swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const unsigned char & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char &DIRECTOROUT = unsigned char
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=20,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char, const unsigned char& {
    int res = SWIG_AsVal_unsigned_SS_char($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned char val; 
      int ecode = SWIG_AsVal_unsigned_SS_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned char val;
      int ecode = SWIG_AsVal_unsigned_SS_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned char *INPUT, unsigned char &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=20,fragment="SWIG_" "AsVal" "_" {unsigned char}) unsigned char *INPUT, unsigned char &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_unsigned_SS_char($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char, const unsigned char {
    $result = SWIG_From_unsigned_SS_char(static_cast< unsigned char >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) const unsigned char& {
    $result = SWIG_From_unsigned_SS_char(static_cast< unsigned char >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char, const unsigned char&  {
    $result = SWIG_From_unsigned_SS_char(static_cast< unsigned char >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_char(static_cast< unsigned char >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char *DIRECTORIN {
    $input = SWIG_From_unsigned_SS_char(static_cast< unsigned char >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char, const unsigned char& {
    $input = SWIG_From_unsigned_SS_char(static_cast< unsigned char >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char {
    SWIG_Python_Raise(SWIG_From_unsigned_SS_char(static_cast< unsigned char >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned char *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned char &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned char}) unsigned char *OUTPUT, unsigned char &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_char((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned char *INOUT = unsigned char *INPUT;
 %typemap(in) unsigned char &INOUT = unsigned char &INPUT;
 %typemap(typecheck) unsigned char *INOUT = unsigned char *INPUT;
 %typemap(typecheck) unsigned char &INOUT = unsigned char &INPUT;
 %typemap(argout) unsigned char *INOUT = unsigned char *OUTPUT;
 %typemap(argout) unsigned char &INOUT = unsigned char &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short (short val, int ecode = 0) {
    ecode = SWIG_AsVal_short($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) short "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) const short & ($*ltype temp, short val, int ecode = 0) {  
    ecode = SWIG_AsVal_short($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const short& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {short}) short {
    short val;
    int res = SWIG_AsVal_short($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short *DIRECTOROUT(short swig_val, int swig_res) {
    swig_res = SWIG_AsVal_short($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short {
    short swig_val;
    int swig_res = SWIG_AsVal_short($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {short},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const short& {  
    short swig_val;
    int swig_res = SWIG_AsVal_short($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const short & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {short}) short &DIRECTOROUT = short
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=35,fragment="SWIG_" "AsVal" "_" {short}) short, const short& {
    int res = SWIG_AsVal_short($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      short val; 
      int ecode = SWIG_AsVal_short($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {short}) short &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      short val;
      int ecode = SWIG_AsVal_short($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") short *INPUT, short &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=35,fragment="SWIG_" "AsVal" "_" {short}) short *INPUT, short &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_short($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {short}) short, const short {
    $result = SWIG_From_short(static_cast< short >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {short}) const short& {
    $result = SWIG_From_short(static_cast< short >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {short}) short, const short&  {
    $result = SWIG_From_short(static_cast< short >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {short}) short {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_short(static_cast< short >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {short}) short *DIRECTORIN {
    $input = SWIG_From_short(static_cast< short >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {short}) short, const short& {
    $input = SWIG_From_short(static_cast< short >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {short}) short {
    SWIG_Python_Raise(SWIG_From_short(static_cast< short >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   short *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   short &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {short}) short *OUTPUT, short &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_short((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) short *INOUT = short *INPUT;
 %typemap(in) short &INOUT = short &INPUT;
 %typemap(typecheck) short *INOUT = short *INPUT;
 %typemap(typecheck) short &INOUT = short &INPUT;
 %typemap(argout) short *INOUT = short *OUTPUT;
 %typemap(argout) short &INOUT = short &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short (unsigned short val, int ecode = 0) {
    ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) unsigned short "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) const unsigned short & ($*ltype temp, unsigned short val, int ecode = 0) {  
    ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned short& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short {
    unsigned short val;
    int res = SWIG_AsVal_unsigned_SS_short($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short *DIRECTOROUT(unsigned short swig_val, int swig_res) {
    swig_res = SWIG_AsVal_unsigned_SS_short($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short {
    unsigned short swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_short($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned short& {  
    unsigned short swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_short($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const unsigned short & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short &DIRECTOROUT = unsigned short
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=30,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short, const unsigned short& {
    int res = SWIG_AsVal_unsigned_SS_short($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned short val; 
      int ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned short val;
      int ecode = SWIG_AsVal_unsigned_SS_short($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned short *INPUT, unsigned short &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=30,fragment="SWIG_" "AsVal" "_" {unsigned short}) unsigned short *INPUT, unsigned short &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_unsigned_SS_short($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short, const unsigned short {
    $result = SWIG_From_unsigned_SS_short(static_cast< unsigned short >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) const unsigned short& {
    $result = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short, const unsigned short&  {
    $result = SWIG_From_unsigned_SS_short(static_cast< unsigned short >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_short(static_cast< unsigned short >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short *DIRECTORIN {
    $input = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short, const unsigned short& {
    $input = SWIG_From_unsigned_SS_short(static_cast< unsigned short >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short {
    SWIG_Python_Raise(SWIG_From_unsigned_SS_short(static_cast< unsigned short >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned short *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned short &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned short}) unsigned short *OUTPUT, unsigned short &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_short((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned short *INOUT = unsigned short *INPUT;
 %typemap(in) unsigned short &INOUT = unsigned short &INPUT;
 %typemap(typecheck) unsigned short *INOUT = unsigned short *INPUT;
 %typemap(typecheck) unsigned short &INOUT = unsigned short &INPUT;
 %typemap(argout) unsigned short *INOUT = unsigned short *OUTPUT;
 %typemap(argout) unsigned short &INOUT = unsigned short &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int (int val, int ecode = 0) {
    ecode = SWIG_AsVal_int($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) int "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) const int & ($*ltype temp, int val, int ecode = 0) {  
    ecode = SWIG_AsVal_int($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const int& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {int}) int {
    int val;
    int res = SWIG_AsVal_int($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int *DIRECTOROUT(int swig_val, int swig_res) {
    swig_res = SWIG_AsVal_int($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int {
    int swig_val;
    int swig_res = SWIG_AsVal_int($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {int},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const int& {  
    int swig_val;
    int swig_res = SWIG_AsVal_int($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const int & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {int}) int &DIRECTOROUT = int
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=45,fragment="SWIG_" "AsVal" "_" {int}) int, const int& {
    int res = SWIG_AsVal_int($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      int val; 
      int ecode = SWIG_AsVal_int($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {int}) int &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      int val;
      int ecode = SWIG_AsVal_int($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") int *INPUT, int &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=45,fragment="SWIG_" "AsVal" "_" {int}) int *INPUT, int &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_int($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {int}) int, const int {
    $result = SWIG_From_int(static_cast< int >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {int}) const int& {
    $result = SWIG_From_int(static_cast< int >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {int}) int, const int&  {
    $result = SWIG_From_int(static_cast< int >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {int}) int {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_int(static_cast< int >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {int}) int *DIRECTORIN {
    $input = SWIG_From_int(static_cast< int >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {int}) int, const int& {
    $input = SWIG_From_int(static_cast< int >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {int}) int {
    SWIG_Python_Raise(SWIG_From_int(static_cast< int >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   int *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   int &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {int}) int *OUTPUT, int &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_int((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) int *INOUT = int *INPUT;
 %typemap(in) int &INOUT = int &INPUT;
 %typemap(typecheck) int *INOUT = int *INPUT;
 %typemap(typecheck) int &INOUT = int &INPUT;
 %typemap(argout) int *INOUT = int *OUTPUT;
 %typemap(argout) int &INOUT = int &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int (unsigned int val, int ecode = 0) {
    ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) unsigned int "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) const unsigned int & ($*ltype temp, unsigned int val, int ecode = 0) {  
    ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned int& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int {
    unsigned int val;
    int res = SWIG_AsVal_unsigned_SS_int($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int *DIRECTOROUT(unsigned int swig_val, int swig_res) {
    swig_res = SWIG_AsVal_unsigned_SS_int($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int {
    unsigned int swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_int($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned int& {  
    unsigned int swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_int($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const unsigned int & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int &DIRECTOROUT = unsigned int
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=40,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int, const unsigned int& {
    int res = SWIG_AsVal_unsigned_SS_int($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned int val; 
      int ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned int val;
      int ecode = SWIG_AsVal_unsigned_SS_int($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned int *INPUT, unsigned int &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=40,fragment="SWIG_" "AsVal" "_" {unsigned int}) unsigned int *INPUT, unsigned int &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_unsigned_SS_int($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int, const unsigned int {
    $result = SWIG_From_unsigned_SS_int(static_cast< unsigned int >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) const unsigned int& {
    $result = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int, const unsigned int&  {
    $result = SWIG_From_unsigned_SS_int(static_cast< unsigned int >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_int(static_cast< unsigned int >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int *DIRECTORIN {
    $input = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int, const unsigned int& {
    $input = SWIG_From_unsigned_SS_int(static_cast< unsigned int >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int {
    SWIG_Python_Raise(SWIG_From_unsigned_SS_int(static_cast< unsigned int >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned int *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned int &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned int}) unsigned int *OUTPUT, unsigned int &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_int((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned int *INOUT = unsigned int *INPUT;
 %typemap(in) unsigned int &INOUT = unsigned int &INPUT;
 %typemap(typecheck) unsigned int *INOUT = unsigned int *INPUT;
 %typemap(typecheck) unsigned int &INOUT = unsigned int &INPUT;
 %typemap(argout) unsigned int *INOUT = unsigned int *OUTPUT;
 %typemap(argout) unsigned int &INOUT = unsigned int &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long (long val, int ecode = 0) {
    ecode = SWIG_AsVal_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) long "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) const long & ($*ltype temp, long val, int ecode = 0) {  
    ecode = SWIG_AsVal_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const long& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {long}) long {
    long val;
    int res = SWIG_AsVal_long($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long *DIRECTOROUT(long swig_val, int swig_res) {
    swig_res = SWIG_AsVal_long($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long {
    long swig_val;
    int swig_res = SWIG_AsVal_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {long},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const long& {  
    long swig_val;
    int swig_res = SWIG_AsVal_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const long & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {long}) long &DIRECTOROUT = long
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=55,fragment="SWIG_" "AsVal" "_" {long}) long, const long& {
    int res = SWIG_AsVal_long($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      long val; 
      int ecode = SWIG_AsVal_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long}) long &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      long val;
      int ecode = SWIG_AsVal_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") long *INPUT, long &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=55,fragment="SWIG_" "AsVal" "_" {long}) long *INPUT, long &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_long($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long}) long, const long {
    $result = SWIG_From_long(static_cast< long >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long}) const long& {
    $result = SWIG_From_long(static_cast< long >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {long}) long, const long&  {
    $result = SWIG_From_long(static_cast< long >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {long}) long {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_long(static_cast< long >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {long}) long *DIRECTORIN {
    $input = SWIG_From_long(static_cast< long >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {long}) long, const long& {
    $input = SWIG_From_long(static_cast< long >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {long}) long {
    SWIG_Python_Raise(SWIG_From_long(static_cast< long >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {long}) long *OUTPUT, long &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_long((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) long *INOUT = long *INPUT;
 %typemap(in) long &INOUT = long &INPUT;
 %typemap(typecheck) long *INOUT = long *INPUT;
 %typemap(typecheck) long &INOUT = long &INPUT;
 %typemap(argout) long *INOUT = long *OUTPUT;
 %typemap(argout) long &INOUT = long &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long (unsigned long val, int ecode = 0) {
    ecode = SWIG_AsVal_unsigned_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) unsigned long "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) const unsigned long & ($*ltype temp, unsigned long val, int ecode = 0) {  
    ecode = SWIG_AsVal_unsigned_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned long& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long {
    unsigned long val;
    int res = SWIG_AsVal_unsigned_SS_long($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long *DIRECTOROUT(unsigned long swig_val, int swig_res) {
    swig_res = SWIG_AsVal_unsigned_SS_long($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long {
    unsigned long swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned long& {  
    unsigned long swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const unsigned long & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long &DIRECTOROUT = unsigned long
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=50,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long, const unsigned long& {
    int res = SWIG_AsVal_unsigned_SS_long($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned long val; 
      int ecode = SWIG_AsVal_unsigned_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned long val;
      int ecode = SWIG_AsVal_unsigned_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned long *INPUT, unsigned long &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=50,fragment="SWIG_" "AsVal" "_" {unsigned long}) unsigned long *INPUT, unsigned long &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_unsigned_SS_long($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long, const unsigned long {
    $result = SWIG_From_unsigned_SS_long(static_cast< unsigned long >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) const unsigned long& {
    $result = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long, const unsigned long&  {
    $result = SWIG_From_unsigned_SS_long(static_cast< unsigned long >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_long(static_cast< unsigned long >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long *DIRECTORIN {
    $input = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long, const unsigned long& {
    $input = SWIG_From_unsigned_SS_long(static_cast< unsigned long >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long {
    SWIG_Python_Raise(SWIG_From_unsigned_SS_long(static_cast< unsigned long >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long}) unsigned long *OUTPUT, unsigned long &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_long((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned long *INOUT = unsigned long *INPUT;
 %typemap(in) unsigned long &INOUT = unsigned long &INPUT;
 %typemap(typecheck) unsigned long *INOUT = unsigned long *INPUT;
 %typemap(typecheck) unsigned long &INOUT = unsigned long &INPUT;
 %typemap(argout) unsigned long *INOUT = unsigned long *OUTPUT;
 %typemap(argout) unsigned long &INOUT = unsigned long &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long (long long val, int ecode = 0) {
    ecode = SWIG_AsVal_long_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) long long "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) const long long & ($*ltype temp, long long val, int ecode = 0) {  
    ecode = SWIG_AsVal_long_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const long long& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {long long}) long long {
    long long val;
    int res = SWIG_AsVal_long_SS_long($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long *DIRECTOROUT(long long swig_val, int swig_res) {
    swig_res = SWIG_AsVal_long_SS_long($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long {
    long long swig_val;
    int swig_res = SWIG_AsVal_long_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {long long},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const long long& {  
    long long swig_val;
    int swig_res = SWIG_AsVal_long_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const long long & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {long long}) long long &DIRECTOROUT = long long
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=65,fragment="SWIG_" "AsVal" "_" {long long}) long long, const long long& {
    int res = SWIG_AsVal_long_SS_long($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      long long val; 
      int ecode = SWIG_AsVal_long_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {long long}) long long &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      long long val;
      int ecode = SWIG_AsVal_long_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") long long *INPUT, long long &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=65,fragment="SWIG_" "AsVal" "_" {long long}) long long *INPUT, long long &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_long_SS_long($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long, const long long {
    $result = SWIG_From_long_SS_long(static_cast< long long >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {long long}) const long long& {
    $result = SWIG_From_long_SS_long(static_cast< long long >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long, const long long&  {
    $result = SWIG_From_long_SS_long(static_cast< long long >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_long_SS_long(static_cast< long long >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long *DIRECTORIN {
    $input = SWIG_From_long_SS_long(static_cast< long long >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long, const long long& {
    $input = SWIG_From_long_SS_long(static_cast< long long >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long {
    SWIG_Python_Raise(SWIG_From_long_SS_long(static_cast< long long >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   long long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   long long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {long long}) long long *OUTPUT, long long &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_long_SS_long((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) long long *INOUT = long long *INPUT;
 %typemap(in) long long &INOUT = long long &INPUT;
 %typemap(typecheck) long long *INOUT = long long *INPUT;
 %typemap(typecheck) long long &INOUT = long long &INPUT;
 %typemap(argout) long long *INOUT = long long *OUTPUT;
 %typemap(argout) long long &INOUT = long long &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long (unsigned long long val, int ecode = 0) {
    ecode = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) unsigned long long "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) const unsigned long long & ($*ltype temp, unsigned long long val, int ecode = 0) {  
    ecode = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const unsigned long long& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long {
    unsigned long long val;
    int res = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long *DIRECTOROUT(unsigned long long swig_val, int swig_res) {
    swig_res = SWIG_AsVal_unsigned_SS_long_SS_long($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long {
    unsigned long long swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_long_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const unsigned long long& {  
    unsigned long long swig_val;
    int swig_res = SWIG_AsVal_unsigned_SS_long_SS_long($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const unsigned long long & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long &DIRECTOROUT = unsigned long long
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=60,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long, const unsigned long long& {
    int res = SWIG_AsVal_unsigned_SS_long_SS_long($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned long long val; 
      int ecode = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      unsigned long long val;
      int ecode = SWIG_AsVal_unsigned_SS_long_SS_long($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") unsigned long long *INPUT, unsigned long long &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=60,fragment="SWIG_" "AsVal" "_" {unsigned long long}) unsigned long long *INPUT, unsigned long long &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_unsigned_SS_long_SS_long($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long, const unsigned long long {
    $result = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) const unsigned long long& {
    $result = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long, const unsigned long long&  {
    $result = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long *DIRECTORIN {
    $input = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long, const unsigned long long& {
    $input = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long {
    SWIG_Python_Raise(SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   unsigned long long *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   unsigned long long &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {unsigned long long}) unsigned long long *OUTPUT, unsigned long long &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_unsigned_SS_long_SS_long((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) unsigned long long *INOUT = unsigned long long *INPUT;
 %typemap(in) unsigned long long &INOUT = unsigned long long &INPUT;
 %typemap(typecheck) unsigned long long *INOUT = unsigned long long *INPUT;
 %typemap(typecheck) unsigned long long &INOUT = unsigned long long &INPUT;
 %typemap(argout) unsigned long long *INOUT = unsigned long long *OUTPUT;
 %typemap(argout) unsigned long long &INOUT = unsigned long long &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float (float val, int ecode = 0) {
    ecode = SWIG_AsVal_float($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) float "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) const float & ($*ltype temp, float val, int ecode = 0) {  
    ecode = SWIG_AsVal_float($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const float& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {float}) float {
    float val;
    int res = SWIG_AsVal_float($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float *DIRECTOROUT(float swig_val, int swig_res) {
    swig_res = SWIG_AsVal_float($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float {
    float swig_val;
    int swig_res = SWIG_AsVal_float($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {float},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const float& {  
    float swig_val;
    int swig_res = SWIG_AsVal_float($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const float & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {float}) float &DIRECTOROUT = float
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=80,fragment="SWIG_" "AsVal" "_" {float}) float, const float& {
    int res = SWIG_AsVal_float($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      float val; 
      int ecode = SWIG_AsVal_float($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {float}) float &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      float val;
      int ecode = SWIG_AsVal_float($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") float *INPUT, float &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=80,fragment="SWIG_" "AsVal" "_" {float}) float *INPUT, float &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_float($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {float}) float, const float {
    $result = SWIG_From_float(static_cast< float >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {float}) const float& {
    $result = SWIG_From_float(static_cast< float >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {float}) float, const float&  {
    $result = SWIG_From_float(static_cast< float >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {float}) float {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_float(static_cast< float >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {float}) float *DIRECTORIN {
    $input = SWIG_From_float(static_cast< float >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {float}) float, const float& {
    $input = SWIG_From_float(static_cast< float >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {float}) float {
    SWIG_Python_Raise(SWIG_From_float(static_cast< float >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   float *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   float &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {float}) float *OUTPUT, float &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_float((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) float *INOUT = float *INPUT;
 %typemap(in) float &INOUT = float &INPUT;
 %typemap(typecheck) float *INOUT = float *INPUT;
 %typemap(typecheck) float &INOUT = float &INPUT;
 %typemap(argout) float *INOUT = float *OUTPUT;
 %typemap(argout) float &INOUT = float &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double (double val, int ecode = 0) {
    ecode = SWIG_AsVal_double($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) double "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) const double & ($*ltype temp, double val, int ecode = 0) {  
    ecode = SWIG_AsVal_double($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const double& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {double}) double {
    double val;
    int res = SWIG_AsVal_double($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double *DIRECTOROUT(double swig_val, int swig_res) {
    swig_res = SWIG_AsVal_double($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double {
    double swig_val;
    int swig_res = SWIG_AsVal_double($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {double},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const double& {  
    double swig_val;
    int swig_res = SWIG_AsVal_double($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const double & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {double}) double &DIRECTOROUT = double
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=90,fragment="SWIG_" "AsVal" "_" {double}) double, const double& {
    int res = SWIG_AsVal_double($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      double val; 
      int ecode = SWIG_AsVal_double($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {double}) double &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      double val;
      int ecode = SWIG_AsVal_double($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") double *INPUT, double &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=90,fragment="SWIG_" "AsVal" "_" {double}) double *INPUT, double &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_double($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {double}) double, const double {
    $result = SWIG_From_double(static_cast< double >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {double}) const double& {
    $result = SWIG_From_double(static_cast< double >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {double}) double, const double&  {
    $result = SWIG_From_double(static_cast< double >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {double}) double {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_double(static_cast< double >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {double}) double *DIRECTORIN {
    $input = SWIG_From_double(static_cast< double >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {double}) double, const double& {
    $input = SWIG_From_double(static_cast< double >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {double}) double {
    SWIG_Python_Raise(SWIG_From_double(static_cast< double >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   double *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   double &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {double}) double *OUTPUT, double &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_double((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) double *INOUT = double *INPUT;
 %typemap(in) double &INOUT = double &INPUT;
 %typemap(typecheck) double *INOUT = double *INPUT;
 %typemap(typecheck) double &INOUT = double &INPUT;
 %typemap(argout) double *INOUT = double *OUTPUT;
 %typemap(argout) double &INOUT = double &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char (char val, int ecode = 0) {
    ecode = SWIG_AsVal_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) char "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) const char & ($*ltype temp, char val, int ecode = 0) {  
    ecode = SWIG_AsVal_char($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const char& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {char}) char {
    char val;
    int res = SWIG_AsVal_char($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char *DIRECTOROUT(char swig_val, int swig_res) {
    swig_res = SWIG_AsVal_char($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char {
    char swig_val;
    int swig_res = SWIG_AsVal_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {char},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const char& {  
    char swig_val;
    int swig_res = SWIG_AsVal_char($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const char & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {char}) char &DIRECTOROUT = char
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=130,fragment="SWIG_" "AsVal" "_" {char}) char, const char& {
    int res = SWIG_AsVal_char($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      char val; 
      int ecode = SWIG_AsVal_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {char}) char &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      char val;
      int ecode = SWIG_AsVal_char($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") char *INPUT, char &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=130,fragment="SWIG_" "AsVal" "_" {char}) char *INPUT, char &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_char($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char {
    $result = SWIG_From_char(static_cast< char >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {char}) const char& {
    $result = SWIG_From_char(static_cast< char >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char&  {
    $result = SWIG_From_char(static_cast< char >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {char}) char {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_char(static_cast< char >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {char}) char *DIRECTORIN {
    $input = SWIG_From_char(static_cast< char >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {char}) char, const char& {
    $input = SWIG_From_char(static_cast< char >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {char}) char {
    SWIG_Python_Raise(SWIG_From_char(static_cast< char >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   char *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   char &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {char}) char *OUTPUT, char &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_char((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) char *INOUT = char *INPUT;
 %typemap(in) char &INOUT = char &INPUT;
 %typemap(typecheck) char *INOUT = char *INPUT;
 %typemap(typecheck) char &INOUT = char &INPUT;
 %typemap(argout) char *INOUT = char *OUTPUT;
 %typemap(argout) char &INOUT = char &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t (wchar_t val, int ecode = 0) {
    ecode = SWIG_AsVal_wchar_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) wchar_t "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) const wchar_t & ($*ltype temp, wchar_t val, int ecode = 0) {  
    ecode = SWIG_AsVal_wchar_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const wchar_t& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t {
    wchar_t val;
    int res = SWIG_AsVal_wchar_t($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t *DIRECTOROUT(wchar_t swig_val, int swig_res) {
    swig_res = SWIG_AsVal_wchar_t($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t {
    wchar_t swig_val;
    int swig_res = SWIG_AsVal_wchar_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const wchar_t& {  
    wchar_t swig_val;
    int swig_res = SWIG_AsVal_wchar_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const wchar_t & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t &DIRECTOROUT = wchar_t
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=110,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t, const wchar_t& {
    int res = SWIG_AsVal_wchar_t($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      wchar_t val; 
      int ecode = SWIG_AsVal_wchar_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      wchar_t val;
      int ecode = SWIG_AsVal_wchar_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") wchar_t *INPUT, wchar_t &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=110,fragment="SWIG_" "AsVal" "_" {wchar_t}) wchar_t *INPUT, wchar_t &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_wchar_t($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t, const wchar_t {
    $result = SWIG_From_wchar_t(static_cast< wchar_t >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) const wchar_t& {
    $result = SWIG_From_wchar_t(static_cast< wchar_t >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t, const wchar_t&  {
    $result = SWIG_From_wchar_t(static_cast< wchar_t >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_wchar_t(static_cast< wchar_t >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t *DIRECTORIN {
    $input = SWIG_From_wchar_t(static_cast< wchar_t >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t, const wchar_t& {
    $input = SWIG_From_wchar_t(static_cast< wchar_t >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t {
    SWIG_Python_Raise(SWIG_From_wchar_t(static_cast< wchar_t >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   wchar_t *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   wchar_t &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {wchar_t}) wchar_t *OUTPUT, wchar_t &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_wchar_t((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) wchar_t *INOUT = wchar_t *INPUT;
 %typemap(in) wchar_t &INOUT = wchar_t &INPUT;
 %typemap(typecheck) wchar_t *INOUT = wchar_t *INPUT;
 %typemap(typecheck) wchar_t &INOUT = wchar_t &INPUT;
 %typemap(argout) wchar_t *INOUT = wchar_t *OUTPUT;
 %typemap(argout) wchar_t &INOUT = wchar_t &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t (size_t val, int ecode = 0) {
    ecode = SWIG_AsVal_size_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) size_t "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) const size_t & ($*ltype temp, size_t val, int ecode = 0) {  
    ecode = SWIG_AsVal_size_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const size_t& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {size_t}) size_t {
    size_t val;
    int res = SWIG_AsVal_size_t($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t *DIRECTOROUT(size_t swig_val, int swig_res) {
    swig_res = SWIG_AsVal_size_t($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t {
    size_t swig_val;
    int swig_res = SWIG_AsVal_size_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const size_t& {  
    size_t swig_val;
    int swig_res = SWIG_AsVal_size_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const size_t & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {size_t}) size_t &DIRECTOROUT = size_t
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=47,fragment="SWIG_" "AsVal" "_" {size_t}) size_t, const size_t& {
    int res = SWIG_AsVal_size_t($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      size_t val; 
      int ecode = SWIG_AsVal_size_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {size_t}) size_t &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      size_t val;
      int ecode = SWIG_AsVal_size_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") size_t *INPUT, size_t &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=47,fragment="SWIG_" "AsVal" "_" {size_t}) size_t *INPUT, size_t &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_size_t($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t, const size_t {
    $result = SWIG_From_size_t(static_cast< size_t >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {size_t}) const size_t& {
    $result = SWIG_From_size_t(static_cast< size_t >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t, const size_t&  {
    $result = SWIG_From_size_t(static_cast< size_t >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_size_t(static_cast< size_t >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t *DIRECTORIN {
    $input = SWIG_From_size_t(static_cast< size_t >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t, const size_t& {
    $input = SWIG_From_size_t(static_cast< size_t >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t {
    SWIG_Python_Raise(SWIG_From_size_t(static_cast< size_t >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   size_t *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   size_t &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {size_t}) size_t *OUTPUT, size_t &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_size_t((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) size_t *INOUT = size_t *INPUT;
 %typemap(in) size_t &INOUT = size_t &INPUT;
 %typemap(typecheck) size_t *INOUT = size_t *INPUT;
 %typemap(typecheck) size_t &INOUT = size_t &INPUT;
 %typemap(argout) size_t *INOUT = size_t *OUTPUT;
 %typemap(argout) size_t &INOUT = size_t &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t (ptrdiff_t val, int ecode = 0) {
    ecode = SWIG_AsVal_ptrdiff_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) ptrdiff_t "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) const ptrdiff_t & ($*ltype temp, ptrdiff_t val, int ecode = 0) {  
    ecode = SWIG_AsVal_ptrdiff_t($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const ptrdiff_t& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t {
    ptrdiff_t val;
    int res = SWIG_AsVal_ptrdiff_t($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t *DIRECTOROUT(ptrdiff_t swig_val, int swig_res) {
    swig_res = SWIG_AsVal_ptrdiff_t($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t {
    ptrdiff_t swig_val;
    int swig_res = SWIG_AsVal_ptrdiff_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const ptrdiff_t& {  
    ptrdiff_t swig_val;
    int swig_res = SWIG_AsVal_ptrdiff_t($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const ptrdiff_t & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t &DIRECTOROUT = ptrdiff_t
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=48,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t& {
    int res = SWIG_AsVal_ptrdiff_t($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      ptrdiff_t val; 
      int ecode = SWIG_AsVal_ptrdiff_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      ptrdiff_t val;
      int ecode = SWIG_AsVal_ptrdiff_t($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") ptrdiff_t *INPUT, ptrdiff_t &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=48,fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) ptrdiff_t *INPUT, ptrdiff_t &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_ptrdiff_t($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t {
    $result = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) const ptrdiff_t& {
    $result = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t&  {
    $result = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t *DIRECTORIN {
    $input = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t, const ptrdiff_t& {
    $input = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t {
    SWIG_Python_Raise(SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   ptrdiff_t *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   ptrdiff_t &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {ptrdiff_t}) ptrdiff_t *OUTPUT, ptrdiff_t &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_ptrdiff_t((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) ptrdiff_t *INOUT = ptrdiff_t *INPUT;
 %typemap(in) ptrdiff_t &INOUT = ptrdiff_t &INPUT;
 %typemap(typecheck) ptrdiff_t *INOUT = ptrdiff_t *INPUT;
 %typemap(typecheck) ptrdiff_t &INOUT = ptrdiff_t &INPUT;
 %typemap(argout) ptrdiff_t *INOUT = ptrdiff_t *OUTPUT;
 %typemap(argout) ptrdiff_t &INOUT = ptrdiff_t &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG@*/;

%endoffile
%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/string.swg" %beginfile
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,222,%ensure_fragment@*/
%fragment("SWIG_AsCharPtrAndSize","header") {
#error "SWIG language implementation must provide the SWIG_AsCharPtrAndSize fragment"
}
/*@SWIG@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/fragments.swg,222,%ensure_fragment@*/
%fragment("SWIG_FromCharPtrAndSize","header") {
#error "SWIG language implementation must provide the SWIG_FromCharPtrAndSize fragment"
}
/*@SWIG@*/

%types(char *);

%fragment("SWIG_pchar_descriptor","header") {
SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}
}

%fragment("SWIG_strnlen","header",fragment="SWIG_FromCharPtrAndSize") {
SWIGINTERN size_t
SWIG_strnlen(const char* s, size_t maxlen)
{
  const char *p;
  for (p = s; maxlen-- && *p; p++)
    ;
  return p - s;
}
}

%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/strings.swg" %beginfile
//
// Use the macro SWIG_PRESERVE_CARRAY_SIZE if you prefer to preserve
// the size of char arrays, ie
//  ------------------------------------------
//       C Side             =>   Language Side
//  ------------------------------------------
//   char name[5] = "hola"  =>   'hola\0'
//
// the default behaviour is 
//
//   char name[5] = "hola"  =>   'hola'
//
//
//#define SWIG_PRESERVE_CARRAY_SIZE

/* ------------------------------------------------------------
 *  String typemaps for type Char (char or wchar_t)
 * ------------------------------------------------------------ */































































































































































































































































































































































































































































































/* ------------------------------------------------------------
 * --- String fragment methods ---
 * ------------------------------------------------------------ */










































































































/* ------------------------------------------------------------
 *  String typemaps and fragments, with default allocators
 * ------------------------------------------------------------ */



















/* ------------------------------------------------------------
 *  String typemaps and fragments, with custom allocators
 * ------------------------------------------------------------ */




















%endoffile
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/strings.swg,611,%typemaps_string@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/strings.swg,503,%_typemap2_string@*/
  
%fragment("SWIG_From""Char""Ptr","header",fragment="SWIG_FromCharPtrAndSize") {
SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}
}

%fragment("SWIG_From""Char""Array","header",fragment="SWIG_FromCharPtrAndSize") {
SWIGINTERNINLINE PyObject * 
SWIG_FromCharArray(const char *cptr, size_t size)
{ 
  return SWIG_FromCharPtrAndSize(cptr, size);
}
}

%fragment("SWIG_As""Char" "Ptr","header",fragment="SWIG_AsCharPtrAndSize") {

}

%fragment("SWIG_As""Char" "Array","header",fragment="SWIG_AsCharPtrAndSize") {
SWIGINTERN int
SWIG_AsCharArray(PyObject * obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    /* special case of single char conversion when we don't need space for NUL */
    if (size == 1 && csize == 2 && cptr && !cptr[1]) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}
}

/* char */

%fragment("SWIG_" "From" "_" {char},"header",fragment="SWIG_FromCharPtrAndSize") {
SWIGINTERNINLINE PyObject *
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}
}

%fragment("SWIG_" "AsVal" "_" {char},"header",
	  fragment="SWIG_As""Char""Array",
	  fragment="<limits.h>",
	  fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERN int
SWIG_AsVal_char (PyObject * obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}
}

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/strings.swg,20,%_typemap_string@*/

/* in */

%typemap(in,noblock=1,fragment="SWIG_AsCharPtr") 
  char * (int res, char *buf = 0, int alloc = 0),
  const char * (int res, char *buf = 0, int alloc = 0) {
  res = SWIG_AsCharPtrAndSize($input, &buf, NULL, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = reinterpret_cast< $1_ltype >(buf);
}
%typemap(freearg,noblock=1,match="in") char *, const char * {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}

%typemap(in,noblock=1,fragment="SWIG_AsCharPtr") char const*& (int res, char *buf = 0, int alloc = 0) {
  res = SWIG_AsCharPtrAndSize($input, &buf, NULL, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = &buf;
}    
%typemap(freearg, noblock=1,match="in") char const*& {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}

/* out */

%typemap(out,noblock=1,fragment="SWIG_FromCharPtr") char *, const char * {
  $result = SWIG_FromCharPtr((const char *)$1);
}


%typemap(out,noblock=1,fragment="SWIG_FromCharPtr") char const*& {
  $result = SWIG_FromCharPtr(*$1);
}

%typemap(newfree,noblock=1) char * {
  delete[] $1;
}

/* varin */

%typemap(varin,fragment="SWIG_AsCharPtrAndSize") char * {
  char *cptr = 0; size_t csize = 0; int alloc = SWIG_NEWOBJ;
  int res = SWIG_AsCharPtrAndSize($input, &cptr, &csize, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if ($1) delete[] $1;
  if (alloc == SWIG_NEWOBJ) {
    $1 = cptr;
  } else {
    $1 = csize ? ($1_type)reinterpret_cast< char* >(memcpy(new char[csize], cptr, sizeof(char)*(csize))) : 0;
  }
}

%typemap(varin,fragment="SWIG_AsCharPtrAndSize",warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  char *cptr = 0; size_t csize = 0; int alloc = SWIG_NEWOBJ;
  int res = SWIG_AsCharPtrAndSize($input, &cptr, &csize, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
  if (alloc == SWIG_NEWOBJ) {
    $1 = cptr;
  } else {
    $1 = csize ? ($1_type)reinterpret_cast< char* >(memcpy(new char[csize], cptr, sizeof(char)*(csize))) : 0;
  }
}

/* varout */

%typemap(varout,noblock=1,fragment="SWIG_FromCharPtr") char *, const char * {
  $result = SWIG_FromCharPtr($1);
}

/* memberin */

%typemap(memberin,noblock=1) char * {
  if ($1) delete[] $1;
  if ($input) {
    size_t size = strlen(reinterpret_cast< const char * >($input)) + 1;
    $1 = ($1_type)reinterpret_cast< char* >(memcpy(new char[size], reinterpret_cast< const char * >($input), sizeof(char)*(size)));
  } else {
    $1 = 0;
  }
}

%typemap(memberin,noblock=1,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  if ($input) {
    size_t size = strlen(reinterpret_cast< const char * >(reinterpret_cast< const char * >($input))) + 1;
    $1 = ($1_type)reinterpret_cast< char* >(memcpy(new char[size], $input, sizeof(char)*(size)));
  } else {
    $1 = 0;
  }
}

/* globalin */

%typemap(globalin,noblock=1) char * {
  if ($1) delete[] $1;
  if ($input) {
    size_t size = strlen(reinterpret_cast< const char * >(reinterpret_cast< const char * >($input))) + 1;
    $1 = ($1_type)reinterpret_cast< char* >(memcpy(new char[size], $input, sizeof(char)*(size)));
  } else {
    $1 = 0;
  }
}

%typemap(globalin,noblock=1,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  if ($input) {
    size_t size = strlen($input) + 1;
    $1 = ($1_type)reinterpret_cast< char* >(memcpy(new char[size], $input, sizeof(char)*(size)));
  } else {
    $1 = 0;
  }
}

/* constant */

%typemap(constcode,noblock=1,fragment="SWIG_FromCharPtr")
  char *, char const*, char * const, char const* const {
  SWIG_Python_SetConstant(d, "$symname",SWIG_FromCharPtr($value));
}




/* directorin */

%typemap(directorin,noblock=1,fragment="SWIG_FromCharPtr")
  char *, char const*, char *const, char const *const, 
  char const *&, char *const &, char const *const & {
  $input = SWIG_FromCharPtr((const char *)$1);
}


/* directorout */

%typemap(directorout,noblock=1,fragment="SWIG_AsCharPtr",warning= "473:Returning a pointer or reference in a director method is not recommended." ) char * (int res, char *buf = 0, int alloc = SWIG_NEWOBJ) {
  res = SWIG_AsCharPtrAndSize($input, &buf, NULL, &alloc);
  if (!SWIG_IsOK(res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
  }
  if (alloc == SWIG_NEWOBJ) {
    swig_acquire_ownership_array(buf);
  }
  $result = reinterpret_cast< $1_ltype >(buf);
}
%typemap(directorfree,noblock=1) char *
{
  if (director) {
    director->swig_release_ownership(SWIG_as_voidptr($input));
  }
}


%typemap(directorout,noblock=1,fragment="SWIG_AsCharPtr",warning= "473:Returning a pointer or reference in a director method is not recommended." ) char *const& (int res, char *buf = 0, int alloc = SWIG_NEWOBJ), char const*const& (int res, char *buf = 0, int alloc = SWIG_NEWOBJ) { 
  res = SWIG_AsCharPtrAndSize($input, &buf, NULL, &alloc);
  if (!SWIG_IsOK(res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
  }
  static $*1_ltype tmp = buf;
  $result = &tmp;
  if (alloc == SWIG_NEWOBJ) {
    swig_acquire_ownership_array(buf);
  }
}
%typemap(directorfree,noblock=1)
  char * const&, char const* const& {
  if (director) {
    director->swig_release_ownership(SWIG_as_voidptr(*$input));
  }
}



/* typecheck */

%typemap(typecheck,noblock=1,precedence=140,
	 fragment="SWIG_AsCharPtr") char *, const char *, char const*& {
  int res = SWIG_AsCharPtrAndSize($input, 0, NULL, 0);
  $1 = SWIG_CheckState(res);
}


/* throws */

%typemap(throws,noblock=1,fragment="SWIG_FromCharPtr") char * {
  SWIG_Python_Raise(SWIG_FromCharPtr($1), "$type", 0); SWIG_fail;
}


/* ------------------------------------------------------------
 *  Unknown size const Character array char[ANY] handling
 * ------------------------------------------------------------ */

%apply char * { char [] };
%apply const char * { const char [] };

%typemap(varin,noblock=1,warning="462:Unable to set variable of type char []") char []
{
  SWIG_exception_fail(SWIG_ArgError(SWIG_AttributeError), "in variable '""read-only $name""' of type '""$type""'");
}


/* ------------------------------------------------------------
 *  Fixed size Character array char[ANY] handling
 * ------------------------------------------------------------ */

/*  memberin and globalin typemaps  */

%typemap(memberin,noblock=1) char [ANY]
{
  if ($input) memcpy($1,$input,$1_dim0*sizeof(char));
  else memset($1,0,$1_dim0*sizeof(char));
}

%typemap(globalin,noblock=1) char [ANY]
{
  if ($input) memcpy($1,$input,$1_dim0*sizeof(char));
  else memset($1,0,$1_dim0*sizeof(char));
}

/* in */

%typemap(in,noblock=1,fragment="SWIG_AsCharArray")
  char [ANY] (char temp[$1_dim0], int res), 
  const char [ANY](char temp[$1_dim0], int res)
{  
  res = SWIG_AsCharArray($input, temp, $1_dim0);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = reinterpret_cast< $1_ltype >(temp);
}
%typemap(freearg) char [ANY], const char [ANY] "";

%typemap(in,noblock=1,fragment="SWIG_AsCharArray") const char (&)[ANY] (char temp[$1_dim0], int res)
{  
  res = SWIG_AsCharArray($input, temp, $1_dim0);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = &temp;
}
%typemap(freearg) const char (&)[ANY] "";

%typemap(out,fragment="SWIG_FromCharPtrAndSize",fragment="SWIG_strnlen")
  char [ANY], const char[ANY] 
{

  size_t size = SWIG_strnlen($1, $1_dim0);



   $result = SWIG_FromCharPtrAndSize($1, size);
}

/* varin */

%typemap(varin,fragment="SWIG_AsCharArray") char [ANY]
{
  int res = SWIG_AsCharArray($input, $1, $1_dim0);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
  }
}

/* varout */

%typemap(varout,fragment="SWIG_strnlen")
  char [ANY], const char [ANY] {

  size_t size = SWIG_strnlen($1, $1_dim0);



  $result = SWIG_FromCharPtrAndSize($1, size);
}

/* constant */

%typemap(constcode,fragment="SWIG_strnlen")
  char [ANY], const char [ANY]
{

  size_t size = SWIG_strnlen($1, $1_dim0);



  SWIG_Python_SetConstant(d, "$symname",SWIG_FromCharPtrAndSize($value,size));
}




/* directorin */
%typemap(directorin,fragment="SWIG_strnlen")
  char [ANY], const char [ANY] 
{

  size_t size = SWIG_strnlen($1, $1_dim0);



  $input = SWIG_FromCharPtrAndSize($1, size);
}

/* directorout */

%typemap(directorout,noblock=1,fragment="SWIG_AsCharArray")
  char [ANY] (char temp[$result_dim0]),
  const char [ANY] (char temp[$result_dim0], int res)
{ 
  res = SWIG_AsCharArray($input, temp, $result_dim0);
  if (!SWIG_IsOK(res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(res)), "in output value of type '""$type""'");
  }
  $result = temp;
}



/* typecheck */

%typemap(typecheck,noblock=1,precedence=140,
	 fragment="SWIG_AsCharArray")  
  char [ANY], const char[ANY] {
  int res = SWIG_AsCharArray($input, (char *)0, $1_dim0);
  $1 = SWIG_CheckState(res);
}


/* throws */

%typemap(throws,fragment="SWIG_strnlen")
  char [ANY], const char[ANY]
{

  size_t size = SWIG_strnlen($1, $1_dim0);



  SWIG_Python_Raise(SWIG_FromCharPtrAndSize($1, size), "$type", 0); SWIG_fail; 
}

/* -------------------------------------------------------------------
 * --- Really fix size char arrays, including '\0'chars at the end ---
 * ------------------------------------------------------------------- */

%typemap(varout,noblock=1,fragment="SWIG_FromCharPtrAndSize")
  char FIXSIZE[ANY], const char FIXSIZE[ANY]
{
  $result = SWIG_FromCharPtrAndSize($1, $1_dim0);
}

%typemap(out,noblock=1,fragment="SWIG_FromCharPtrAndSize")
  char FIXSIZE[ANY], const char FIXSIZE[ANY]
{
  $result = SWIG_FromCharPtrAndSize($1, $1_dim0);
}



%typemap(directorin,noblock=1,fragment="SWIG_FromCharPtrAndSize")
  char FIXSIZE[ANY], const char FIXSIZE[ANY]
{
  $input = SWIG_FromCharPtrAndSize($1, $1_dim0);
}



%typemap(throws,noblock=1,fragment="SWIG_FromCharPtrAndSize")
  char FIXSIZE[ANY], const char FIXSIZE[ANY] {
  SWIG_Python_Raise(SWIG_FromCharPtrAndSize($1, $1_dim0), "$type", 0); SWIG_fail; 
}

/* ------------------------------------------------------------
 * --- String & length ---
 * ------------------------------------------------------------ */

/* Here len doesn't include the '0' terminator */
%typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize") 
  (char *STRING, size_t LENGTH) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
  (const char *STRING, size_t LENGTH) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }  
  $1 = reinterpret_cast< $1_ltype >(buf);
  $2 = static_cast< $2_ltype >(size - 1);
}
%typemap(freearg,noblock=1,match="in") (char *STRING, size_t LENGTH) {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}
/* old 'int' form */
%typemap(in) (char *STRING, int LENGTH) = (char *STRING, size_t LENGTH);
%typemap(freearg) (char *STRING, int LENGTH) = (char *STRING, size_t LENGTH);


/* Here size includes the '0' terminator */
%typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize")
  (char *STRING, size_t SIZE) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
  (const char *STRING, size_t SIZE) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $1 = reinterpret_cast< $1_ltype >(buf);
  $2 = static_cast< $2_ltype >(size);
}
%typemap(freearg,noblock=1,match="in") (char *STRING, size_t SIZE) {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}
/* old 'int' form */
%typemap(in) (char *STRING, int SIZE) = (char *STRING, size_t SIZE);
%typemap(freearg) (char *STRING, int SIZE) = (char *STRING, size_t SIZE);


/* reverse order versions */

/* Here len doesn't include the '0' terminator */
%typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize") 
  (size_t LENGTH, char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
  (size_t LENGTH, const char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
  if (!SWIG_IsOK(res)) { 
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }  
  $2 = reinterpret_cast< $2_ltype >(buf) ;
  $1 = static_cast< $1_ltype >(size - 1) ;
}
%typemap(freearg, noblock=1, match="in") (size_t LENGTH, char *STRING) {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}
/* old 'int' form */
%typemap(in) (int LENGTH, char *STRING) = (size_t LENGTH, char *STRING);
%typemap(freearg) (int LENGTH, char *STRING) = (size_t LENGTH, char *STRING);

/* Here size includes the '0' terminator */
%typemap(in,noblock=1,fragment="SWIG_AsCharPtrAndSize")
  (size_t SIZE, char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0),
  (size_t SIZE, const char *STRING) (int res, char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  }
  $2 = reinterpret_cast< $2_ltype >(buf) ;
  $1 = static_cast< $1_ltype >(size) ;
}
%typemap(freearg, noblock=1, match="in") (size_t SIZE, char *STRING) {
  if (alloc$argnum == SWIG_NEWOBJ) delete[] buf$argnum;
}
/* old 'int' form */
%typemap(in) (int SIZE, char *STRING) = (size_t SIZE, char *STRING);
%typemap(freearg) (int SIZE, char *STRING) = (size_t SIZE, char *STRING);


/*@SWIG@*/











/*@SWIG@*/








/*@SWIG@*/



%endoffile
%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/misctypes.swg" %beginfile

/* ------------------------------------------------------------
 * --- ANSI/Posix C/C++ types ---
 * ------------------------------------------------------------ */




%apply size_t { std::size_t };
%apply const size_t& { const std::size_t& };

%apply ptrdiff_t { std::ptrdiff_t };
%apply const ptrdiff_t& { const std::ptrdiff_t& };


%apply size_t& { std::size_t& };
%apply ptrdiff_t& { std::ptrdiff_t& };




%endoffile
%includefile "/home/balos1/.local/share/swig/4.0.0/typemaps/enumint.swg" %beginfile
/* ------------------------------------------------------------
 *  Enums mapped as integer values
 * ------------------------------------------------------------ */

%apply int { enum SWIGTYPE };
%apply const int& { const enum SWIGTYPE & };
%apply const int& { const enum SWIGTYPE && };

%typemap(in,fragment="SWIG_" "AsVal" "_" {int},noblock=1) const enum SWIGTYPE & (int val, int ecode, $basetype temp) {  
  ecode = SWIG_AsVal_int ($input, &val);
  if (!SWIG_IsOK(ecode)) {
    SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  } else {
    temp = static_cast< $basetype >(val);
    $1 = &temp;
  }
}

%typemap(in,fragment="SWIG_" "AsVal" "_" {int},noblock=1) const enum SWIGTYPE && (int val, int ecode, $basetype temp) {  
  ecode = SWIG_AsVal_int ($input, &val);
  if (!SWIG_IsOK(ecode)) {
    SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$type""'");
  } else {
    temp = static_cast< $basetype >(val);
    $1 = &temp;
  }
}

%typemap(varin,fragment="SWIG_" "AsVal" "_" {int},noblock=1) enum SWIGTYPE {
  if (sizeof(int) != sizeof($1)) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_AttributeError), "in variable '""arch, read-only $name""' of type '""$type""'");
  }  else {
    int ecode = SWIG_AsVal_int ($input, reinterpret_cast< int* >(&$1));
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in variable '""$name""' of type '""$type""'");
    }
  }
}

%endoffile


%endoffile


/*  ------------------------------------------------------------
 *  Python extra typemaps / typemap overrides
 * ------------------------------------------------------------ */

/* Get the address of the 'python self' object */

%typemap(in,numinputs=0,noblock=1) PyObject **PYTHON_SELF {
  $1 = &$self;
}


/* Consttab, needed for callbacks, it should be removed later */

%typemap(consttab) SWIGTYPE ((*)(ANY))
{ SWIG_PY_POINTER, "$symname", 0, 0, (void *)($value), &$descriptor }
%typemap(consttab) SWIGTYPE ((* const)(ANY)) = SWIGTYPE ((*)(ANY));

%typemap(constcode) SWIGTYPE ((*)(ANY)) "";
%typemap(constcode) SWIGTYPE ((* const)(ANY)) = SWIGTYPE ((*)(ANY));


/* Smart Pointers */
%typemap(out,noblock=1) const SWIGTYPE & SMARTPOINTER  {
  $result = SWIG_NewPointerObj((new $*ltype(static_cast< const $*ltype& >(*$1))), $descriptor, SWIG_POINTER_OWN |  0 );
}

%typemap(ret,noblock=1) const SWIGTYPE & SMARTPOINTER, SWIGTYPE SMARTPOINTER {
  if ($result) {
    PyObject *robj = PyObject_CallMethod($result, (char *)"__deref__", NULL);
    if (robj && !PyErr_Occurred()) {
      SwigPyObject_append((PyObject *) SWIG_Python_GetSwigThis($result), 
			  (PyObject *) SWIG_Python_GetSwigThis(robj));
      Py_DECREF(robj);
    }
  }
}

%endoffile

/* ------------------------------------------------------------
 *  Overloaded operator support
 * ------------------------------------------------------------ */
%includefile "/home/balos1/.local/share/swig/4.0.0/python/pyopers.swg" %beginfile
/* ------------------------------------------------------------
 * Overloaded operator support

 The directives in this file apply whether or not you use the
 -builtin option to SWIG, but operator overloads are particularly
 attractive when using -builtin, because they are much faster
 than named methods.

 If you're using the -builtin option to SWIG, and you want to define
 python operator overloads beyond the defaults defined in this file,
 here's what you need to know:

 There are two ways to define a python slot function: dispatch to a
 statically defined function; or dispatch to a method defined on the
 operand.

 To dispatch to a statically defined function, use %feature("python:<slot>"),
 where <slot> is the name of a field in a PyTypeObject, PyNumberMethods,
 PyMappingMethods, PySequenceMethods, or PyBufferProcs.  For example:

   %feature("python:tp_hash") MyClass "myHashFunc";

   class MyClass {
     public:
       ...
   };

   %{
     // Note: Py_hash_t was introduced in Python 3.2
     static Py_hash_t myHashFunc(PyObject *pyobj) {
       MyClass *cobj;
       // Convert pyobj to cobj
       return (cobj->field1 * (cobj->field2 << 7));
     }
   %}

 NOTE: It is the responsibility of the programmer (that's you) to ensure
 that a statically defined slot function has the correct signature.

 If, instead, you want to dispatch to an instance method, you can
 use %feature("python:slot").  For example:

   %feature("python:slot", "tp_hash", functype="hashfunc") MyClass::myHashFunc;

   class MyClass {
     public:
       Py_hash_t myHashFunc () const;
       ...
   };

 NOTE: Some python slots use a method signature which does not
 match the signature of SWIG-wrapped methods.  For those slots,
 SWIG will automatically generate a "closure" function to re-marshall
 the arguments before dispatching to the wrapped method.  Setting
 the "functype" attribute of the feature enables SWIG to generate
 a correct closure function.

 --------------------------------------------------------------

 The tp_richcompare slot is a special case: SWIG automatically generates
 a rich compare function for all wrapped types.  If a type defines C++
 operator overloads for comparison (operator==, operator<, etc.), they
 will be called from the generated rich compare function.  If you
 want to explicitly choose a method to handle a certain comparison
 operation, you may use a different feature, %feature("python:compare")
 like this:

   %feature("python:compare", "Py_LT") MyClass::lessThan;

   class MyClass {
     public:
       bool lessThan(const MyClass& other) const;
       ...
   };
   
 ... where "Py_LT" is one of the rich comparison opcodes defined in the
 python header file object.h.

 If there's no method defined to handle a particular comparison operation,
 the default behavior is to compare pointer values of the wrapped
 C++ objects.

 --------------------------------------------------------------


 For more information about python slots, including their names and
 signatures, you may refer to the python documentation :

   http://docs.python.org/c-api/typeobj.html

 * ------------------------------------------------------------ */












%rename(__add__) *::operator+; %feature("python:maybecall", "1") *::operator+;
%rename(__pos__) *::operator+(); %feature("python:maybecall", "1") *::operator+();
%rename(__pos__) *::operator+() const; %feature("python:maybecall", "1") *::operator+() const;
%rename(__sub__) *::operator-; %feature("python:maybecall", "1") *::operator-;
%rename(__neg__) *::operator-(); %feature("python:maybecall", "1") *::operator-();
%rename(__neg__) *::operator-() const; %feature("python:maybecall", "1") *::operator-() const;
%rename(__mul__) *::operator*; %feature("python:maybecall", "1") *::operator*;
%rename(__mod__) *::operator%; %feature("python:maybecall", "1") *::operator%;
%rename(__lshift__) *::operator<<; %feature("python:maybecall", "1") *::operator<<;
%rename(__rshift__) *::operator>>; %feature("python:maybecall", "1") *::operator>>;
%rename(__and__) *::operator&; %feature("python:maybecall", "1") *::operator&;
%rename(__or__) *::operator|; %feature("python:maybecall", "1") *::operator|;
%rename(__xor__) *::operator^; %feature("python:maybecall", "1") *::operator^;
%rename(__lt__) *::operator<; %feature("python:maybecall", "1") *::operator<;
%rename(__le__) *::operator<=; %feature("python:maybecall", "1") *::operator<=;
%rename(__gt__) *::operator>; %feature("python:maybecall", "1") *::operator>;
%rename(__ge__) *::operator>=; %feature("python:maybecall", "1") *::operator>=;
%rename(__eq__) *::operator==; %feature("python:maybecall", "1") *::operator==;
%rename(__ne__) *::operator!=; %feature("python:maybecall", "1") *::operator!=;

/* Special cases */
%rename(__invert__)     *::operator~;
%feature("python:slot", "nb_invert", functype="unaryfunc") *::operator~;
%rename(__call__)       *::operator();
%feature("python:slot", "tp_call", functype="ternarycallfunc") *::operator();





%feature("shadow")      *::operator bool %{
def __nonzero__(self):
    return $action(self)
__bool__ = __nonzero__
%};
%rename(__nonzero__)    *::operator bool;
%feature("shadow")      *::operator/ %{
def __truediv__(self, *args):
    return $action(self, *args)
__div__ = __truediv__
%};
%rename(__truediv__)    *::operator/;
%feature("python:maybecall", "1")        *::operator/;


/* Ignored operators */
%rename("$ignore:"       "361:operator! ignored"  )       operator!;
%rename("$ignore:"       "381:operator&& ignored"  )       operator&&;
%rename("$ignore:"        "382:operator|| ignored"  )        operator||;
%rename("$ignore:"         "362:operator= ignored"  )         *::operator=;
%rename("$ignore:"   "383:operator++ ignored"  )   *::operator++;
%rename("$ignore:" "384:operator-- ignored"  ) *::operator--;
%rename("$ignore:"  "386:operator->* ignored"  )  *::operator->*;
%rename("$ignore:"      "389:operator[] ignored (consider using %%extend)"  )      *::operator[];

/*
  Inplace operator declarations.

  They translate the inplace C++ operators (+=, -=, ...)  into the
  corresponding python equivalents(__iadd__,__isub__), etc,
  disabling the ownership of the input 'this' pointer, and assigning
  it to the returning object:  

     %feature("del") *::Operator; // disables ownership by generating SWIG_POINTER_DISOWN
     %feature("new") *::Operator; // claims ownership by generating SWIG_POINTER_OWN
  
  This makes the most common case safe, ie:

     A&  A::operator+=(int i) { ...; return *this; }
    ^^^^                                    ^^^^^^

  will work fine, even when the resulting python object shares the
  'this' pointer with the input one. The input object is usually
  deleted after the operation, including the shared 'this' pointer,
  producing 'strange' seg faults, as reported by Lucriz
  (lucriz@sitilandia.it).

  If you have an interface that already takes care of that, ie, you
  already are using inplace operators and you are not getting
  seg. faults, with the new scheme you could end with 'free' elements
  that never get deleted (maybe, not sure, it depends). But if that is
  the case, you could recover the old behaviour using

     %feature("del","0") A::operator+=;
     %feature("new","0") A::operator+=;

  which recovers the old behaviour for the class 'A', or if you are
  100% sure your entire system works fine in the old way, use:

    %feature("del","") *::operator+=;
    %feature("new","") *::operator+=;

  The default behaviour assumes that the 'this' pointer's memory is
  already owned by the SWIG object; it relinquishes ownership then
  takes it back. This may not be the case though as the SWIG object
  might be owned by memory managed elsewhere, eg after calling a
  function that returns a C++ reference. In such case you will need
  to use the features above to recover the old behaviour too.
*/







%feature("del") *::operator +=; %feature("new") *::operator +=; %rename(__iadd__) *::operator +=;
%feature("del") *::operator -=; %feature("new") *::operator -=; %rename(__isub__) *::operator -=;
%feature("del") *::operator *=; %feature("new") *::operator *=; %rename(__imul__) *::operator *=;
%feature("del") *::operator %=; %feature("new") *::operator %=; %rename(__imod__) *::operator %=;
%feature("del") *::operator &=; %feature("new") *::operator &=; %rename(__iand__) *::operator &=;
%feature("del") *::operator |=; %feature("new") *::operator |=; %rename(__ior__) *::operator |=;
%feature("del") *::operator ^=; %feature("new") *::operator ^=; %rename(__ixor__) *::operator ^=;
%feature("del") *::operator <<=; %feature("new") *::operator <<=; %rename(__ilshift__) *::operator <<=;
%feature("del") *::operator >>=; %feature("new") *::operator >>=; %rename(__irshift__) *::operator >>=;

/* Special cases */



%feature("del") *::operator /=;
%feature("new") *::operator /=;
%feature("shadow")      *::operator /= %{
def __itruediv__(self, *args):
    return $action(self, *args)
__idiv__ = __itruediv__
%};
%rename(__itruediv__)    *::operator /=;


/* Finally, in python we need to mark the binary operations to fail as
 'maybecall' methods */



%feature("python:maybecall", "1") __add__;  %feature("python:maybecall", "1") __radd__;
%feature("python:maybecall", "1") __pos__;  %feature("python:maybecall", "1") __rpos__;
%feature("python:maybecall", "1") __pos__;  %feature("python:maybecall", "1") __rpos__;
%feature("python:maybecall", "1") __sub__;  %feature("python:maybecall", "1") __rsub__;
%feature("python:maybecall", "1") __neg__;  %feature("python:maybecall", "1") __rneg__;
%feature("python:maybecall", "1") __neg__;  %feature("python:maybecall", "1") __rneg__;
%feature("python:maybecall", "1") __mul__;  %feature("python:maybecall", "1") __rmul__;
%feature("python:maybecall", "1") __div__;  %feature("python:maybecall", "1") __rdiv__;
%feature("python:maybecall", "1") __truediv__;  %feature("python:maybecall", "1") __rtruediv__;
%feature("python:maybecall", "1") __mod__;  %feature("python:maybecall", "1") __rmod__;
%feature("python:maybecall", "1") __lshift__;  %feature("python:maybecall", "1") __rlshift__;
%feature("python:maybecall", "1") __rshift__;  %feature("python:maybecall", "1") __rrshift__;
%feature("python:maybecall", "1") __and__;  %feature("python:maybecall", "1") __rand__;
%feature("python:maybecall", "1") __or__;  %feature("python:maybecall", "1") __ror__;
%feature("python:maybecall", "1") __xor__;  %feature("python:maybecall", "1") __rxor__;
%feature("python:maybecall", "1") __lt__;  %feature("python:maybecall", "1") __rlt__;
%feature("python:maybecall", "1") __le__;  %feature("python:maybecall", "1") __rle__;
%feature("python:maybecall", "1") __gt__;  %feature("python:maybecall", "1") __rgt__;
%feature("python:maybecall", "1") __ge__;  %feature("python:maybecall", "1") __rge__;
%feature("python:maybecall", "1") __eq__;  %feature("python:maybecall", "1") __req__;
%feature("python:maybecall", "1") __ne__;  %feature("python:maybecall", "1") __rne__;





%endoffile

/* ------------------------------------------------------------
 * Warnings for Python keywords 
 * ------------------------------------------------------------ */
%includefile "/home/balos1/.local/share/swig/4.0.0/python/pythonkw.swg" %beginfile
/*
  Warnings for Python keywords, built-in names and bad names.
*/





/*
  Warnings for Python keywords 
  https://docs.python.org/2/reference/lexical_analysis.html#keywords
*/

%namewarn("314"":""'" "and" "' is a python keyword",rename="_%s")  "and";
%namewarn("314"":""'" "as" "' is a python keyword",rename="_%s")  "as";
%namewarn("314"":""'" "assert" "' is a python keyword",rename="_%s")  "assert";
%namewarn("314"":""'" "async" "' is a python keyword",rename="_%s")  "async";
%namewarn("314"":""'" "await" "' is a python keyword",rename="_%s")  "await";
%namewarn("314"":""'" "break" "' is a python keyword",rename="_%s")  "break";
%namewarn("314"":""'" "class" "' is a python keyword",rename="_%s")  "class";
%namewarn("314"":""'" "continue" "' is a python keyword",rename="_%s")  "continue";
%namewarn("314"":""'" "def" "' is a python keyword",rename="_%s")  "def";
%namewarn("314"":""'" "del" "' is a python keyword",rename="_%s")  "del";
%namewarn("314"":""'" "elif" "' is a python keyword",rename="_%s")  "elif";
%namewarn("314"":""'" "else" "' is a python keyword",rename="_%s")  "else";
%namewarn("314"":""'" "except" "' is a python keyword",rename="_%s")  "except";
%namewarn("314"":""'" "exec" "' is a python keyword",rename="_%s")  "exec";
%namewarn("314"":""'" "finally" "' is a python keyword",rename="_%s")  "finally";
%namewarn("314"":""'" "for" "' is a python keyword",rename="_%s")  "for";
%namewarn("314"":""'" "from" "' is a python keyword",rename="_%s")  "from";
%namewarn("314"":""'" "global" "' is a python keyword",rename="_%s")  "global";
%namewarn("314"":""'" "if" "' is a python keyword",rename="_%s")  "if";
%namewarn("314"":""'" "import" "' is a python keyword",rename="_%s")  "import";
%namewarn("314"":""'" "in" "' is a python keyword",rename="_%s")  "in";
%namewarn("314"":""'" "is" "' is a python keyword",rename="_%s")  "is";
%namewarn("314"":""'" "lambda" "' is a python keyword",rename="_%s")  "lambda";
%namewarn("314"":""'" "not" "' is a python keyword",rename="_%s")  "not";
%namewarn("314"":""'" "or" "' is a python keyword",rename="_%s")  "or";
%namewarn("314"":""'" "pass" "' is a python keyword",rename="_%s")  "pass";
%namewarn("314"":""'" "print" "' is a python keyword",rename="_%s")  "print";
%namewarn("314"":""'" "raise" "' is a python keyword",rename="_%s")  "raise";
%namewarn("314"":""'" "return" "' is a python keyword",rename="_%s")  "return";
%namewarn("314"":""'" "try" "' is a python keyword",rename="_%s")  "try";
%namewarn("314"":""'" "while" "' is a python keyword",rename="_%s")  "while";
%namewarn("314"":""'" "with" "' is a python keyword",rename="_%s")  "with";
%namewarn("314"":""'" "yield" "' is a python keyword",rename="_%s")  "yield";

/*
  built-in functions
  https://docs.python.org/2/library/functions.html
 */ 

%namewarn("321"":""'" "abs" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "abs";
%namewarn("321"":""'" "apply" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "apply";
%namewarn("321"":""'" "bool" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "bool";
%namewarn("321"":""'" "buffer" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "buffer";
%namewarn("321"":""'" "callable" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "callable";
%namewarn("321"":""'" "chr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "chr";
%namewarn("321"":""'" "classmethod" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "classmethod";
%namewarn("321"":""'" "cmp" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "cmp";
%namewarn("321"":""'" "coerce" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "coerce";
%namewarn("321"":""'" "compile" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "compile";
%namewarn("321"":""'" "complex" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "complex";
%namewarn("321"":""'" "delattr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "delattr";
%namewarn("321"":""'" "dict" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "dict";
%namewarn("321"":""'" "dir" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "dir";
%namewarn("321"":""'" "divmod" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "divmod";
%namewarn("321"":""'" "enumerate" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "enumerate";
%namewarn("321"":""'" "eval" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "eval";
%namewarn("321"":""'" "execfile" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "execfile";
%namewarn("321"":""'" "file" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "file";
%namewarn("321"":""'" "filter" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "filter";
%namewarn("321"":""'" "float" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "float";
%namewarn("321"":""'" "frozenset" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "frozenset";
%namewarn("321"":""'" "getattr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "getattr";
%namewarn("321"":""'" "globals" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "globals";
%namewarn("321"":""'" "hasattr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "hasattr";
%namewarn("321"":""'" "hash" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "hash";
%namewarn("321"":""'" "hex" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "hex";
%namewarn("321"":""'" "id" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "id";
%namewarn("321"":""'" "input" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "input";
%namewarn("321"":""'" "int" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "int";
%namewarn("321"":""'" "intern" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "intern";
%namewarn("321"":""'" "isinstance" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "isinstance";
%namewarn("321"":""'" "issubclass" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "issubclass";
%namewarn("321"":""'" "iter" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "iter";
%namewarn("321"":""'" "len" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "len";
%namewarn("321"":""'" "list" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "list";
%namewarn("321"":""'" "locals" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "locals";
%namewarn("321"":""'" "long" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "long";
%namewarn("321"":""'" "map" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "map";
%namewarn("321"":""'" "max" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "max";
%namewarn("321"":""'" "min" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "min";
%namewarn("321"":""'" "object" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "object";
%namewarn("321"":""'" "oct" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "oct";
%namewarn("321"":""'" "open" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "open";
%namewarn("321"":""'" "ord" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "ord";
%namewarn("321"":""'" "pow" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "pow";
%namewarn("321"":""'" "property" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "property";
%namewarn("321"":""'" "range" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "range";
%namewarn("321"":""'" "raw_input" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "raw_input";
%namewarn("321"":""'" "reduce" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "reduce";
%namewarn("321"":""'" "reload" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "reload";
%namewarn("321"":""'" "repr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "repr";
%namewarn("321"":""'" "reversed" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "reversed";
%namewarn("321"":""'" "round" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "round";
%namewarn("321"":""'" "set" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "set";
%namewarn("321"":""'" "setattr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "setattr";
%namewarn("321"":""'" "slice" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "slice";
%namewarn("321"":""'" "sorted" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "sorted";
%namewarn("321"":""'" "staticmethod" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "staticmethod";
%namewarn("321"":""'" "str" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "str";
%namewarn("321"":""'" "sum" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "sum";
%namewarn("321"":""'" "super" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "super";
%namewarn("321"":""'" "tuple" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "tuple";
%namewarn("321"":""'" "type" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "type";
%namewarn("321"":""'" "unichr" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "unichr";
%namewarn("321"":""'" "unicode" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "unicode";
%namewarn("321"":""'" "vars" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "vars";
%namewarn("321"":""'" "xrange" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "xrange";
%namewarn("321"":""'" "zip" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "zip";


/* 
   built-in names
   boolean type and None
*/
%namewarn("321"":""'" "True" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "True";
%namewarn("321"":""'" "False" "' conflicts with a built-in name in python",     "match$kind"="function"  )  "False";

%namewarn("314"":""'" "None" "' is a python keyword",rename="_%s")  "None";


/* 
   'self' is also a bad Name
*/
%namewarn("314"":""'" "self" "' is a python keyword",rename="_%s")  "self";



%endoffile

/* ------------------------------------------------------------
 * The Python autodoc support
 * ------------------------------------------------------------ */
%includefile "/home/balos1/.local/share/swig/4.0.0/python/pydocs.swg" %beginfile

// Documentation for use with the autodoc feature.












%typemap(doc) SWIGTYPE "$1_name: $1_type";
%typemap(doc) SWIGTYPE * "$1_name: $1_type";
%typemap(doc) const SWIGTYPE & "$1_name: $1_type";
%typemap(doc) const SWIGTYPE && "$1_name: $1_type";
%typemap(doc) enum SWIGTYPE "$1_name: enum $1_type";

%typemap(doc) SWIGTYPE *INOUT, SWIGTYPE &INOUT "$1_name: $1_type (input/output)";
%typemap(doc) SWIGTYPE *INPUT, SWIGTYPE &INPUT "$1_name: $1_type (input)";
%typemap(doc) SWIGTYPE *OUTPUT, SWIGTYPE &OUTPUT "$1_name: $1_type (output)";



// Types to use in Python documentation for the parameters of the given C++ type.
%typemap(doctype) bool "boolean";




/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/swigmacros.swg,193,%formacro@*//*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/swigmacros.swg,185,%_formacro_1@*//*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pydocs.swg,30,int_doctype_for_cppint_type@*/
    %typemap(doctype) short, unsigned short "int";
/*@SWIG@*/

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/swigmacros.swg,185,%_formacro_1@*//*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pydocs.swg,30,int_doctype_for_cppint_type@*/
    %typemap(doctype) int, unsigned int "int";
/*@SWIG@*/

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/swigmacros.swg,185,%_formacro_1@*//*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pydocs.swg,30,int_doctype_for_cppint_type@*/
    %typemap(doctype) long, unsigned long "int";
/*@SWIG@*/

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/swigmacros.swg,185,%_formacro_1@*//*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pydocs.swg,30,int_doctype_for_cppint_type@*/
    %typemap(doctype) long long, unsigned long long "int";
/*@SWIG@*/



/*@SWIG@*/

/*@SWIG@*/

/*@SWIG@*/

/*@SWIG@*//*@SWIG@*/

%typemap(doctype) size_t "int";

%typemap(doctype) enum SWIGTYPE "int";

%typemap(doctype) float, double, long double "float";

%typemap(doctype) char*, std::string "string";

%typemap(doctype) SWIGTYPE "$1_basetype"
%typemap(doctype) SWIGTYPE * "$typemap(doctype, $*1_ltype)"
%typemap(doctype) SWIGTYPE & "$typemap(doctype, $*1_ltype)"
%endoffile

/* ------------------------------------------------------------
 * The Python classes, for C++
 * ------------------------------------------------------------ */
%includefile "/home/balos1/.local/share/swig/4.0.0/python/pyclasses.swg" %beginfile


/*
  SwigPtr_PyObject is used as a replacement of PyObject *, where
  the INCREF/DECREF are applied as needed.

  You can use SwigPtr_PyObject in a container, such as
  
     std::vector<SwigPtr_PyObject>;

  or as a member variable:
  
     struct A {
       SwigPtr_PyObject obj;
       A(PyObject *o) : _obj(o) {
       }
     };

   or as a input/output value 

     SwigPtr_PyObject func(SwigPtr_PyObject obj) {     
       SwigPtr_PyObject out = PyString_FromFormat("hello %s", PyObject_AsString(obj));
       Py_DECREF(out);
       return out;
     }

   just remember to pair the object creation with the proper DECREF,
   the same as with plain PyObject *ptr, since SwigPtr_PyObject always add
   one reference at construction.

   SwigPtr_PyObject is 'visible' at the wrapped side, so you can do:


      %template(pyvector) std::vector<swig::SwigPtr_PyObject>;

   and all the proper typemaps will be used.
   
*/

namespace swig {
  %rename($ignore) SwigPtr_PyObject;
  struct SwigPtr_PyObject {};
  %apply PyObject * {SwigPtr_PyObject};
  %apply PyObject * const& {SwigPtr_PyObject const&};

  %typemap(typecheck,precedence=       5000    ,noblock=1) SwigPtr_PyObject const& "$1 = ($input != 0);";


  /* For output */
  %typemap(out,noblock=1)  SwigPtr_PyObject {
    $result = (PyObject *)$1;
    Py_INCREF($result);
  }
  
  %typemap(out,noblock=1)  SwigPtr_PyObject const & {
    $result = (PyObject *)*$1;
    Py_INCREF($result);
  }
  
}

%{
namespace swig {
  class SwigPtr_PyObject {
  protected:
    PyObject *_obj;

  public:
    SwigPtr_PyObject() :_obj(0)
    {
    }

    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(_obj);      
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
    {
      if (initial_ref) {
        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
        Py_XINCREF(_obj);
        SWIG_PYTHON_THREAD_END_BLOCK;
      }
    }
    
    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(item._obj);
      Py_XDECREF(_obj);
      _obj = item._obj;
      SWIG_PYTHON_THREAD_END_BLOCK;
      return *this;      
    }
    
    ~SwigPtr_PyObject() 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XDECREF(_obj);
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    operator PyObject *() const
    {
      return _obj;
    }

    PyObject *operator->() const
    {
      return _obj;
    }
  };
}
%}

/*
  SwigVar_PyObject is used to manage 'in the scope' PyObject * variables,
  as in

  int func () {
    SwigVar_PyObject obj = PyString_FromString("hello");
  }

  ie, 'obj' is created and destructed in the same scope from
  a python object that carries at least one reference value.
  
  SwigVar_PyObject just take care of applying the proper Py_DECREF.

  Hence, this class is purely internal and not visible at the wrapped side.
 */
namespace swig {
  %rename($ignore) SwigVar_PyObject;
  struct SwigVar_PyObject {};
  %apply PyObject * {SwigVar_PyObject};
  %apply PyObject * const& {SwigVar_PyObject const&};
}

%{
namespace swig {
  struct SwigVar_PyObject : SwigPtr_PyObject {
    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
    
    SwigVar_PyObject & operator = (PyObject* obj)
    {
      Py_XDECREF(_obj);
      _obj = obj;
      return *this;      
    }
  };
}
%}



%endoffile

/* ------------------------------------------------------------
 * The Python initialization function 
 * ------------------------------------------------------------ */
%includefile "/home/balos1/.local/share/swig/4.0.0/python/pyinit.swg" %beginfile
/* ------------------------------------------------------------
 * The start of the Python initialization function 
 * ------------------------------------------------------------ */

%insert(init) "swiginit.swg"





%insert("init") %{

#ifdef __cplusplus
extern "C" {
#endif

/* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
 
/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */
 
typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

SWIGINTERN PyObject *
swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_InternFromString("<Swig global variables>");
#else
  return PyString_FromString("<Swig global variables>");
#endif
}

SWIGINTERN PyObject *
swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
  PyObject *str = PyUnicode_InternFromString("(");
  PyObject *tail;
  PyObject *joined;
  swig_globalvar *var;
  for (var = v->vars; var; var=var->next) {
    tail = PyUnicode_FromString(var->name);
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
    if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
    }
  }
  tail = PyUnicode_InternFromString(")");
  joined = PyUnicode_Concat(str, tail);
  Py_DecRef(str);
  Py_DecRef(tail);
  str = joined;
#else
  PyObject *str = PyString_FromString("(");
  swig_globalvar *var;
  for (var = v->vars; var; var=var->next) {
    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
  }
  PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
  return str;
}

SWIGINTERN void
swig_varlink_dealloc(swig_varlinkobject *v) {
  swig_globalvar *var = v->vars;
  while (var) {
    swig_globalvar *n = var->next;
    free(var->name);
    free(var);
    var = n;
  }
}

SWIGINTERN PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  PyObject *res = NULL;
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      res = (*var->get_attr)();
      break;
    }
    var = var->next;
  }
  if (res == NULL && !PyErr_Occurred()) {
    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
  }
  return res;
}

SWIGINTERN int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  int res = 1;
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      res = (*var->set_attr)(p);
      break;
    }
    var = var->next;
  }
  if (res == 1 && !PyErr_Occurred()) {
    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
  }
  return res;
}

SWIGINTERN PyTypeObject*
swig_varlink_type(void) {
  static char varlink__doc__[] = "Swig var link object";
  static PyTypeObject varlink_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                  /* ob_size */
#endif
      "swigvarlink",                      /* tp_name */
      sizeof(swig_varlinkobject),         /* tp_basicsize */
      0,                                  /* tp_itemsize */
      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
      0,                                  /* tp_print */
      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
      0,                                  /* tp_compare */
      (reprfunc) swig_varlink_repr,       /* tp_repr */
      0,                                  /* tp_as_number */
      0,                                  /* tp_as_sequence */
      0,                                  /* tp_as_mapping */
      0,                                  /* tp_hash */
      0,                                  /* tp_call */
      (reprfunc) swig_varlink_str,        /* tp_str */
      0,                                  /* tp_getattro */
      0,                                  /* tp_setattro */
      0,                                  /* tp_as_buffer */
      0,                                  /* tp_flags */
      varlink__doc__,                     /* tp_doc */
      0,                                  /* tp_traverse */
      0,                                  /* tp_clear */
      0,                                  /* tp_richcompare */
      0,                                  /* tp_weaklistoffset */
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
      0,                                  /* tp_del */
      0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                  /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                  /* tp_allocs */
      0,                                  /* tp_frees */
      0,                                  /* tp_maxalloc */
      0,                                  /* tp_prev */
      0                                   /* tp_next */
#endif
    };
    varlink_type = tmp;
    type_init = 1;
    if (PyType_Ready(&varlink_type) < 0)
      return NULL;
  }
  return &varlink_type;
}

/* Create a variable linking object for use later */
SWIGINTERN PyObject *
SWIG_Python_newvarlink(void) {
  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
  if (result) {
    result->vars = 0;
  }
  return ((PyObject*) result);
}

SWIGINTERN void 
SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v = (swig_varlinkobject *) p;
  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  if (gv) {
    size_t size = strlen(name)+1;
    gv->name = (char *)malloc(size);
    if (gv->name) {
      memcpy(gv->name, name, size);
      gv->get_attr = get_attr;
      gv->set_attr = set_attr;
      gv->next = v->vars;
    }
  }
  v->vars = gv;
}

SWIGINTERN PyObject *
SWIG_globals(void) {
  static PyObject *globals = 0;
  if (!globals) {
    globals = SWIG_newvarlink();
  }
  return globals;
}

/* -----------------------------------------------------------------------------
 * constants/methods manipulation
 * ----------------------------------------------------------------------------- */

/* Install Constants */
SWIGINTERN void
SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
  PyObject *obj = 0;
  size_t i;
  for (i = 0; constants[i].type; ++i) {
    switch(constants[i].type) {
    case SWIG_PY_POINTER:
      obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d, constants[i].name, obj);
      Py_DECREF(obj);
    }
  }
}

/* -----------------------------------------------------------------------------*/
/* Fix SwigMethods to carry the callback ptrs when needed */
/* -----------------------------------------------------------------------------*/

SWIGINTERN void
SWIG_Python_FixMethods(PyMethodDef *methods,
		       swig_const_info *const_table,
		       swig_type_info **types,
		       swig_type_info **types_initial) {
  size_t i;
  for (i = 0; methods[i].ml_name; ++i) {
    const char *c = methods[i].ml_doc;
    if (!c) continue;
    c = strstr(c, "swig_ptr: ");
    if (c) {
      int j;
      swig_const_info *ci = 0;
      const char *name = c + 10;
      for (j = 0; const_table[j].type; ++j) {
	if (strncmp(const_table[j].name, name, 
		    strlen(const_table[j].name)) == 0) {
	  ci = &(const_table[j]);
	  break;
	}
      }
      if (ci) {
	void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
	if (ptr) {
	  size_t shift = (ci->ptype) - types;
	  swig_type_info *ty = types_initial[shift];
	  size_t ldoc = (c - methods[i].ml_doc);
	  size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
	  char *ndoc = (char*)malloc(ldoc + lptr + 10);
	  if (ndoc) {
	    char *buff = ndoc;
	    memcpy(buff, methods[i].ml_doc, ldoc);
	    buff += ldoc;
	    memcpy(buff, "swig_ptr: ", 10);
	    buff += 10;
	    SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
	    methods[i].ml_doc = ndoc;
	  }
	}
      }
    }
  }
} 

#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
  PyObject*
#else
  void
#endif
SWIG_init(void) {
  PyObject *m, *d, *md, *globals;

#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
    PyModuleDef_HEAD_INIT,
    SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif

#if defined(SWIGPYTHON_BUILTIN)
  static SwigPyClientData SwigPyObject_clientdata = {0, 0, 0, 0, 0, 0, 0};
  static PyGetSetDef this_getset_def = {
    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
  };
  static SwigPyGetSet thisown_getset_closure = {
    SwigPyObject_own,
    SwigPyObject_own
  };
  static PyGetSetDef thisown_getset_def = {
    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
  };
  PyTypeObject *builtin_pytype;
  int builtin_base_count;
  swig_type_info *builtin_basetype;
  PyObject *tuple;
  PyGetSetDescrObject *static_getset;
  PyTypeObject *metatype;
  PyTypeObject *swigpyobject;
  SwigPyClientData *cd;
  PyObject *public_interface, *public_symbol;
  PyObject *this_descr;
  PyObject *thisown_descr;
  PyObject *self = 0;
  int i;

  (void)builtin_pytype;
  (void)builtin_base_count;
  (void)builtin_basetype;
  (void)tuple;
  (void)static_getset;
  (void)self;

  /* Metaclass is used to implement static member variables */
  metatype = SwigPyObjectType();
  assert(metatype);
#endif

  (void)globals;

  /* Create singletons now to avoid potential deadlocks with multi-threaded usage after module initialization */
  SWIG_This();
  SWIG_Python_TypeCache();
  SwigPyPacked_type();
#ifndef SWIGPYTHON_BUILTIN
  SwigPyObject_type();
#endif

  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);

#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule(SWIG_name, SwigMethods);
#endif

  md = d = PyModule_GetDict(m);
  (void)md;

  SWIG_InitializeModule(0);

#ifdef SWIGPYTHON_BUILTIN
  swigpyobject = SwigPyObject_TypeOnce();

  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
  assert(SwigPyObject_stype);
  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
  if (!cd) {
    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
    SwigPyObject_clientdata.pytype = swigpyobject;
  } else if (swigpyobject->tp_basicsize != cd->pytype->tp_basicsize) {
    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }

  /* All objects have a 'this' attribute */
  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
  (void)this_descr;

  /* All objects have a 'thisown' attribute */
  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
  (void)thisown_descr;

  public_interface = PyList_New(0);
  public_symbol = 0;
  (void)public_symbol;

  PyDict_SetItemString(md, "__all__", public_interface);
  Py_DECREF(public_interface);
  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
    SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
  for (i = 0; swig_const_table[i].name != 0; ++i)
    SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
#endif

  SWIG_InstallConstants(d,swig_const_table);
%}

%endoffile


/* ------------------------------------------------------------
 * For backward compatibility
 * ------------------------------------------------------------ */
%includefile "/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg" %beginfile
/* 
   adding backward compatibility macros
*/








































/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/primtypes.swg,341,%apply_checkctypes@*/
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {bool},"header", fragment="SWIG_" "AsVal" "_" {bool}) {
SWIGINTERNINLINE bool
SWIG_As_bool (PyObject* obj)
{
  bool v;
  int res = SWIG_AsVal_bool (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(bool));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {bool},"header",fragment="SWIG_" "AsVal" "_" {bool}) {
SWIGINTERNINLINE int
SWIG_Check_bool (PyObject* obj)
{
  int res = SWIG_AsVal_bool (obj, (bool*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {signed char},"header", fragment="SWIG_" "AsVal" "_" {signed char}) {
SWIGINTERNINLINE signed char
SWIG_As_signed_SS_char (PyObject* obj)
{
  signed char v;
  int res = SWIG_AsVal_signed_SS_char (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(signed char));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {signed char},"header",fragment="SWIG_" "AsVal" "_" {signed char}) {
SWIGINTERNINLINE int
SWIG_Check_signed_SS_char (PyObject* obj)
{
  int res = SWIG_AsVal_signed_SS_char (obj, (signed char*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {unsigned char},"header", fragment="SWIG_" "AsVal" "_" {unsigned char}) {
SWIGINTERNINLINE unsigned char
SWIG_As_unsigned_SS_char (PyObject* obj)
{
  unsigned char v;
  int res = SWIG_AsVal_unsigned_SS_char (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(unsigned char));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {unsigned char},"header",fragment="SWIG_" "AsVal" "_" {unsigned char}) {
SWIGINTERNINLINE int
SWIG_Check_unsigned_SS_char (PyObject* obj)
{
  int res = SWIG_AsVal_unsigned_SS_char (obj, (unsigned char*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {short},"header", fragment="SWIG_" "AsVal" "_" {short}) {
SWIGINTERNINLINE short
SWIG_As_short (PyObject* obj)
{
  short v;
  int res = SWIG_AsVal_short (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(short));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {short},"header",fragment="SWIG_" "AsVal" "_" {short}) {
SWIGINTERNINLINE int
SWIG_Check_short (PyObject* obj)
{
  int res = SWIG_AsVal_short (obj, (short*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {unsigned short},"header", fragment="SWIG_" "AsVal" "_" {unsigned short}) {
SWIGINTERNINLINE unsigned short
SWIG_As_unsigned_SS_short (PyObject* obj)
{
  unsigned short v;
  int res = SWIG_AsVal_unsigned_SS_short (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(unsigned short));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {unsigned short},"header",fragment="SWIG_" "AsVal" "_" {unsigned short}) {
SWIGINTERNINLINE int
SWIG_Check_unsigned_SS_short (PyObject* obj)
{
  int res = SWIG_AsVal_unsigned_SS_short (obj, (unsigned short*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {int},"header", fragment="SWIG_" "AsVal" "_" {int}) {
SWIGINTERNINLINE int
SWIG_As_int (PyObject* obj)
{
  int v;
  int res = SWIG_AsVal_int (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(int));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {int},"header",fragment="SWIG_" "AsVal" "_" {int}) {
SWIGINTERNINLINE int
SWIG_Check_int (PyObject* obj)
{
  int res = SWIG_AsVal_int (obj, (int*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {unsigned int},"header", fragment="SWIG_" "AsVal" "_" {unsigned int}) {
SWIGINTERNINLINE unsigned int
SWIG_As_unsigned_SS_int (PyObject* obj)
{
  unsigned int v;
  int res = SWIG_AsVal_unsigned_SS_int (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(unsigned int));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {unsigned int},"header",fragment="SWIG_" "AsVal" "_" {unsigned int}) {
SWIGINTERNINLINE int
SWIG_Check_unsigned_SS_int (PyObject* obj)
{
  int res = SWIG_AsVal_unsigned_SS_int (obj, (unsigned int*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {long},"header", fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERNINLINE long
SWIG_As_long (PyObject* obj)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(long));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {long},"header",fragment="SWIG_" "AsVal" "_" {long}) {
SWIGINTERNINLINE int
SWIG_Check_long (PyObject* obj)
{
  int res = SWIG_AsVal_long (obj, (long*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {unsigned long},"header", fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERNINLINE unsigned long
SWIG_As_unsigned_SS_long (PyObject* obj)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(unsigned long));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {unsigned long},"header",fragment="SWIG_" "AsVal" "_" {unsigned long}) {
SWIGINTERNINLINE int
SWIG_Check_unsigned_SS_long (PyObject* obj)
{
  int res = SWIG_AsVal_unsigned_SS_long (obj, (unsigned long*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {long long},"header", fragment="SWIG_" "AsVal" "_" {long long}) {
SWIGINTERNINLINE long long
SWIG_As_long_SS_long (PyObject* obj)
{
  long long v;
  int res = SWIG_AsVal_long_SS_long (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(long long));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {long long},"header",fragment="SWIG_" "AsVal" "_" {long long}) {
SWIGINTERNINLINE int
SWIG_Check_long_SS_long (PyObject* obj)
{
  int res = SWIG_AsVal_long_SS_long (obj, (long long*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {unsigned long long},"header", fragment="SWIG_" "AsVal" "_" {unsigned long long}) {
SWIGINTERNINLINE unsigned long long
SWIG_As_unsigned_SS_long_SS_long (PyObject* obj)
{
  unsigned long long v;
  int res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(unsigned long long));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {unsigned long long},"header",fragment="SWIG_" "AsVal" "_" {unsigned long long}) {
SWIGINTERNINLINE int
SWIG_Check_unsigned_SS_long_SS_long (PyObject* obj)
{
  int res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, (unsigned long long*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {float},"header", fragment="SWIG_" "AsVal" "_" {float}) {
SWIGINTERNINLINE float
SWIG_As_float (PyObject* obj)
{
  float v;
  int res = SWIG_AsVal_float (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(float));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {float},"header",fragment="SWIG_" "AsVal" "_" {float}) {
SWIGINTERNINLINE int
SWIG_Check_float (PyObject* obj)
{
  int res = SWIG_AsVal_float (obj, (float*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {double},"header", fragment="SWIG_" "AsVal" "_" {double}) {
SWIGINTERNINLINE double
SWIG_As_double (PyObject* obj)
{
  double v;
  int res = SWIG_AsVal_double (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(double));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {double},"header",fragment="SWIG_" "AsVal" "_" {double}) {
SWIGINTERNINLINE int
SWIG_Check_double (PyObject* obj)
{
  int res = SWIG_AsVal_double (obj, (double*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {char},"header", fragment="SWIG_" "AsVal" "_" {char}) {
SWIGINTERNINLINE char
SWIG_As_char (PyObject* obj)
{
  char v;
  int res = SWIG_AsVal_char (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(char));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {char},"header",fragment="SWIG_" "AsVal" "_" {char}) {
SWIGINTERNINLINE int
SWIG_Check_char (PyObject* obj)
{
  int res = SWIG_AsVal_char (obj, (char*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {wchar_t},"header", fragment="SWIG_" "AsVal" "_" {wchar_t}) {
SWIGINTERNINLINE wchar_t
SWIG_As_wchar_t (PyObject* obj)
{
  wchar_t v;
  int res = SWIG_AsVal_wchar_t (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(wchar_t));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {wchar_t},"header",fragment="SWIG_" "AsVal" "_" {wchar_t}) {
SWIGINTERNINLINE int
SWIG_Check_wchar_t (PyObject* obj)
{
  int res = SWIG_AsVal_wchar_t (obj, (wchar_t*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {size_t},"header", fragment="SWIG_" "AsVal" "_" {size_t}) {
SWIGINTERNINLINE size_t
SWIG_As_size_t (PyObject* obj)
{
  size_t v;
  int res = SWIG_AsVal_size_t (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(size_t));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {size_t},"header",fragment="SWIG_" "AsVal" "_" {size_t}) {
SWIGINTERNINLINE int
SWIG_Check_size_t (PyObject* obj)
{
  int res = SWIG_AsVal_size_t (obj, (size_t*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pybackward.swg,16,%ascheck_methods@*/
%fragment("SWIG_" "As" "_" {ptrdiff_t},"header", fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) {
SWIGINTERNINLINE ptrdiff_t
SWIG_As_ptrdiff_t (PyObject* obj)
{
  ptrdiff_t v;
  int res = SWIG_AsVal_ptrdiff_t (obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(ptrdiff_t));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment("SWIG_" "Check" "_" {ptrdiff_t},"header",fragment="SWIG_" "AsVal" "_" {ptrdiff_t}) {
SWIGINTERNINLINE int
SWIG_Check_ptrdiff_t (PyObject* obj)
{
  int res = SWIG_AsVal_ptrdiff_t (obj, (ptrdiff_t*)0);
  return SWIG_IsOK(res);
}
}
/*@SWIG@*/;
/*@SWIG@*/

%endoffile


%endoffile
%includefile(maininput="kinsol.i") "kinsol.i" %beginfile
// ---------------------------------------------------------------
// Programmer: Cody J. Balos @ LLNL
// ---------------------------------------------------------------
// SUNDIALS Copyright Start
// Copyright (c) 2002-2019, Lawrence Livermore National Security
// and Southern Methodist University.
// All rights reserved.
//
// See the top-level LICENSE and NOTICE files for details.
//
// SPDX-License-Identifier: BSD-3-Clause
// SUNDIALS Copyright End
// ---------------------------------------------------------------
// Swig interface file
// ---------------------------------------------------------------

%module(directors="1") kinsol

%includefile "/home/balos1/.local/share/swig/4.0.0/stdint.i" %beginfile
/* -----------------------------------------------------------------------------
 * stdint.i
 *
 * SWIG library file for ISO C99 types: 7.18 Integer types <stdint.h>
 * ----------------------------------------------------------------------------- */

%{
#include <stdint.h>		// Use the C99 official header
%}

%includefile "/home/balos1/.local/share/swig/4.0.0/swigarch.i" %beginfile
/* -----------------------------------------------------------------------------
 * swigarch.i
 *
 * SWIG library file for 32bit/64bit code specialization and checking.
 *
 * Use only in extreme cases, when no arch. independent code can be
 * generated
 * 
 * To activate architecture specific code, use
 *
 *     swig -DSWIGWORDSIZE32
 *
 * or
 *
 *     swig -DSWIGWORDSIZE64
 *
 * Note that extra checking code will be added to the wrapped code,
 * which will prevent the compilation in a different architecture.
 *
 * If you don't specify the SWIGWORDSIZE (the default case), swig will
 * generate architecture independent and/or 32bits code, with no extra
 * checking code added.
 * ----------------------------------------------------------------------------- */






  






























  

%endoffile

/* Exact integral types.  */

/* Signed.  */

typedef signed char		int8_t;
typedef short int		int16_t;
typedef int			int32_t;



typedef long long int		int64_t;


/* Unsigned.  */
typedef unsigned char		uint8_t;
typedef unsigned short int	uint16_t;
typedef unsigned int		uint32_t;



typedef unsigned long long int	uint64_t;



/* Small types.  */

/* Signed.  */
typedef signed char		int_least8_t;
typedef short int		int_least16_t;
typedef int			int_least32_t;



typedef long long int		int_least64_t;


/* Unsigned.  */
typedef unsigned char		uint_least8_t;
typedef unsigned short int	uint_least16_t;
typedef unsigned int		uint_least32_t;



typedef unsigned long long int	uint_least64_t;



/* Fast types.  */

/* Signed.  */
typedef signed char		int_fast8_t;





typedef int			int_fast16_t;
typedef int			int_fast32_t;
typedef long long int		int_fast64_t;


/* Unsigned.  */
typedef unsigned char		uint_fast8_t;





typedef unsigned int		uint_fast16_t;
typedef unsigned int		uint_fast32_t;
typedef unsigned long long int	uint_fast64_t;



/* Types for `void *' pointers.  */




typedef int			intptr_t;
typedef unsigned int		uintptr_t;



/* Largest integral types.  */




typedef long long int		intmax_t;
typedef unsigned long long int	uintmax_t;



%endoffile

// ----------------------------------
// numpy swig setup stuff.
// This must only happen in one file.
// ----------------------------------

%{
#define SWIG_FILE_WITH_INIT
%}
%includefile "numpy.i" %beginfile
/* -*- C -*-  (not really, but good for syntax highlighting) */

/*
 * Copyright (c) 2005-2015, NumPy Developers.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer in the documentation and/or other materials provided
 *        with the distribution.
 *
 *     * Neither the name of the NumPy Developers nor the names of any
 *        contributors may be used to endorse or promote products derived
 *        from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



%{
#ifndef SWIG_FILE_WITH_INIT
#define NO_IMPORT_ARRAY
#endif
#include "stdio.h"
#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#include <numpy/arrayobject.h>
%}

/**********************************************************************/

%fragment("NumPy_Backward_Compatibility", "header")
{
#if NPY_API_VERSION < 0x00000007
#define NPY_ARRAY_DEFAULT NPY_DEFAULT
#define NPY_ARRAY_FARRAY  NPY_FARRAY
#define NPY_FORTRANORDER  NPY_FORTRAN
#endif
}

/**********************************************************************/

/* The following code originally appeared in
 * enthought/kiva/agg/src/numeric.i written by Eric Jones.  It was
 * translated from C++ to C by John Hunter.  Bill Spotz has modified
 * it to fix some minor bugs, upgrade from Numeric to numpy (all
 * versions), add some comments and functionality, and convert from
 * direct code insertion to SWIG fragments.
 */

%fragment("NumPy_Macros", "header")
{
/* Macros to extract array attributes.
 */
#if NPY_API_VERSION < 0x00000007
#define is_array(a)            ((a) && PyArray_Check((PyArrayObject*)a))
#define array_type(a)          (int)(PyArray_TYPE((PyArrayObject*)a))
#define array_numdims(a)       (((PyArrayObject*)a)->nd)
#define array_dimensions(a)    (((PyArrayObject*)a)->dimensions)
#define array_size(a,i)        (((PyArrayObject*)a)->dimensions[i])
#define array_strides(a)       (((PyArrayObject*)a)->strides)
#define array_stride(a,i)      (((PyArrayObject*)a)->strides[i])
#define array_data(a)          (((PyArrayObject*)a)->data)
#define array_descr(a)         (((PyArrayObject*)a)->descr)
#define array_flags(a)         (((PyArrayObject*)a)->flags)
#define array_clearflags(a,f)  (((PyArrayObject*)a)->flags) &= ~f
#define array_enableflags(a,f) (((PyArrayObject*)a)->flags) = f
#define array_is_fortran(a)    (PyArray_ISFORTRAN((PyArrayObject*)a))
#else
#define is_array(a)            ((a) && PyArray_Check(a))
#define array_type(a)          PyArray_TYPE((PyArrayObject*)a)
#define array_numdims(a)       PyArray_NDIM((PyArrayObject*)a)
#define array_dimensions(a)    PyArray_DIMS((PyArrayObject*)a)
#define array_strides(a)       PyArray_STRIDES((PyArrayObject*)a)
#define array_stride(a,i)      PyArray_STRIDE((PyArrayObject*)a,i)
#define array_size(a,i)        PyArray_DIM((PyArrayObject*)a,i)
#define array_data(a)          PyArray_DATA((PyArrayObject*)a)
#define array_descr(a)         PyArray_DESCR((PyArrayObject*)a)
#define array_flags(a)         PyArray_FLAGS((PyArrayObject*)a)
#define array_enableflags(a,f) PyArray_ENABLEFLAGS((PyArrayObject*)a,f)
#define array_clearflags(a,f)  PyArray_CLEARFLAGS((PyArrayObject*)a,f)
#define array_is_fortran(a)    (PyArray_IS_F_CONTIGUOUS((PyArrayObject*)a))
#endif
#define array_is_contiguous(a) (PyArray_ISCONTIGUOUS((PyArrayObject*)a))
#define array_is_native(a)     (PyArray_ISNOTSWAPPED((PyArrayObject*)a))
}

/**********************************************************************/

%fragment("NumPy_Utilities",
          "header")
{
  /* Given a PyObject, return a string describing its type.
   */
  const char* pytype_string(PyObject* py_obj)
  {
    if (py_obj == NULL          ) return "C NULL value";
    if (py_obj == Py_None       ) return "Python None" ;
    if (PyCallable_Check(py_obj)) return "callable"    ;
    if (PyString_Check(  py_obj)) return "string"      ;
    if (PyInt_Check(     py_obj)) return "int"         ;
    if (PyFloat_Check(   py_obj)) return "float"       ;
    if (PyDict_Check(    py_obj)) return "dict"        ;
    if (PyList_Check(    py_obj)) return "list"        ;
    if (PyTuple_Check(   py_obj)) return "tuple"       ;
#if PY_MAJOR_VERSION < 3
    if (PyFile_Check(    py_obj)) return "file"        ;
    if (PyModule_Check(  py_obj)) return "module"      ;
    if (PyInstance_Check(py_obj)) return "instance"    ;
#endif

    return "unknown type";
  }

  /* Given a NumPy typecode, return a string describing the type.
   */
  const char* typecode_string(int typecode)
  {
    static const char* type_names[25] = {"bool",
                                         "byte",
                                         "unsigned byte",
                                         "short",
                                         "unsigned short",
                                         "int",
                                         "unsigned int",
                                         "long",
                                         "unsigned long",
                                         "long long",
                                         "unsigned long long",
                                         "float",
                                         "double",
                                         "long double",
                                         "complex float",
                                         "complex double",
                                         "complex long double",
                                         "object",
                                         "string",
                                         "unicode",
                                         "void",
                                         "ntypes",
                                         "notype",
                                         "char",
                                         "unknown"};
    return typecode < 24 ? type_names[typecode] : type_names[24];
  }

  /* Make sure input has correct numpy type.  This now just calls
     PyArray_EquivTypenums().
   */
  int type_match(int actual_type,
                 int desired_type)
  {
    return PyArray_EquivTypenums(actual_type, desired_type);
  }

#ifdef SWIGPY_USE_CAPSULE
  void free_cap(PyObject * cap)
  {
    void* array = (void*) PyCapsule_GetPointer(cap,SWIGPY_CAPSULE_NAME);
    if (array != NULL) free(array);
  }
#endif


}

/**********************************************************************/

%fragment("NumPy_Object_to_Array",
          "header",
          fragment="NumPy_Backward_Compatibility",
          fragment="NumPy_Macros",
          fragment="NumPy_Utilities")
{
  /* Given a PyObject pointer, cast it to a PyArrayObject pointer if
   * legal.  If not, set the python error string appropriately and
   * return NULL.
   */
  PyArrayObject* obj_to_array_no_conversion(PyObject* input,
                                            int        typecode)
  {
    PyArrayObject* ary = NULL;
    if (is_array(input) && (typecode == NPY_NOTYPE ||
                            PyArray_EquivTypenums(array_type(input), typecode)))
    {
      ary = (PyArrayObject*) input;
    }
    else if is_array(input)
    {
      const char* desired_type = typecode_string(typecode);
      const char* actual_type  = typecode_string(array_type(input));
      PyErr_Format(PyExc_TypeError,
                   "Array of type '%s' required.  Array of type '%s' given",
                   desired_type, actual_type);
      ary = NULL;
    }
    else
    {
      const char* desired_type = typecode_string(typecode);
      const char* actual_type  = pytype_string(input);
      PyErr_Format(PyExc_TypeError,
                   "Array of type '%s' required.  A '%s' was given",
                   desired_type,
                   actual_type);
      ary = NULL;
    }
    return ary;
  }

  /* Convert the given PyObject to a NumPy array with the given
   * typecode.  On success, return a valid PyArrayObject* with the
   * correct type.  On failure, the python error string will be set and
   * the routine returns NULL.
   */
  PyArrayObject* obj_to_array_allow_conversion(PyObject* input,
                                               int       typecode,
                                               int*      is_new_object)
  {
    PyArrayObject* ary = NULL;
    PyObject*      py_obj;
    if (is_array(input) && (typecode == NPY_NOTYPE ||
                            PyArray_EquivTypenums(array_type(input),typecode)))
    {
      ary = (PyArrayObject*) input;
      *is_new_object = 0;
    }
    else
    {
      py_obj = PyArray_FROMANY(input, typecode, 0, 0, NPY_ARRAY_DEFAULT);
      /* If NULL, PyArray_FromObject will have set python error value.*/
      ary = (PyArrayObject*) py_obj;
      *is_new_object = 1;
    }
    return ary;
  }

  /* Given a PyArrayObject, check to see if it is contiguous.  If so,
   * return the input pointer and flag it as not a new object.  If it is
   * not contiguous, create a new PyArrayObject using the original data,
   * flag it as a new object and return the pointer.
   */
  PyArrayObject* make_contiguous(PyArrayObject* ary,
                                 int*           is_new_object,
                                 int            min_dims,
                                 int            max_dims)
  {
    PyArrayObject* result;
    if (array_is_contiguous(ary))
    {
      result = ary;
      *is_new_object = 0;
    }
    else
    {
      result = (PyArrayObject*) PyArray_ContiguousFromObject((PyObject*)ary,
                                                              array_type(ary),
                                                              min_dims,
                                                              max_dims);
      *is_new_object = 1;
    }
    return result;
  }

  /* Given a PyArrayObject, check to see if it is Fortran-contiguous.
   * If so, return the input pointer, but do not flag it as not a new
   * object.  If it is not Fortran-contiguous, create a new
   * PyArrayObject using the original data, flag it as a new object
   * and return the pointer.
   */
  PyArrayObject* make_fortran(PyArrayObject* ary,
                              int*           is_new_object)
  {
    PyArrayObject* result;
    if (array_is_fortran(ary))
    {
      result = ary;
      *is_new_object = 0;
    }
    else
    {
      Py_INCREF(array_descr(ary));
      result = (PyArrayObject*) PyArray_FromArray(ary,
                                                  array_descr(ary),
#if NPY_API_VERSION < 0x00000007
                                                  NPY_FORTRANORDER);
#else
                                                  NPY_ARRAY_F_CONTIGUOUS);
#endif
      *is_new_object = 1;
    }
    return result;
  }

  /* Convert a given PyObject to a contiguous PyArrayObject of the
   * specified type.  If the input object is not a contiguous
   * PyArrayObject, a new one will be created and the new object flag
   * will be set.
   */
  PyArrayObject* obj_to_array_contiguous_allow_conversion(PyObject* input,
                                                          int       typecode,
                                                          int*      is_new_object)
  {
    int is_new1 = 0;
    int is_new2 = 0;
    PyArrayObject* ary2;
    PyArrayObject* ary1 = obj_to_array_allow_conversion(input,
                                                        typecode,
                                                        &is_new1);
    if (ary1)
    {
      ary2 = make_contiguous(ary1, &is_new2, 0, 0);
      if ( is_new1 && is_new2)
      {
        Py_DECREF(ary1);
      }
      ary1 = ary2;
    }
    *is_new_object = is_new1 || is_new2;
    return ary1;
  }

  /* Convert a given PyObject to a Fortran-ordered PyArrayObject of the
   * specified type.  If the input object is not a Fortran-ordered
   * PyArrayObject, a new one will be created and the new object flag
   * will be set.
   */
  PyArrayObject* obj_to_array_fortran_allow_conversion(PyObject* input,
                                                       int       typecode,
                                                       int*      is_new_object)
  {
    int is_new1 = 0;
    int is_new2 = 0;
    PyArrayObject* ary2;
    PyArrayObject* ary1 = obj_to_array_allow_conversion(input,
                                                        typecode,
                                                        &is_new1);
    if (ary1)
    {
      ary2 = make_fortran(ary1, &is_new2);
      if (is_new1 && is_new2)
      {
        Py_DECREF(ary1);
      }
      ary1 = ary2;
    }
    *is_new_object = is_new1 || is_new2;
    return ary1;
  }
} /* end fragment */

/**********************************************************************/

%fragment("NumPy_Array_Requirements",
          "header",
          fragment="NumPy_Backward_Compatibility",
          fragment="NumPy_Macros")
{
  /* Test whether a python object is contiguous.  If array is
   * contiguous, return 1.  Otherwise, set the python error string and
   * return 0.
   */
  int require_contiguous(PyArrayObject* ary)
  {
    int contiguous = 1;
    if (!array_is_contiguous(ary))
    {
      PyErr_SetString(PyExc_TypeError,
                      "Array must be contiguous.  A non-contiguous array was given");
      contiguous = 0;
    }
    return contiguous;
  }

  /* Test whether a python object is (C_ or F_) contiguous.  If array is
   * contiguous, return 1.  Otherwise, set the python error string and
   * return 0.
   */
  int require_c_or_f_contiguous(PyArrayObject* ary)
  {
    int contiguous = 1;
    if (!(array_is_contiguous(ary) || array_is_fortran(ary)))
    {
      PyErr_SetString(PyExc_TypeError,
                      "Array must be contiguous (C_ or F_).  A non-contiguous array was given");
      contiguous = 0;
    }
    return contiguous;
  }

  /* Require that a numpy array is not byte-swapped.  If the array is
   * not byte-swapped, return 1.  Otherwise, set the python error string
   * and return 0.
   */
  int require_native(PyArrayObject* ary)
  {
    int native = 1;
    if (!array_is_native(ary))
    {
      PyErr_SetString(PyExc_TypeError,
                      "Array must have native byteorder.  "
                      "A byte-swapped array was given");
      native = 0;
    }
    return native;
  }

  /* Require the given PyArrayObject to have a specified number of
   * dimensions.  If the array has the specified number of dimensions,
   * return 1.  Otherwise, set the python error string and return 0.
   */
  int require_dimensions(PyArrayObject* ary,
                         int            exact_dimensions)
  {
    int success = 1;
    if (array_numdims(ary) != exact_dimensions)
    {
      PyErr_Format(PyExc_TypeError,
                   "Array must have %d dimensions.  Given array has %d dimensions",
                   exact_dimensions,
                   array_numdims(ary));
      success = 0;
    }
    return success;
  }

  /* Require the given PyArrayObject to have one of a list of specified
   * number of dimensions.  If the array has one of the specified number
   * of dimensions, return 1.  Otherwise, set the python error string
   * and return 0.
   */
  int require_dimensions_n(PyArrayObject* ary,
                           int*           exact_dimensions,
                           int            n)
  {
    int success = 0;
    int i;
    char dims_str[255] = "";
    char s[255];
    for (i = 0; i < n && !success; i++)
    {
      if (array_numdims(ary) == exact_dimensions[i])
      {
        success = 1;
      }
    }
    if (!success)
    {
      for (i = 0; i < n-1; i++)
      {
        sprintf(s, "%d, ", exact_dimensions[i]);
        strcat(dims_str,s);
      }
      sprintf(s, " or %d", exact_dimensions[n-1]);
      strcat(dims_str,s);
      PyErr_Format(PyExc_TypeError,
                   "Array must have %s dimensions.  Given array has %d dimensions",
                   dims_str,
                   array_numdims(ary));
    }
    return success;
  }

  /* Require the given PyArrayObject to have a specified shape.  If the
   * array has the specified shape, return 1.  Otherwise, set the python
   * error string and return 0.
   */
  int require_size(PyArrayObject* ary,
                   npy_intp*      size,
                   int            n)
  {
    int i;
    int success = 1;
    size_t len;
    char desired_dims[255] = "[";
    char s[255];
    char actual_dims[255] = "[";
    for(i=0; i < n;i++)
    {
      if (size[i] != -1 &&  size[i] != array_size(ary,i))
      {
        success = 0;
      }
    }
    if (!success)
    {
      for (i = 0; i < n; i++)
      {
        if (size[i] == -1)
        {
          sprintf(s, "*,");
        }
        else
        {
          sprintf(s, "%ld,", (long int)size[i]);
        }
        strcat(desired_dims,s);
      }
      len = strlen(desired_dims);
      desired_dims[len-1] = ']';
      for (i = 0; i < n; i++)
      {
        sprintf(s, "%ld,", (long int)array_size(ary,i));
        strcat(actual_dims,s);
      }
      len = strlen(actual_dims);
      actual_dims[len-1] = ']';
      PyErr_Format(PyExc_TypeError,
                   "Array must have shape of %s.  Given array has shape of %s",
                   desired_dims,
                   actual_dims);
    }
    return success;
  }

  /* Require the given PyArrayObject to to be Fortran ordered.  If the
   * the PyArrayObject is already Fortran ordered, do nothing.  Else,
   * set the Fortran ordering flag and recompute the strides.
   */
  int require_fortran(PyArrayObject* ary)
  {
    int success = 1;
    int nd = array_numdims(ary);
    int i;
    npy_intp * strides = array_strides(ary);
    if (array_is_fortran(ary)) return success;
    int n_non_one = 0;
    /* Set the Fortran ordered flag */
    const npy_intp *dims = array_dimensions(ary);
    for (i=0; i < nd; ++i)
      n_non_one += (dims[i] != 1) ? 1 : 0;
    if (n_non_one > 1)    
      array_clearflags(ary,NPY_ARRAY_CARRAY);
    array_enableflags(ary,NPY_ARRAY_FARRAY);
    /* Recompute the strides */
    strides[0] = strides[nd-1];
    for (i=1; i < nd; ++i)
      strides[i] = strides[i-1] * array_size(ary,i-1);
    return success;
  }
}

/* Combine all NumPy fragments into one for convenience */
%fragment("NumPy_Fragments",
          "header",
          fragment="NumPy_Backward_Compatibility",
          fragment="NumPy_Macros",
          fragment="NumPy_Utilities",
          fragment="NumPy_Object_to_Array",
          fragment="NumPy_Array_Requirements")
{
}

/* End John Hunter translation (with modifications by Bill Spotz)
 */

/* %numpy_typemaps() macro
 *
 * This macro defines a family of 75 typemaps that allow C arguments
 * of the form
 *
 *    1. (DATA_TYPE IN_ARRAY1[ANY])
 *    2. (DATA_TYPE* IN_ARRAY1, DIM_TYPE DIM1)
 *    3. (DIM_TYPE DIM1, DATA_TYPE* IN_ARRAY1)
 *
 *    4. (DATA_TYPE IN_ARRAY2[ANY][ANY])
 *    5. (DATA_TYPE* IN_ARRAY2, DIM_TYPE DIM1, DIM_TYPE DIM2)
 *    6. (DIM_TYPE DIM1, DIM_TYPE DIM2, DATA_TYPE* IN_ARRAY2)
 *    7. (DATA_TYPE* IN_FARRAY2, DIM_TYPE DIM1, DIM_TYPE DIM2)
 *    8. (DIM_TYPE DIM1, DIM_TYPE DIM2, DATA_TYPE* IN_FARRAY2)
 *
 *    9. (DATA_TYPE IN_ARRAY3[ANY][ANY][ANY])
 *   10. (DATA_TYPE* IN_ARRAY3, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3)
 *   11. (DATA_TYPE** IN_ARRAY3, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3)
 *   12. (DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DATA_TYPE* IN_ARRAY3)
 *   13. (DATA_TYPE* IN_FARRAY3, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3)
 *   14. (DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DATA_TYPE* IN_FARRAY3)
 *
 *   15. (DATA_TYPE IN_ARRAY4[ANY][ANY][ANY][ANY])
 *   16. (DATA_TYPE* IN_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4)
 *   17. (DATA_TYPE** IN_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4)
 *   18. (DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, , DIM_TYPE DIM4, DATA_TYPE* IN_ARRAY4)
 *   19. (DATA_TYPE* IN_FARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4)
 *   20. (DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4, DATA_TYPE* IN_FARRAY4)
 *
 *   21. (DATA_TYPE INPLACE_ARRAY1[ANY])
 *   22. (DATA_TYPE* INPLACE_ARRAY1, DIM_TYPE DIM1)
 *   23. (DIM_TYPE DIM1, DATA_TYPE* INPLACE_ARRAY1)
 *
 *   24. (DATA_TYPE INPLACE_ARRAY2[ANY][ANY])
 *   25. (DATA_TYPE* INPLACE_ARRAY2, DIM_TYPE DIM1, DIM_TYPE DIM2)
 *   26. (DIM_TYPE DIM1, DIM_TYPE DIM2, DATA_TYPE* INPLACE_ARRAY2)
 *   27. (DATA_TYPE* INPLACE_FARRAY2, DIM_TYPE DIM1, DIM_TYPE DIM2)
 *   28. (DIM_TYPE DIM1, DIM_TYPE DIM2, DATA_TYPE* INPLACE_FARRAY2)
 *
 *   29. (DATA_TYPE INPLACE_ARRAY3[ANY][ANY][ANY])
 *   30. (DATA_TYPE* INPLACE_ARRAY3, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3)
 *   31. (DATA_TYPE** INPLACE_ARRAY3, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3)
 *   32. (DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DATA_TYPE* INPLACE_ARRAY3)
 *   33. (DATA_TYPE* INPLACE_FARRAY3, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3)
 *   34. (DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DATA_TYPE* INPLACE_FARRAY3)
 *
 *   35. (DATA_TYPE INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 *   36. (DATA_TYPE* INPLACE_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4)
 *   37. (DATA_TYPE** INPLACE_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4)
 *   38. (DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4, DATA_TYPE* INPLACE_ARRAY4)
 *   39. (DATA_TYPE* INPLACE_FARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4)
 *   40. (DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4, DATA_TYPE* INPLACE_FARRAY4)
 *
 *   41. (DATA_TYPE ARGOUT_ARRAY1[ANY])
 *   42. (DATA_TYPE* ARGOUT_ARRAY1, DIM_TYPE DIM1)
 *   43. (DIM_TYPE DIM1, DATA_TYPE* ARGOUT_ARRAY1)
 *
 *   44. (DATA_TYPE ARGOUT_ARRAY2[ANY][ANY])
 *
 *   45. (DATA_TYPE ARGOUT_ARRAY3[ANY][ANY][ANY])
 *
 *   46. (DATA_TYPE ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 *
 *   47. (DATA_TYPE** ARGOUTVIEW_ARRAY1, DIM_TYPE* DIM1)
 *   48. (DIM_TYPE* DIM1, DATA_TYPE** ARGOUTVIEW_ARRAY1)
 *
 *   49. (DATA_TYPE** ARGOUTVIEW_ARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)
 *   50. (DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEW_ARRAY2)
 *   51. (DATA_TYPE** ARGOUTVIEW_FARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)
 *   52. (DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEW_FARRAY2)
 *
 *   53. (DATA_TYPE** ARGOUTVIEW_ARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3)
 *   54. (DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEW_ARRAY3)
 *   55. (DATA_TYPE** ARGOUTVIEW_FARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3)
 *   56. (DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEW_FARRAY3)
 *
 *   57. (DATA_TYPE** ARGOUTVIEW_ARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4)
 *   58. (DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE** ARGOUTVIEW_ARRAY4)
 *   59. (DATA_TYPE** ARGOUTVIEW_FARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4)
 *   60. (DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE** ARGOUTVIEW_FARRAY4)
 *
 *   61. (DATA_TYPE** ARGOUTVIEWM_ARRAY1, DIM_TYPE* DIM1)
 *   62. (DIM_TYPE* DIM1, DATA_TYPE** ARGOUTVIEWM_ARRAY1)
 *
 *   63. (DATA_TYPE** ARGOUTVIEWM_ARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)
 *   64. (DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEWM_ARRAY2)
 *   65. (DATA_TYPE** ARGOUTVIEWM_FARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)
 *   66. (DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEWM_FARRAY2)
 *
 *   67. (DATA_TYPE** ARGOUTVIEWM_ARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3)
 *   68. (DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEWM_ARRAY3)
 *   69. (DATA_TYPE** ARGOUTVIEWM_FARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3)
 *   70. (DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEWM_FARRAY3)
 *
 *   71. (DATA_TYPE** ARGOUTVIEWM_ARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4)
 *   72. (DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE** ARGOUTVIEWM_ARRAY4)
 *   73. (DATA_TYPE** ARGOUTVIEWM_FARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4)
 *   74. (DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE** ARGOUTVIEWM_FARRAY4)
 *
 *   75. (DATA_TYPE* INPLACE_ARRAY_FLAT, DIM_TYPE DIM_FLAT)
 *
 * where "DATA_TYPE" is any type supported by the NumPy module, and
 * "DIM_TYPE" is any int-like type suitable for specifying dimensions.
 * The difference between "ARRAY" typemaps and "FARRAY" typemaps is
 * that the "FARRAY" typemaps expect Fortran ordering of
 * multidimensional arrays.  In python, the dimensions will not need
 * to be specified (except for the "DATA_TYPE* ARGOUT_ARRAY1"
 * typemaps).  The IN_ARRAYs can be a numpy array or any sequence that
 * can be converted to a numpy array of the specified type.  The
 * INPLACE_ARRAYs must be numpy arrays of the appropriate type.  The
 * ARGOUT_ARRAYs will be returned as new numpy arrays of the
 * appropriate type.
 *
 * These typemaps can be applied to existing functions using the
 * %apply directive.  For example:
 *
 *     %apply (double* IN_ARRAY1, int DIM1) {(double* series, int length)};
 *     double prod(double* series, int length);
 *
 *     %apply (int DIM1, int DIM2, double* INPLACE_ARRAY2)
 *           {(int rows, int cols, double* matrix        )};
 *     void floor(int rows, int cols, double* matrix, double f);
 *
 *     %apply (double IN_ARRAY3[ANY][ANY][ANY])
 *           {(double tensor[2][2][2]         )};
 *     %apply (double ARGOUT_ARRAY3[ANY][ANY][ANY])
 *           {(double low[2][2][2]                )};
 *     %apply (double ARGOUT_ARRAY3[ANY][ANY][ANY])
 *           {(double upp[2][2][2]                )};
 *     void luSplit(double tensor[2][2][2],
 *                  double low[2][2][2],
 *                  double upp[2][2][2]    );
 *
 * or directly with
 *
 *     double prod(double* IN_ARRAY1, int DIM1);
 *
 *     void floor(int DIM1, int DIM2, double* INPLACE_ARRAY2, double f);
 *
 *     void luSplit(double IN_ARRAY3[ANY][ANY][ANY],
 *                  double ARGOUT_ARRAY3[ANY][ANY][ANY],
 *                  double ARGOUT_ARRAY3[ANY][ANY][ANY]);
 */
















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































    /* %numpy_typemaps() macro */
/* *************************************************************** */

/* Concrete instances of the %numpy_typemaps() macro: Each invocation
 * below applies all of the typemaps above to the specified data type.
 */
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (signed char IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (signed char IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (signed char* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (signed char* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, signed char* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, signed char* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, signed char* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (signed char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, signed char* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (signed char IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (signed char IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (signed char* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (signed char* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, signed char* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, signed char* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, signed char* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (signed char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, signed char* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (signed char* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_BYTE,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (signed char* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, signed char* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, signed char* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, signed char* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (signed char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, signed char* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (signed char IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (signed char IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (signed char* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (signed char* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (signed char** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (signed char** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (signed char **)malloc($2*sizeof(signed char *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_BYTE, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (signed char*) array_data(temp_array);
  }

  $1 = (signed char**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (signed char** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    signed char* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, signed char* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, signed char* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (signed char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, signed char* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (signed char* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_BYTE,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (signed char* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    signed char* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, signed char* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, signed char* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (signed char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, signed char* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (signed char IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (signed char IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (signed char* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (signed char* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (signed char** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (signed char** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (signed char **)malloc($2*sizeof(signed char *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_BYTE, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (signed char*) array_data(temp_array);
  }

  $1 = (signed char**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (signed char** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    signed char* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, signed char* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, signed char* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (signed char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, signed char* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (signed char* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_BYTE,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (signed char* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    signed char* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, signed char* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, signed char* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_BYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (signed char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, signed char* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (signed char INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (signed char* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, signed char* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, signed char* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, signed char* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (signed char*) array_data(array);
}

/* Typemap suite for (signed char INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (signed char* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, signed char* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, signed char* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, signed char* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (signed char*) array_data(array);
}

/* Typemap suite for (signed char* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, signed char* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, signed char* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, signed char* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (signed char*) array_data(array);
}

/* Typemap suite for (signed char INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (signed char* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (signed char** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (signed char** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (signed char **)malloc($2*sizeof(signed char *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_BYTE);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_BYTE)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (signed char*) array_data(temp_array);
  }

  $1 = (signed char**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (signed char** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    signed char* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, signed char* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, signed char* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (signed char*) array_data(array);
}

/* Typemap suite for (signed char* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    signed char* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, signed char* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, signed char* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (signed char*) array_data(array);
}

/* Typemap suite for (signed char INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (signed char* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (signed char** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (signed char** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (signed char **)malloc($2*sizeof(signed char *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_BYTE);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_BYTE)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (signed char*) array_data(temp_array);
  }

  $1 = (signed char**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (signed char** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    signed char* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, signed char* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, signed char* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (signed char*) array_data(array);
}

/* Typemap suite for (signed char* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    signed char* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, signed char* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, signed char* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (signed char*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (signed char ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (signed char ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_BYTE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (signed char ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (signed char* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (signed char* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_BYTE);
  if (!array) SWIG_fail;
  $1 = (signed char*) array_data(array);
}
%typemap(argout)
  (signed char* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, signed char* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, signed char* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_BYTE);
  if (!array) SWIG_fail;
  $2 = (signed char*) array_data(array);
}
%typemap(argout)
  (int DIM1, signed char* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (signed char ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (signed char ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_BYTE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (signed char ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (signed char ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (signed char ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_BYTE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (signed char ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (signed char ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (signed char ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_BYTE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (signed char ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (signed char** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (signed char*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (signed char** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, signed char** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , signed char** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, signed char*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, signed char** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_BYTE, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (signed char*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (signed char** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, signed char** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , signed char** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, signed char*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, signed char** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_BYTE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (signed char*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (signed char** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, signed char** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , signed char** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, signed char*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, signed char** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_BYTE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (signed char* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (signed char** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      signed char** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, signed char** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, signed char* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, signed char** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_BYTE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (signed char* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (signed char** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      signed char** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , signed char** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, signed char* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, signed char** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_BYTE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (signed char* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (signed char** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      signed char** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , signed char** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, signed char* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, signed char** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_BYTE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (signed char* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (signed char** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      signed char** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , signed char** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, signed char* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, signed char** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_BYTE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (signed char** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (signed char*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (signed char** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, signed char** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , signed char** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, signed char*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, signed char** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_BYTE, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (signed char*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (signed char** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, signed char** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , signed char** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, signed char*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, signed char** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_BYTE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (signed char*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (signed char** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, signed char** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , signed char** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, signed char*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, signed char** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_BYTE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (signed char* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (signed char** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      signed char** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , signed char** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, signed char* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, signed char** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_BYTE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (signed char* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (signed char** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      signed char** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , signed char** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, signed char* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, signed char** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_BYTE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (signed char* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (signed char** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      signed char** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , signed char** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, signed char* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, signed char** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_BYTE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (signed char* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (signed char** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      signed char** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , signed char** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, signed char* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, signed char** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_BYTE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (signed char* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (signed char** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      signed char** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , signed char** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, signed char* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, signed char** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_BYTE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (signed char** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (signed char** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (signed char* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (signed char** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_BYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      signed char** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , signed char** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, signed char* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, signed char** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_BYTE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (signed char* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (signed char* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_BYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (signed char* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_BYTE);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (signed char*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (unsigned char IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned char IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned char* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (unsigned char* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, unsigned char* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, unsigned char* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned char* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (unsigned char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, unsigned char* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned char IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned char IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned char* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (unsigned char* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, unsigned char* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned char* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned char* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, unsigned char* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned char* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_UBYTE,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (unsigned char* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, unsigned char* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned char* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned char* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, unsigned char* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned char IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned char IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned char* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (unsigned char* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned char** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (unsigned char** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned char **)malloc($2*sizeof(unsigned char *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_UBYTE, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (unsigned char*) array_data(temp_array);
  }

  $1 = (unsigned char**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (unsigned char** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned char* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned char* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned char* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, unsigned char* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned char* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UBYTE,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (unsigned char* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned char* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned char* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned char* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, unsigned char* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned char IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned char IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned char* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (unsigned char* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned char** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (unsigned char** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned char **)malloc($2*sizeof(unsigned char *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_UBYTE, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (unsigned char*) array_data(temp_array);
  }

  $1 = (unsigned char**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (unsigned char** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned char* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned char* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned char* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned char* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned char* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UBYTE,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (unsigned char* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned char* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned char* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned char* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UBYTE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned char*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned char* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (unsigned char INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned char* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, unsigned char* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, unsigned char* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned char* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (unsigned char*) array_data(array);
}

/* Typemap suite for (unsigned char INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned char* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, unsigned char* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned char* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned char* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned char*) array_data(array);
}

/* Typemap suite for (unsigned char* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, unsigned char* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned char* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned char* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned char*) array_data(array);
}

/* Typemap suite for (unsigned char INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned char* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (unsigned char** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (unsigned char** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned char **)malloc($2*sizeof(unsigned char *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_UBYTE);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_UBYTE)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (unsigned char*) array_data(temp_array);
  }

  $1 = (unsigned char**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (unsigned char** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned char* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned char* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned char* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned char*) array_data(array);
}

/* Typemap suite for (unsigned char* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned char* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned char* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned char* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned char*) array_data(array);
}

/* Typemap suite for (unsigned char INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned char* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (unsigned char** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (unsigned char** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned char **)malloc($2*sizeof(unsigned char *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_UBYTE);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_UBYTE)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (unsigned char*) array_data(temp_array);
  }

  $1 = (unsigned char**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (unsigned char** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned char* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned char* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned char* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned char*) array_data(array);
}

/* Typemap suite for (unsigned char* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned char* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned char* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned char* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned char*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (unsigned char ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned char ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_UBYTE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned char ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned char* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (unsigned char* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_UBYTE);
  if (!array) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
}
%typemap(argout)
  (unsigned char* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, unsigned char* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned char* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_UBYTE);
  if (!array) SWIG_fail;
  $2 = (unsigned char*) array_data(array);
}
%typemap(argout)
  (int DIM1, unsigned char* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned char ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned char ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_UBYTE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned char ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned char ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned char ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_UBYTE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned char ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned char ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned char ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_UBYTE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned char ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (unsigned char** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (unsigned char*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned char** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, unsigned char** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , unsigned char** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, unsigned char*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, unsigned char** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UBYTE, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (unsigned char*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned char** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned char** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned char** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned char*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, unsigned char** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UBYTE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (unsigned char*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned char** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned char** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned char** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned char*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, unsigned char** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UBYTE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned char* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned char** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned char** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, unsigned char** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned char* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, unsigned char** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UBYTE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned char* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned char** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned char** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned char** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned char* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, unsigned char** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UBYTE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned char* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned char** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned char** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned char** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned char* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned char** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UBYTE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned char* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned char** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned char** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned char** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned char* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned char** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UBYTE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (unsigned char** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (unsigned char*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned char** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, unsigned char** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , unsigned char** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, unsigned char*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, unsigned char** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UBYTE, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (unsigned char*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned char** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned char** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned char** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned char*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, unsigned char** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UBYTE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (unsigned char*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned char** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned char** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned char** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned char*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, unsigned char** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UBYTE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned char* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned char** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned char** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned char** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned char* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, unsigned char** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_UBYTE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned char* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned char** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned char** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned char** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned char* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, unsigned char** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UBYTE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned char* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned char** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned char** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned char** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned char* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned char** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UBYTE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned char* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned char** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned char** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned char** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned char* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned char** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UBYTE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned char* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned char** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned char** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned char** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned char* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned char** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UBYTE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned char** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned char** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned char* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned char** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UBYTE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned char** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned char** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned char* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned char** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UBYTE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (unsigned char* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned char* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UBYTE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned char* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_UBYTE);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned char*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (short IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (short IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (short* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (short* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, short* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, short* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, short* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, short* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (short IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (short IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (short* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (short* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, short* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, short* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, short* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, short* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (short* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_SHORT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (short* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, short* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, short* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, short* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, short* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (short IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (short IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (short* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (short* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (short** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (short** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (short **)malloc($2*sizeof(short *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_SHORT, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (short*) array_data(temp_array);
  }

  $1 = (short**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (short** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    short* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, short* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, short* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, short* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (short* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_SHORT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (short* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    short* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, short* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, short* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, short* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (short IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (short IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (short* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (short* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (short** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (short** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (short **)malloc($2*sizeof(short *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_SHORT, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (short*) array_data(temp_array);
  }

  $1 = (short**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (short** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    short* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, short* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, short* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, short* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (short* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_SHORT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (short* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    short* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, short* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, short* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_SHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, short* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (short INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (short* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, short* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, short* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, short* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (short*) array_data(array);
}

/* Typemap suite for (short INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (short* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, short* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, short* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, short* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (short*) array_data(array);
}

/* Typemap suite for (short* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, short* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, short* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, short* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (short*) array_data(array);
}

/* Typemap suite for (short INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (short* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (short** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (short** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (short **)malloc($2*sizeof(short *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_SHORT);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_SHORT)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (short*) array_data(temp_array);
  }

  $1 = (short**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (short** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    short* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, short* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, short* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (short*) array_data(array);
}

/* Typemap suite for (short* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    short* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, short* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, short* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (short*) array_data(array);
}

/* Typemap suite for (short INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (short* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (short** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (short** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (short **)malloc($2*sizeof(short *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_SHORT);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_SHORT)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (short*) array_data(temp_array);
  }

  $1 = (short**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (short** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    short* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, short* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, short* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (short*) array_data(array);
}

/* Typemap suite for (short* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    short* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, short* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, short* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (short*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (short ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (short ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_SHORT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (short ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (short* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (short* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_SHORT);
  if (!array) SWIG_fail;
  $1 = (short*) array_data(array);
}
%typemap(argout)
  (short* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, short* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, short* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_SHORT);
  if (!array) SWIG_fail;
  $2 = (short*) array_data(array);
}
%typemap(argout)
  (int DIM1, short* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (short ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (short ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_SHORT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (short ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (short ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (short ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_SHORT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (short ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (short ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (short ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_SHORT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (short ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (short** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (short*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (short** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, short** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , short** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, short*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, short** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_SHORT, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (short*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (short** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, short** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , short** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, short*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, short** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_SHORT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (short*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (short** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, short** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , short** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, short*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, short** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_SHORT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (short* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (short** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      short** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, short** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, short* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, short** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_SHORT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (short* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (short** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      short** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , short** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, short* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, short** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_SHORT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (short* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (short** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      short** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , short** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, short* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, short** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_SHORT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (short* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (short** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      short** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , short** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, short* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, short** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_SHORT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (short** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (short*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (short** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, short** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , short** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, short*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, short** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_SHORT, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (short*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (short** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, short** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , short** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, short*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, short** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_SHORT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (short*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (short** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, short** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , short** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, short*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, short** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_SHORT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (short* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (short** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      short** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , short** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, short* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, short** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_SHORT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (short* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (short** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      short** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , short** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, short* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, short** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_SHORT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (short* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (short** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      short** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , short** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, short* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, short** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_SHORT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (short* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (short** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      short** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , short** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, short* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, short** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_SHORT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (short* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (short** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      short** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , short** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, short* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, short** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_SHORT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (short** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (short** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (short* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (short** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_SHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      short** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , short** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, short* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, short** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_SHORT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (short* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (short* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_SHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (short* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_SHORT);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (short*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (unsigned short IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned short IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned short* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (unsigned short* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, unsigned short* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, unsigned short* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned short* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (unsigned short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, unsigned short* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned short IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned short IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned short* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (unsigned short* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, unsigned short* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned short* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned short* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, unsigned short* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned short* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_USHORT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (unsigned short* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, unsigned short* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned short* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned short* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, unsigned short* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned short IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned short IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned short* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (unsigned short* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned short** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (unsigned short** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned short **)malloc($2*sizeof(unsigned short *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_USHORT, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (unsigned short*) array_data(temp_array);
  }

  $1 = (unsigned short**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (unsigned short** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned short* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned short* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned short* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, unsigned short* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned short* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_USHORT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (unsigned short* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned short* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned short* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned short* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, unsigned short* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned short IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned short IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned short* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (unsigned short* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned short** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (unsigned short** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned short **)malloc($2*sizeof(unsigned short *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_USHORT, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (unsigned short*) array_data(temp_array);
  }

  $1 = (unsigned short**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (unsigned short** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned short* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned short* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned short* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned short* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned short* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_USHORT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (unsigned short* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned short* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned short* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned short* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_USHORT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned short*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned short* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (unsigned short INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned short* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, unsigned short* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, unsigned short* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned short* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (unsigned short*) array_data(array);
}

/* Typemap suite for (unsigned short INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned short* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, unsigned short* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned short* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned short* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned short*) array_data(array);
}

/* Typemap suite for (unsigned short* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, unsigned short* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned short* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned short* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned short*) array_data(array);
}

/* Typemap suite for (unsigned short INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned short* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (unsigned short** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (unsigned short** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned short **)malloc($2*sizeof(unsigned short *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_USHORT);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_USHORT)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (unsigned short*) array_data(temp_array);
  }

  $1 = (unsigned short**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (unsigned short** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned short* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned short* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned short* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned short*) array_data(array);
}

/* Typemap suite for (unsigned short* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned short* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned short* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned short* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned short*) array_data(array);
}

/* Typemap suite for (unsigned short INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned short* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (unsigned short** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (unsigned short** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned short **)malloc($2*sizeof(unsigned short *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_USHORT);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_USHORT)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (unsigned short*) array_data(temp_array);
  }

  $1 = (unsigned short**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (unsigned short** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned short* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned short* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned short* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned short*) array_data(array);
}

/* Typemap suite for (unsigned short* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned short* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned short* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned short* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned short*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (unsigned short ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned short ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_USHORT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned short ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned short* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (unsigned short* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_USHORT);
  if (!array) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
}
%typemap(argout)
  (unsigned short* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, unsigned short* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned short* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_USHORT);
  if (!array) SWIG_fail;
  $2 = (unsigned short*) array_data(array);
}
%typemap(argout)
  (int DIM1, unsigned short* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned short ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned short ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_USHORT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned short ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned short ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned short ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_USHORT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned short ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned short ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned short ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_USHORT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned short ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (unsigned short** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (unsigned short*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned short** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, unsigned short** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , unsigned short** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, unsigned short*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, unsigned short** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_USHORT, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (unsigned short*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned short** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned short** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned short** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned short*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, unsigned short** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_USHORT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (unsigned short*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned short** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned short** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned short** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned short*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, unsigned short** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_USHORT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned short* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned short** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned short** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, unsigned short** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned short* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, unsigned short** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_USHORT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned short* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned short** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned short** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned short** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned short* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, unsigned short** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_USHORT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned short* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned short** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned short** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned short** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned short* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned short** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_USHORT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned short* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned short** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned short** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned short** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned short* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned short** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_USHORT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (unsigned short** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (unsigned short*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned short** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, unsigned short** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , unsigned short** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, unsigned short*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, unsigned short** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_USHORT, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (unsigned short*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned short** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned short** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned short** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned short*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, unsigned short** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_USHORT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (unsigned short*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned short** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned short** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned short** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned short*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, unsigned short** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_USHORT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned short* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned short** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned short** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned short** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned short* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, unsigned short** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_USHORT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned short* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned short** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned short** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned short** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned short* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, unsigned short** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_USHORT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned short* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned short** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned short** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned short** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned short* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned short** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_USHORT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned short* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned short** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned short** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned short** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned short* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned short** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_USHORT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned short* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned short** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned short** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned short** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned short* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned short** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_USHORT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned short** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned short** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned short* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned short** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_USHORT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned short** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned short** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned short* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned short** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_USHORT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (unsigned short* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned short* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_USHORT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned short* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_USHORT);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned short*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (int IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (int* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (int* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_INT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (int* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (int* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (int** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int **)malloc($2*sizeof(int *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_INT, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (int*) array_data(temp_array);
  }

  $1 = (int**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (int** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (int* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (int* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (int** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int **)malloc($2*sizeof(int *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_INT, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (int*) array_data(temp_array);
  }

  $1 = (int**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (int** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, int* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (int* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, int* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (int INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, int* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (int*) array_data(array);
}

/* Typemap suite for (int INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, int* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int*) array_data(array);
}

/* Typemap suite for (int* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, int* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int*) array_data(array);
}

/* Typemap suite for (int INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (int** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int **)malloc($2*sizeof(int *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_INT);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_INT)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (int*) array_data(temp_array);
  }

  $1 = (int**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (int** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int*) array_data(array);
}

/* Typemap suite for (int* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int*) array_data(array);
}

/* Typemap suite for (int INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (int** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int **)malloc($2*sizeof(int *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_INT);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_INT)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (int*) array_data(temp_array);
  }

  $1 = (int**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (int** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int*) array_data(array);
}

/* Typemap suite for (int* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (int ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_INT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_INT);
  if (!array) SWIG_fail;
  $1 = (int*) array_data(array);
}
%typemap(argout)
  (int* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, int* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, int* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_INT);
  if (!array) SWIG_fail;
  $2 = (int*) array_data(array);
}
%typemap(argout)
  (int DIM1, int* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_INT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_INT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_INT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (int** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (int*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, int*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (int*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, int*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (int*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, int*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, int** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (int** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (int*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, int*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (int*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, int*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (int*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, int*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_INT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (int* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_INT);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (unsigned int IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned int IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned int* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (unsigned int* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, unsigned int* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, unsigned int* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned int* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (unsigned int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, unsigned int* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned int IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned int IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned int* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (unsigned int* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, unsigned int* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned int* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned int* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, unsigned int* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned int* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_UINT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (unsigned int* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, unsigned int* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned int* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned int* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, unsigned int* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned int IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned int IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned int* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (unsigned int* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned int** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (unsigned int** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned int **)malloc($2*sizeof(unsigned int *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_UINT, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (unsigned int*) array_data(temp_array);
  }

  $1 = (unsigned int**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (unsigned int** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned int* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned int* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned int* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, unsigned int* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned int* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (unsigned int* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned int* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned int* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned int* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, unsigned int* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned int IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned int IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned int* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (unsigned int* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned int** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (unsigned int** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned int **)malloc($2*sizeof(unsigned int *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_UINT, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (unsigned int*) array_data(temp_array);
  }

  $1 = (unsigned int**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (unsigned int** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned int* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned int* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned int* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned int* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned int* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (unsigned int* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned int* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned int* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned int* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned int*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned int* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (unsigned int INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned int* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, unsigned int* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, unsigned int* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned int* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (unsigned int*) array_data(array);
}

/* Typemap suite for (unsigned int INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned int* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, unsigned int* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned int* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned int* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned int*) array_data(array);
}

/* Typemap suite for (unsigned int* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, unsigned int* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned int* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned int* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned int*) array_data(array);
}

/* Typemap suite for (unsigned int INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned int* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (unsigned int** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (unsigned int** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned int **)malloc($2*sizeof(unsigned int *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_UINT);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_UINT)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (unsigned int*) array_data(temp_array);
  }

  $1 = (unsigned int**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (unsigned int** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned int* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned int* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned int* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned int*) array_data(array);
}

/* Typemap suite for (unsigned int* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned int* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned int* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned int* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned int*) array_data(array);
}

/* Typemap suite for (unsigned int INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned int* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (unsigned int** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (unsigned int** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned int **)malloc($2*sizeof(unsigned int *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_UINT);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_UINT)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (unsigned int*) array_data(temp_array);
  }

  $1 = (unsigned int**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (unsigned int** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned int* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned int* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned int* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned int*) array_data(array);
}

/* Typemap suite for (unsigned int* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned int* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned int* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned int* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned int*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (unsigned int ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned int ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_UINT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned int ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned int* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (unsigned int* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_UINT);
  if (!array) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
}
%typemap(argout)
  (unsigned int* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, unsigned int* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned int* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_UINT);
  if (!array) SWIG_fail;
  $2 = (unsigned int*) array_data(array);
}
%typemap(argout)
  (int DIM1, unsigned int* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned int ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned int ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_UINT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned int ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned int ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned int ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_UINT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned int ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned int ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned int ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_UINT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned int ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (unsigned int** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (unsigned int*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned int** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, unsigned int** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , unsigned int** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, unsigned int*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, unsigned int** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (unsigned int*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned int** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned int** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned int** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned int*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, unsigned int** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (unsigned int*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned int** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned int** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned int** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned int*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, unsigned int** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned int* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned int** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned int** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, unsigned int** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned int* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, unsigned int** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned int* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned int** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned int** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned int** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned int* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, unsigned int** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned int* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned int** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned int** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned int** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned int* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned int** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned int* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned int** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned int** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned int** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned int* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned int** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (unsigned int** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (unsigned int*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned int** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, unsigned int** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , unsigned int** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, unsigned int*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, unsigned int** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (unsigned int*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned int** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned int** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned int** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned int*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, unsigned int** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (unsigned int*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned int** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned int** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned int** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned int*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, unsigned int** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned int* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned int** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned int** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned int** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned int* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, unsigned int** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_UINT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned int* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned int** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned int** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned int** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned int* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, unsigned int** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned int* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned int** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned int** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned int** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned int* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned int** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned int* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned int** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned int** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned int** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned int* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned int** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned int* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned int** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned int** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned int** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned int* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned int** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned int** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned int** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned int* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned int** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned int** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned int** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned int* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned int** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (unsigned int* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned int* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned int* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_UINT);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned int*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (long IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (long IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (long* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, long* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, long* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, long* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, long* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (long IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (long* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, long* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, long* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, long* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, long* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_LONG,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (long* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, long* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, long* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, long* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, long* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (long IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (long* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (long** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (long **)malloc($2*sizeof(long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_LONG, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (long*) array_data(temp_array);
  }

  $1 = (long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (long** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    long* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, long* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, long* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, long* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_LONG,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (long* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    long* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, long* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, long* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, long* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (long IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (long* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (long** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (long **)malloc($2*sizeof(long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_LONG, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (long*) array_data(temp_array);
  }

  $1 = (long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (long** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    long* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, long* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, long* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, long* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_LONG,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (long* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    long* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, long* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, long* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_LONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, long* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (long INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (long* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, long* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, long* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, long* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (long*) array_data(array);
}

/* Typemap suite for (long INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (long* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, long* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, long* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, long* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (long*) array_data(array);
}

/* Typemap suite for (long* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, long* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, long* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, long* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (long*) array_data(array);
}

/* Typemap suite for (long INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (long* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (long** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (long** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (long **)malloc($2*sizeof(long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_LONG);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_LONG)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (long*) array_data(temp_array);
  }

  $1 = (long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (long** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    long* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, long* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, long* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (long*) array_data(array);
}

/* Typemap suite for (long* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    long* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, long* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, long* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (long*) array_data(array);
}

/* Typemap suite for (long INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (long* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (long** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (long** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (long **)malloc($2*sizeof(long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_LONG);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_LONG)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (long*) array_data(temp_array);
  }

  $1 = (long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (long** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    long* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, long* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, long* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (long*) array_data(array);
}

/* Typemap suite for (long* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    long* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, long* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, long* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (long*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (long ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (long ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_LONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (long ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (long* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (long* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_LONG);
  if (!array) SWIG_fail;
  $1 = (long*) array_data(array);
}
%typemap(argout)
  (long* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, long* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, long* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_LONG);
  if (!array) SWIG_fail;
  $2 = (long*) array_data(array);
}
%typemap(argout)
  (int DIM1, long* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (long ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (long ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_LONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (long ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (long ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (long ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_LONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (long ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (long ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (long ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_LONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (long ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (long** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (long*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (long** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, long** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , long** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, long*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, long** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_LONG, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (long*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (long** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, long** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , long** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, long*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, long** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (long*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (long** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, long** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , long** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, long*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, long** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (long* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (long** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      long** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, long** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, long* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, long** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (long** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      long** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , long** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, long** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (long* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (long** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      long** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , long** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, long* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, long** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (long** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      long** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , long** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, long** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (long** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (long*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (long** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, long** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , long** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, long*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, long** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_LONG, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (long*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (long** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, long** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , long** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, long*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, long** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (long*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (long** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, long** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , long** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, long*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, long** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (long** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      long** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , long** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, long** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_LONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (long* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (long** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      long** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , long** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, long* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, long** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      long** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , long** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, long** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (long* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      long** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , long** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, long* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, long** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      long** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , long** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, long** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (long** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (long* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      long** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , long** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, long* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, long** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (long* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_LONG);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (long*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (unsigned long IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned long IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (unsigned long* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, unsigned long* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, unsigned long* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned long* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (unsigned long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, unsigned long* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned long IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (unsigned long* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, unsigned long* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned long* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned long* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, unsigned long* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_ULONG,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (unsigned long* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, unsigned long* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned long* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned long* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, unsigned long* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned long IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (unsigned long* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (unsigned long** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned long **)malloc($2*sizeof(unsigned long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_ULONG, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (unsigned long*) array_data(temp_array);
  }

  $1 = (unsigned long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (unsigned long** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned long* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned long* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned long* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, unsigned long* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_ULONG,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (unsigned long* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned long* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned long* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned long* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, unsigned long* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned long IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (unsigned long* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (unsigned long** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned long **)malloc($2*sizeof(unsigned long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_ULONG, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (unsigned long*) array_data(temp_array);
  }

  $1 = (unsigned long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (unsigned long** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned long* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_ULONG,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (unsigned long* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned long* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_ULONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (unsigned long INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned long* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, unsigned long* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, unsigned long* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned long* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (unsigned long*) array_data(array);
}

/* Typemap suite for (unsigned long INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned long* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, unsigned long* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned long* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned long* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned long*) array_data(array);
}

/* Typemap suite for (unsigned long* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, unsigned long* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned long* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned long* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned long*) array_data(array);
}

/* Typemap suite for (unsigned long INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned long* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (unsigned long** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (unsigned long** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned long **)malloc($2*sizeof(unsigned long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_ULONG);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_ULONG)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (unsigned long*) array_data(temp_array);
  }

  $1 = (unsigned long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (unsigned long** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned long* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned long* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned long* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned long*) array_data(array);
}

/* Typemap suite for (unsigned long* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned long* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned long* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned long* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned long*) array_data(array);
}

/* Typemap suite for (unsigned long INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned long* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (unsigned long** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (unsigned long** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned long **)malloc($2*sizeof(unsigned long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_ULONG);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_ULONG)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (unsigned long*) array_data(temp_array);
  }

  $1 = (unsigned long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (unsigned long** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned long* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned long*) array_data(array);
}

/* Typemap suite for (unsigned long* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned long* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned long*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (unsigned long ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned long ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_ULONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned long ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned long* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (unsigned long* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_ULONG);
  if (!array) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
}
%typemap(argout)
  (unsigned long* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, unsigned long* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned long* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_ULONG);
  if (!array) SWIG_fail;
  $2 = (unsigned long*) array_data(array);
}
%typemap(argout)
  (int DIM1, unsigned long* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned long ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned long ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_ULONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned long ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned long ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned long ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_ULONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned long ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned long ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned long ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_ULONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned long ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (unsigned long** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (unsigned long*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned long** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, unsigned long** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , unsigned long** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, unsigned long*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, unsigned long** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_ULONG, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (unsigned long*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned long** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned long** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned long** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned long*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, unsigned long** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (unsigned long*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned long** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned long** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned long** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned long*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, unsigned long** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned long* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned long** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned long** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, unsigned long** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned long* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, unsigned long** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned long** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned long** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned long** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, unsigned long** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned long* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned long** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned long** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned long** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned long* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned long** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned long** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned long** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned long** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned long** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (unsigned long** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (unsigned long*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned long** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, unsigned long** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , unsigned long** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, unsigned long*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, unsigned long** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_ULONG, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (unsigned long*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned long** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned long** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned long** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned long*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, unsigned long** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (unsigned long*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned long** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned long** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned long** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned long*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, unsigned long** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned long** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned long** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned long** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, unsigned long** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_ULONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned long* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned long** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned long** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned long** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned long* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, unsigned long** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned long** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned long** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned long** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned long* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned long** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned long** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned long* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned long** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned long** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned long** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned long** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned long** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned long* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned long** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned long** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned long* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned long** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (unsigned long* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_ULONG);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned long*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (long long IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (long long IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long long* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (long long* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, long long* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, long long* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, long long* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, long long* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long long IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (long long IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long long* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (long long* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, long long* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, long long* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, long long* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, long long* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long long* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_LONGLONG,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (long long* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, long long* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, long long* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, long long* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, long long* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long long IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (long long IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long long* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (long long* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long long** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (long long** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (long long **)malloc($2*sizeof(long long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_LONGLONG, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (long long*) array_data(temp_array);
  }

  $1 = (long long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (long long** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    long long* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, long long* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, long long* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, long long* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long long* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_LONGLONG,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (long long* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    long long* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, long long* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, long long* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, long long* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long long IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (long long IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long long* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (long long* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long long** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (long long** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (long long **)malloc($2*sizeof(long long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_LONGLONG, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (long long*) array_data(temp_array);
  }

  $1 = (long long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (long long** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    long long* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, long long* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, long long* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, long long* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (long long* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_LONGLONG,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (long long* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    long long* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, long long* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, long long* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_LONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, long long* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (long long INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (long long* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, long long* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, long long* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, long long* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (long long*) array_data(array);
}

/* Typemap suite for (long long INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (long long* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, long long* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, long long* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, long long* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (long long*) array_data(array);
}

/* Typemap suite for (long long* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, long long* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, long long* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, long long* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (long long*) array_data(array);
}

/* Typemap suite for (long long INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (long long* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (long long** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (long long** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (long long **)malloc($2*sizeof(long long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_LONGLONG);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_LONGLONG)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (long long*) array_data(temp_array);
  }

  $1 = (long long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (long long** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    long long* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, long long* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, long long* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (long long*) array_data(array);
}

/* Typemap suite for (long long* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    long long* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, long long* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, long long* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (long long*) array_data(array);
}

/* Typemap suite for (long long INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (long long* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (long long** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (long long** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (long long **)malloc($2*sizeof(long long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_LONGLONG);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_LONGLONG)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (long long*) array_data(temp_array);
  }

  $1 = (long long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (long long** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    long long* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, long long* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, long long* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (long long*) array_data(array);
}

/* Typemap suite for (long long* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    long long* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, long long* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, long long* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (long long*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (long long ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (long long ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_LONGLONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (long long ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (long long* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (long long* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_LONGLONG);
  if (!array) SWIG_fail;
  $1 = (long long*) array_data(array);
}
%typemap(argout)
  (long long* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, long long* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, long long* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_LONGLONG);
  if (!array) SWIG_fail;
  $2 = (long long*) array_data(array);
}
%typemap(argout)
  (int DIM1, long long* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (long long ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (long long ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_LONGLONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (long long ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (long long ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (long long ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_LONGLONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (long long ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (long long ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (long long ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_LONGLONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (long long ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (long long** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (long long*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (long long** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, long long** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , long long** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, long long*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, long long** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_LONGLONG, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (long long*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (long long** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, long long** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , long long** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, long long*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, long long** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONGLONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (long long*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (long long** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, long long** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , long long** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, long long*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, long long** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONGLONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (long long* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (long long** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      long long** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, long long** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, long long* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, long long** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONGLONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (long long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (long long** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      long long** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , long long** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, long long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, long long** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONGLONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (long long* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (long long** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      long long** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , long long** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, long long* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, long long** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONGLONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (long long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (long long** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      long long** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , long long** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, long long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, long long** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONGLONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (long long** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (long long*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (long long** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, long long** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , long long** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, long long*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, long long** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_LONGLONG, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (long long*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (long long** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, long long** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , long long** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, long long*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, long long** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONGLONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (long long*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (long long** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, long long** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , long long** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, long long*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, long long** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_LONGLONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (long long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (long long** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      long long** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , long long** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, long long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, long long** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_LONGLONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (long long* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (long long** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      long long** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , long long** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, long long* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, long long** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_LONGLONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (long long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (long long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      long long** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , long long** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, long long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, long long** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONGLONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (long long* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (long long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      long long** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , long long** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, long long* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, long long** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONGLONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (long long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (long long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      long long** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , long long** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, long long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, long long** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONGLONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (long long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (long long** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (long long* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (long long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      long long** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , long long** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, long long* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, long long** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_LONGLONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (long long* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (long long* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_LONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (long long* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_LONGLONG);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (long long*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (unsigned long long IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned long long IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long long* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (unsigned long long* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, unsigned long long* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, unsigned long long* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned long long* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (unsigned long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, unsigned long long* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long long IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned long long IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long long* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (unsigned long long* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, unsigned long long* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned long long* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned long long* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, unsigned long long* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long long* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_ULONGLONG,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (unsigned long long* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, unsigned long long* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned long long* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned long long* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, unsigned long long* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long long IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned long long IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long long* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (unsigned long long* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long long** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (unsigned long long** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned long long **)malloc($2*sizeof(unsigned long long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_ULONGLONG, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (unsigned long long*) array_data(temp_array);
  }

  $1 = (unsigned long long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (unsigned long long** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned long long* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned long long* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned long long* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, unsigned long long* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long long* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_ULONGLONG,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (unsigned long long* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned long long* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned long long* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned long long* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, unsigned long long* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long long IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (unsigned long long IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long long* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (unsigned long long* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long long** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (unsigned long long** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned long long **)malloc($2*sizeof(unsigned long long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_ULONGLONG, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (unsigned long long*) array_data(temp_array);
  }

  $1 = (unsigned long long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (unsigned long long** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned long long* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long long* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long long* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long long* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (unsigned long long* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_ULONGLONG,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (unsigned long long* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned long long* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long long* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long long* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_ULONGLONG,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned long long*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long long* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (unsigned long long INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned long long* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, unsigned long long* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, unsigned long long* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned long long* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (unsigned long long*) array_data(array);
}

/* Typemap suite for (unsigned long long INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned long long* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, unsigned long long* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned long long* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned long long* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned long long*) array_data(array);
}

/* Typemap suite for (unsigned long long* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, unsigned long long* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, unsigned long long* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, unsigned long long* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (unsigned long long*) array_data(array);
}

/* Typemap suite for (unsigned long long INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned long long* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (unsigned long long** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (unsigned long long** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned long long **)malloc($2*sizeof(unsigned long long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_ULONGLONG);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_ULONGLONG)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (unsigned long long*) array_data(temp_array);
  }

  $1 = (unsigned long long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (unsigned long long** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned long long* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned long long* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned long long* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned long long*) array_data(array);
}

/* Typemap suite for (unsigned long long* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned long long* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, unsigned long long* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, unsigned long long* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (unsigned long long*) array_data(array);
}

/* Typemap suite for (unsigned long long INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (unsigned long long* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (unsigned long long** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (unsigned long long** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (unsigned long long **)malloc($2*sizeof(unsigned long long *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_ULONGLONG);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_ULONGLONG)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (unsigned long long*) array_data(temp_array);
  }

  $1 = (unsigned long long**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (unsigned long long** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    unsigned long long* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long long* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long long* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned long long*) array_data(array);
}

/* Typemap suite for (unsigned long long* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    unsigned long long* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long long* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, unsigned long long* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (unsigned long long*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (unsigned long long ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned long long ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_ULONGLONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned long long ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned long long* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (unsigned long long* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_ULONGLONG);
  if (!array) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
}
%typemap(argout)
  (unsigned long long* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, unsigned long long* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, unsigned long long* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_ULONGLONG);
  if (!array) SWIG_fail;
  $2 = (unsigned long long*) array_data(array);
}
%typemap(argout)
  (int DIM1, unsigned long long* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned long long ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned long long ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_ULONGLONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned long long ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned long long ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned long long ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_ULONGLONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned long long ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (unsigned long long ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (unsigned long long ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_ULONGLONG);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (unsigned long long ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (unsigned long long** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (unsigned long long*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned long long** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, unsigned long long** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , unsigned long long** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, unsigned long long*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, unsigned long long** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_ULONGLONG, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (unsigned long long*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned long long** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned long long** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned long long** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned long long*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, unsigned long long** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONGLONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (unsigned long long*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned long long** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned long long** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned long long** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned long long*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, unsigned long long** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONGLONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned long long* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned long long** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned long long** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, unsigned long long** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned long long* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, unsigned long long** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONGLONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned long long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned long long** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned long long** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned long long** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned long long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, unsigned long long** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONGLONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned long long* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (unsigned long long** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned long long** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned long long** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned long long* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned long long** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONGLONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned long long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (unsigned long long** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned long long** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned long long** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned long long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned long long** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONGLONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (unsigned long long** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (unsigned long long*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned long long** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, unsigned long long** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , unsigned long long** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, unsigned long long*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, unsigned long long** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_ULONGLONG, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (unsigned long long*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned long long** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned long long** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned long long** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned long long*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, unsigned long long** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONGLONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (unsigned long long*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned long long** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, unsigned long long** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , unsigned long long** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, unsigned long long*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, unsigned long long** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_ULONGLONG, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned long long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned long long** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned long long** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned long long** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned long long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, unsigned long long** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_ULONGLONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (unsigned long long* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned long long** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      unsigned long long** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , unsigned long long** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, unsigned long long* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, unsigned long long** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_ULONGLONG, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned long long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned long long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned long long** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned long long** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned long long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned long long** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONGLONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned long long* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned long long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned long long** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned long long** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned long long* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned long long** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONGLONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned long long* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (unsigned long long** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned long long** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned long long** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned long long* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned long long** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONGLONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (unsigned long long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (unsigned long long** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (unsigned long long* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (unsigned long long** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONGLONG, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      unsigned long long** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , unsigned long long** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, unsigned long long* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, unsigned long long** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_ULONGLONG, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (unsigned long long* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (unsigned long long* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_ULONGLONG);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (unsigned long long* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_ULONGLONG);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (unsigned long long*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (float IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (float IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (float* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (float* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, float* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, float* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, float* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (float*) array_data(array);
}
%typemap(freearg)
  (int DIM1, float* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (float IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (float IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (float* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (float* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, float* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, float* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, float* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (float*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, float* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (float* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_FLOAT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (float* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, float* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, float* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, float* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (float*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, float* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (float IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (float IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (float* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (float* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (float** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (float** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (float **)malloc($2*sizeof(float *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_FLOAT, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (float*) array_data(temp_array);
  }

  $1 = (float**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (float** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    float* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, float* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, float* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (float*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, float* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (float* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_FLOAT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (float* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    float* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, float* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, float* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (float*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, float* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (float IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (float IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (float* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (float* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (float** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (float** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (float **)malloc($2*sizeof(float *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_FLOAT, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (float*) array_data(temp_array);
  }

  $1 = (float**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (float** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    float* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, float* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, float* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (float*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, float* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (float* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_FLOAT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (float* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    float* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, float* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, float* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_FLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (float*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, float* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (float INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (float* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, float* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, float* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, float* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (float*) array_data(array);
}

/* Typemap suite for (float INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (float* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, float* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, float* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, float* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (float*) array_data(array);
}

/* Typemap suite for (float* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, float* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, float* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, float* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (float*) array_data(array);
}

/* Typemap suite for (float INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (float* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (float** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (float** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (float **)malloc($2*sizeof(float *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_FLOAT);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_FLOAT)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (float*) array_data(temp_array);
  }

  $1 = (float**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (float** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    float* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, float* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, float* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (float*) array_data(array);
}

/* Typemap suite for (float* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    float* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, float* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, float* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (float*) array_data(array);
}

/* Typemap suite for (float INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (float* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (float** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (float** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (float **)malloc($2*sizeof(float *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_FLOAT);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_FLOAT)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (float*) array_data(temp_array);
  }

  $1 = (float**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (float** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    float* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, float* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, float* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (float*) array_data(array);
}

/* Typemap suite for (float* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    float* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, float* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, float* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (float*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (float ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (float ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_FLOAT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (float ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (float* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (float* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_FLOAT);
  if (!array) SWIG_fail;
  $1 = (float*) array_data(array);
}
%typemap(argout)
  (float* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, float* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, float* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_FLOAT);
  if (!array) SWIG_fail;
  $2 = (float*) array_data(array);
}
%typemap(argout)
  (int DIM1, float* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (float ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (float ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_FLOAT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (float ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (float ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (float ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_FLOAT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (float ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (float ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (float ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_FLOAT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (float ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (float** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (float*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (float** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, float** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , float** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, float*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, float** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_FLOAT, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (float*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (float** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, float** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , float** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, float*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, float** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_FLOAT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (float*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (float** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, float** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , float** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, float*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, float** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_FLOAT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (float* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (float** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      float** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, float** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, float* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, float** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_FLOAT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (float* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (float** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      float** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , float** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, float* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, float** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_FLOAT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (float* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (float** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      float** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , float** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, float* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, float** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_FLOAT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (float* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (float** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      float** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , float** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, float* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, float** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_FLOAT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (float** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (float*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (float** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, float** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , float** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, float*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, float** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_FLOAT, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (float*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (float** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, float** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , float** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, float*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, float** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_FLOAT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (float*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (float** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, float** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , float** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, float*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, float** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_FLOAT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (float* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (float** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      float** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , float** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, float* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, float** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_FLOAT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (float* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (float** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      float** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , float** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, float* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, float** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_FLOAT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (float* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (float** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      float** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , float** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, float* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, float** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_FLOAT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (float* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (float** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      float** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , float** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, float* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, float** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_FLOAT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (float* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (float** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      float** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , float** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, float* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, float** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_FLOAT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (float** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (float** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (float* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (float** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_FLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      float** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , float** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, float* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, float** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_FLOAT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (float* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (float* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_FLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (float* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_FLOAT);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (float*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (double IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (double IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (double* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (double* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, double* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, double* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, double* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (double*) array_data(array);
}
%typemap(freearg)
  (int DIM1, double* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (double IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (double IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (double* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (double* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, double* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, double* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, double* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (double*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, double* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (double* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_DOUBLE,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (double* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, double* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, double* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, double* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (double*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, double* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (double IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (double IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (double* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (double* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (double** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (double** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (double **)malloc($2*sizeof(double *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_DOUBLE, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (double*) array_data(temp_array);
  }

  $1 = (double**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (double** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    double* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, double* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, double* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (double*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, double* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (double* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_DOUBLE,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (double* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    double* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, double* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, double* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (double*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, double* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (double IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (double IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (double* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (double* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (double** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (double** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (double **)malloc($2*sizeof(double *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_DOUBLE, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (double*) array_data(temp_array);
  }

  $1 = (double**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (double** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    double* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, double* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, double* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (double*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, double* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (double* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_DOUBLE,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (double* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    double* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, double* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, double* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_DOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (double*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, double* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (double INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (double* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, double* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, double* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, double* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (double*) array_data(array);
}

/* Typemap suite for (double INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (double* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, double* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, double* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, double* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (double*) array_data(array);
}

/* Typemap suite for (double* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, double* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, double* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, double* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (double*) array_data(array);
}

/* Typemap suite for (double INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (double* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (double** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (double** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (double **)malloc($2*sizeof(double *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_DOUBLE);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_DOUBLE)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (double*) array_data(temp_array);
  }

  $1 = (double**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (double** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    double* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, double* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, double* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (double*) array_data(array);
}

/* Typemap suite for (double* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    double* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, double* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, double* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (double*) array_data(array);
}

/* Typemap suite for (double INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (double* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (double** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (double** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (double **)malloc($2*sizeof(double *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_DOUBLE);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_DOUBLE)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (double*) array_data(temp_array);
  }

  $1 = (double**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (double** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    double* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, double* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, double* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (double*) array_data(array);
}

/* Typemap suite for (double* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    double* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, double* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, double* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (double*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (double ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (double ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_DOUBLE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (double ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (double* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (double* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_DOUBLE);
  if (!array) SWIG_fail;
  $1 = (double*) array_data(array);
}
%typemap(argout)
  (double* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, double* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, double* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_DOUBLE);
  if (!array) SWIG_fail;
  $2 = (double*) array_data(array);
}
%typemap(argout)
  (int DIM1, double* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (double ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (double ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_DOUBLE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (double ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (double ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (double ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_DOUBLE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (double ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (double ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (double ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_DOUBLE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (double ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (double** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (double*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (double** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, double** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , double** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, double*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, double** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_DOUBLE, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (double*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (double** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, double** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , double** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, double*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, double** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_DOUBLE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (double*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (double** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, double** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , double** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, double*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, double** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_DOUBLE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (double* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (double** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      double** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, double** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, double* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, double** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_DOUBLE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (double* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (double** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      double** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , double** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, double* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, double** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_DOUBLE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (double* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (double** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      double** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , double** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, double* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, double** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_DOUBLE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (double* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (double** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      double** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , double** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, double* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, double** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_DOUBLE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (double** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (double*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (double** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, double** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , double** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, double*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, double** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_DOUBLE, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (double*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (double** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, double** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , double** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, double*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, double** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_DOUBLE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (double*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (double** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, double** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , double** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, double*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, double** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_DOUBLE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (double* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (double** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      double** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , double** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, double* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, double** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_DOUBLE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (double* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (double** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      double** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , double** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, double* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, double** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_DOUBLE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (double* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (double** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      double** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , double** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, double* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, double** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_DOUBLE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (double* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (double** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      double** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , double** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, double* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, double** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_DOUBLE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (double* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (double** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      double** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , double** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, double* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, double** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_DOUBLE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (double** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (double** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (double* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (double** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_DOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      double** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , double** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, double* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, double** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_DOUBLE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (double* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (double* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_DOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (double* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_DOUBLE);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (double*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (int8_t IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int8_t IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int8_t* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (int8_t* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int8_t* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int8_t* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int8_t* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int8_t* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int8_t IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int8_t IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int8_t* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (int8_t* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int8_t* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int8_t* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int8_t* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int8_t* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int8_t* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_INT8,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (int8_t* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int8_t* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int8_t* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int8_t* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int8_t* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int8_t IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int8_t IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int8_t* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (int8_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int8_t** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (int8_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int8_t **)malloc($2*sizeof(int8_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_INT8, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (int8_t*) array_data(temp_array);
  }

  $1 = (int8_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (int8_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int8_t* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int8_t* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int8_t* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int8_t* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int8_t* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT8,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (int8_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int8_t* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int8_t* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int8_t* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int8_t* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int8_t IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int8_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int8_t* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (int8_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int8_t** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (int8_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int8_t **)malloc($2*sizeof(int8_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_INT8, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (int8_t*) array_data(temp_array);
  }

  $1 = (int8_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (int8_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int8_t* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int8_t* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int8_t* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, int8_t* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int8_t* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT8,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (int8_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int8_t* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int8_t* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int8_t* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, int8_t* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (int8_t INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int8_t* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, int8_t* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int8_t* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int8_t* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (int8_t*) array_data(array);
}

/* Typemap suite for (int8_t INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int8_t* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, int8_t* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int8_t* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int8_t* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int8_t*) array_data(array);
}

/* Typemap suite for (int8_t* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, int8_t* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int8_t* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int8_t* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int8_t*) array_data(array);
}

/* Typemap suite for (int8_t INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int8_t* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int8_t** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (int8_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int8_t **)malloc($2*sizeof(int8_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_INT8);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_INT8)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (int8_t*) array_data(temp_array);
  }

  $1 = (int8_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (int8_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int8_t* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int8_t* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int8_t* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int8_t*) array_data(array);
}

/* Typemap suite for (int8_t* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int8_t* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int8_t* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int8_t* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int8_t*) array_data(array);
}

/* Typemap suite for (int8_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int8_t* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int8_t** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (int8_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int8_t **)malloc($2*sizeof(int8_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_INT8);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_INT8)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (int8_t*) array_data(temp_array);
  }

  $1 = (int8_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (int8_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int8_t* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int8_t* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int8_t* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int8_t*) array_data(array);
}

/* Typemap suite for (int8_t* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int8_t* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int8_t* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int8_t* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int8_t*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (int8_t ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int8_t ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_INT8);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int8_t ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int8_t* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int8_t* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_INT8);
  if (!array) SWIG_fail;
  $1 = (int8_t*) array_data(array);
}
%typemap(argout)
  (int8_t* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, int8_t* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, int8_t* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_INT8);
  if (!array) SWIG_fail;
  $2 = (int8_t*) array_data(array);
}
%typemap(argout)
  (int DIM1, int8_t* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int8_t ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int8_t ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_INT8);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int8_t ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int8_t ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int8_t ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_INT8);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int8_t ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int8_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int8_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_INT8);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int8_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (int8_t** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (int8_t*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int8_t** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int8_t** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int8_t** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, int8_t*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int8_t** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT8, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (int8_t*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int8_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int8_t** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int8_t** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, int8_t*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int8_t** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT8, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (int8_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int8_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int8_t** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int8_t** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, int8_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int8_t** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT8, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int8_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int8_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int8_t** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, int8_t** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int8_t* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int8_t** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT8, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int8_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int8_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int8_t** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int8_t** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int8_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int8_t** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT8, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int8_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int8_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int8_t** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int8_t** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int8_t* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int8_t** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT8, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int8_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int8_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int8_t** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int8_t** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int8_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int8_t** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT8, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (int8_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (int8_t*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int8_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int8_t** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int8_t** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, int8_t*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int8_t** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT8, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (int8_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int8_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int8_t** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int8_t** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, int8_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int8_t** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT8, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (int8_t*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int8_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int8_t** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int8_t** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, int8_t*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int8_t** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT8, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int8_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int8_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int8_t** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int8_t** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int8_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int8_t** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_INT8, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int8_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int8_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int8_t** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int8_t** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int8_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int8_t** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT8, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int8_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int8_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int8_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int8_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int8_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int8_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT8, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int8_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int8_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int8_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int8_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int8_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int8_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT8, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int8_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int8_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int8_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int8_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int8_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int8_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT8, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int8_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int8_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int8_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int8_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int8_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int8_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int8_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int8_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT8, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (int8_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int8_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int8_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_INT8);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int8_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (int16_t IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int16_t IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int16_t* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (int16_t* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int16_t* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int16_t* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int16_t* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int16_t* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int16_t IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int16_t IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int16_t* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (int16_t* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int16_t* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int16_t* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int16_t* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int16_t* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int16_t* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_INT16,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (int16_t* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int16_t* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int16_t* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int16_t* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int16_t* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int16_t IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int16_t IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int16_t* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (int16_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int16_t** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (int16_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int16_t **)malloc($2*sizeof(int16_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_INT16, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (int16_t*) array_data(temp_array);
  }

  $1 = (int16_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (int16_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int16_t* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int16_t* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int16_t* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int16_t* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int16_t* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT16,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (int16_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int16_t* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int16_t* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int16_t* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int16_t* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int16_t IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int16_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int16_t* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (int16_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int16_t** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (int16_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int16_t **)malloc($2*sizeof(int16_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_INT16, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (int16_t*) array_data(temp_array);
  }

  $1 = (int16_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (int16_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int16_t* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int16_t* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int16_t* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, int16_t* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int16_t* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT16,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (int16_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int16_t* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int16_t* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int16_t* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, int16_t* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (int16_t INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int16_t* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, int16_t* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int16_t* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int16_t* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (int16_t*) array_data(array);
}

/* Typemap suite for (int16_t INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int16_t* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, int16_t* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int16_t* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int16_t* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int16_t*) array_data(array);
}

/* Typemap suite for (int16_t* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, int16_t* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int16_t* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int16_t* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int16_t*) array_data(array);
}

/* Typemap suite for (int16_t INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int16_t* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int16_t** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (int16_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int16_t **)malloc($2*sizeof(int16_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_INT16);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_INT16)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (int16_t*) array_data(temp_array);
  }

  $1 = (int16_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (int16_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int16_t* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int16_t* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int16_t* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int16_t*) array_data(array);
}

/* Typemap suite for (int16_t* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int16_t* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int16_t* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int16_t* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int16_t*) array_data(array);
}

/* Typemap suite for (int16_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int16_t* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int16_t** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (int16_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int16_t **)malloc($2*sizeof(int16_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_INT16);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_INT16)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (int16_t*) array_data(temp_array);
  }

  $1 = (int16_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (int16_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int16_t* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int16_t* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int16_t* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int16_t*) array_data(array);
}

/* Typemap suite for (int16_t* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int16_t* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int16_t* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int16_t* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int16_t*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (int16_t ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int16_t ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_INT16);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int16_t ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int16_t* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int16_t* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_INT16);
  if (!array) SWIG_fail;
  $1 = (int16_t*) array_data(array);
}
%typemap(argout)
  (int16_t* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, int16_t* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, int16_t* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_INT16);
  if (!array) SWIG_fail;
  $2 = (int16_t*) array_data(array);
}
%typemap(argout)
  (int DIM1, int16_t* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int16_t ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int16_t ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_INT16);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int16_t ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int16_t ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int16_t ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_INT16);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int16_t ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int16_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int16_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_INT16);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int16_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (int16_t** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (int16_t*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int16_t** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int16_t** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int16_t** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, int16_t*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int16_t** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT16, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (int16_t*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int16_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int16_t** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int16_t** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, int16_t*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int16_t** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT16, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (int16_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int16_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int16_t** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int16_t** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, int16_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int16_t** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT16, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int16_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int16_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int16_t** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, int16_t** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int16_t* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int16_t** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT16, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int16_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int16_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int16_t** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int16_t** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int16_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int16_t** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT16, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int16_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int16_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int16_t** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int16_t** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int16_t* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int16_t** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT16, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int16_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int16_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int16_t** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int16_t** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int16_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int16_t** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT16, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (int16_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (int16_t*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int16_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int16_t** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int16_t** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, int16_t*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int16_t** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT16, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (int16_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int16_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int16_t** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int16_t** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, int16_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int16_t** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT16, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (int16_t*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int16_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int16_t** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int16_t** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, int16_t*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int16_t** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT16, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int16_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int16_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int16_t** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int16_t** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int16_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int16_t** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_INT16, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int16_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int16_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int16_t** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int16_t** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int16_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int16_t** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT16, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int16_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int16_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int16_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int16_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int16_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int16_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT16, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int16_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int16_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int16_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int16_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int16_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int16_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT16, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int16_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int16_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int16_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int16_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int16_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int16_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT16, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int16_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int16_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int16_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int16_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int16_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int16_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int16_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int16_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT16, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (int16_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int16_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int16_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_INT16);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int16_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (int32_t IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int32_t IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int32_t* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (int32_t* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int32_t* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int32_t* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int32_t* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int32_t* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int32_t IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int32_t IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int32_t* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (int32_t* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int32_t* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int32_t* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int32_t* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int32_t* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int32_t* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_INT32,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (int32_t* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int32_t* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int32_t* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int32_t* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int32_t* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int32_t IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int32_t IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int32_t* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (int32_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int32_t** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (int32_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int32_t **)malloc($2*sizeof(int32_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_INT32, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (int32_t*) array_data(temp_array);
  }

  $1 = (int32_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (int32_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int32_t* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int32_t* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int32_t* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int32_t* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int32_t* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT32,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (int32_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int32_t* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int32_t* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int32_t* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int32_t* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int32_t IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int32_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int32_t* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (int32_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int32_t** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (int32_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int32_t **)malloc($2*sizeof(int32_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_INT32, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (int32_t*) array_data(temp_array);
  }

  $1 = (int32_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (int32_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int32_t* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int32_t* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int32_t* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, int32_t* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int32_t* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT32,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (int32_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int32_t* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int32_t* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int32_t* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, int32_t* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (int32_t INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int32_t* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, int32_t* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int32_t* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int32_t* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (int32_t*) array_data(array);
}

/* Typemap suite for (int32_t INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int32_t* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, int32_t* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int32_t* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int32_t* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int32_t*) array_data(array);
}

/* Typemap suite for (int32_t* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, int32_t* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int32_t* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int32_t* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int32_t*) array_data(array);
}

/* Typemap suite for (int32_t INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int32_t* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int32_t** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (int32_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int32_t **)malloc($2*sizeof(int32_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_INT32);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_INT32)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (int32_t*) array_data(temp_array);
  }

  $1 = (int32_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (int32_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int32_t* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int32_t* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int32_t* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int32_t*) array_data(array);
}

/* Typemap suite for (int32_t* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int32_t* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int32_t* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int32_t* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int32_t*) array_data(array);
}

/* Typemap suite for (int32_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int32_t* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int32_t** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (int32_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int32_t **)malloc($2*sizeof(int32_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_INT32);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_INT32)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (int32_t*) array_data(temp_array);
  }

  $1 = (int32_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (int32_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int32_t* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int32_t* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int32_t* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int32_t*) array_data(array);
}

/* Typemap suite for (int32_t* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int32_t* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int32_t* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int32_t* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int32_t*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (int32_t ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int32_t ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_INT32);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int32_t ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int32_t* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int32_t* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_INT32);
  if (!array) SWIG_fail;
  $1 = (int32_t*) array_data(array);
}
%typemap(argout)
  (int32_t* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, int32_t* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, int32_t* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_INT32);
  if (!array) SWIG_fail;
  $2 = (int32_t*) array_data(array);
}
%typemap(argout)
  (int DIM1, int32_t* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int32_t ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int32_t ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_INT32);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int32_t ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int32_t ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int32_t ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_INT32);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int32_t ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int32_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int32_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_INT32);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int32_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (int32_t** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (int32_t*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int32_t** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int32_t** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int32_t** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, int32_t*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int32_t** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT32, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (int32_t*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int32_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int32_t** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int32_t** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, int32_t*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int32_t** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT32, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (int32_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int32_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int32_t** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int32_t** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, int32_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int32_t** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT32, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int32_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int32_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int32_t** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, int32_t** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int32_t* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int32_t** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT32, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int32_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int32_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int32_t** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int32_t** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int32_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int32_t** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT32, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int32_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int32_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int32_t** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int32_t** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int32_t* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int32_t** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT32, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int32_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int32_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int32_t** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int32_t** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int32_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int32_t** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT32, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (int32_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (int32_t*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int32_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int32_t** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int32_t** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, int32_t*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int32_t** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT32, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (int32_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int32_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int32_t** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int32_t** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, int32_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int32_t** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT32, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (int32_t*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int32_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int32_t** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int32_t** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, int32_t*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int32_t** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT32, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int32_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int32_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int32_t** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int32_t** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int32_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int32_t** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_INT32, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int32_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int32_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int32_t** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int32_t** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int32_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int32_t** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT32, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int32_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int32_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int32_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int32_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int32_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int32_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT32, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int32_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int32_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int32_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int32_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int32_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int32_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT32, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int32_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int32_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int32_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int32_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int32_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int32_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT32, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int32_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int32_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int32_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int32_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int32_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int32_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int32_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int32_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT32, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (int32_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int32_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int32_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_INT32);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int32_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (int64_t IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int64_t IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int64_t* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (int64_t* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int64_t* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int64_t* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int64_t* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int64_t* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int64_t IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int64_t IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int64_t* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (int64_t* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int64_t* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int64_t* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int64_t* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int64_t* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int64_t* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_INT64,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (int64_t* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int64_t* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int64_t* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int64_t* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int64_t* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int64_t IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int64_t IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int64_t* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (int64_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int64_t** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (int64_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int64_t **)malloc($2*sizeof(int64_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_INT64, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (int64_t*) array_data(temp_array);
  }

  $1 = (int64_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (int64_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int64_t* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int64_t* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int64_t* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int64_t* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int64_t* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT64,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (int64_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int64_t* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int64_t* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int64_t* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int64_t* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int64_t IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (int64_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int64_t* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (int64_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int64_t** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (int64_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int64_t **)malloc($2*sizeof(int64_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_INT64, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (int64_t*) array_data(temp_array);
  }

  $1 = (int64_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (int64_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int64_t* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int64_t* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int64_t* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, int64_t* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int64_t* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT64,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (int64_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int64_t* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int64_t* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int64_t* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_INT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, int64_t* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (int64_t INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int64_t* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, int64_t* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int64_t* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int64_t* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (int64_t*) array_data(array);
}

/* Typemap suite for (int64_t INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int64_t* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, int64_t* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int64_t* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int64_t* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int64_t*) array_data(array);
}

/* Typemap suite for (int64_t* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, int64_t* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int64_t* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int64_t* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int64_t*) array_data(array);
}

/* Typemap suite for (int64_t INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int64_t* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int64_t** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (int64_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int64_t **)malloc($2*sizeof(int64_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_INT64);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_INT64)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (int64_t*) array_data(temp_array);
  }

  $1 = (int64_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (int64_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int64_t* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int64_t* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int64_t* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int64_t*) array_data(array);
}

/* Typemap suite for (int64_t* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int64_t* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int64_t* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int64_t* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int64_t*) array_data(array);
}

/* Typemap suite for (int64_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (int64_t* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int64_t** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (int64_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (int64_t **)malloc($2*sizeof(int64_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_INT64);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_INT64)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (int64_t*) array_data(temp_array);
  }

  $1 = (int64_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (int64_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    int64_t* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int64_t* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int64_t* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int64_t*) array_data(array);
}

/* Typemap suite for (int64_t* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    int64_t* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, int64_t* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, int64_t* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (int64_t*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (int64_t ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int64_t ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_INT64);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int64_t ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int64_t* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int64_t* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_INT64);
  if (!array) SWIG_fail;
  $1 = (int64_t*) array_data(array);
}
%typemap(argout)
  (int64_t* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, int64_t* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, int64_t* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_INT64);
  if (!array) SWIG_fail;
  $2 = (int64_t*) array_data(array);
}
%typemap(argout)
  (int DIM1, int64_t* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int64_t ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int64_t ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_INT64);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int64_t ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int64_t ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int64_t ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_INT64);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int64_t ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int64_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (int64_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_INT64);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (int64_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (int64_t** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (int64_t*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int64_t** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int64_t** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int64_t** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, int64_t*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int64_t** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT64, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (int64_t*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int64_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int64_t** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int64_t** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, int64_t*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int64_t** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT64, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (int64_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int64_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int64_t** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int64_t** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, int64_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int64_t** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT64, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int64_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int64_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int64_t** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, int64_t** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int64_t* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int64_t** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT64, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int64_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int64_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int64_t** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int64_t** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int64_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int64_t** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT64, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int64_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int64_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int64_t** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int64_t** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int64_t* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int64_t** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT64, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int64_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int64_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int64_t** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int64_t** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int64_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int64_t** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT64, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (int64_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (int64_t*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int64_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int64_t** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int64_t** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, int64_t*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int64_t** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_INT64, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (int64_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int64_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int64_t** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int64_t** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, int64_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int64_t** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT64, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (int64_t*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int64_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int64_t** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , int64_t** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, int64_t*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int64_t** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_INT64, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int64_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int64_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int64_t** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int64_t** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int64_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int64_t** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_INT64, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (int64_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int64_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      int64_t** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int64_t** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, int64_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int64_t** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_INT64, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int64_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int64_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int64_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int64_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int64_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int64_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT64, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int64_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int64_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int64_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int64_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int64_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int64_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT64, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int64_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int64_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int64_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int64_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int64_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int64_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT64, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int64_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (int64_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (int64_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int64_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      int64_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , int64_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, int64_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, int64_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_INT64, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (int64_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int64_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_INT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int64_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_INT64);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int64_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (uint8_t IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint8_t IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint8_t* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (uint8_t* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, uint8_t* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, uint8_t* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, uint8_t* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (uint8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, uint8_t* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint8_t IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint8_t IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint8_t* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (uint8_t* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, uint8_t* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint8_t* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint8_t* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, uint8_t* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint8_t* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_UINT8,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (uint8_t* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, uint8_t* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint8_t* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint8_t* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, uint8_t* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint8_t IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint8_t IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint8_t* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (uint8_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint8_t** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (uint8_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint8_t **)malloc($2*sizeof(uint8_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_UINT8, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (uint8_t*) array_data(temp_array);
  }

  $1 = (uint8_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (uint8_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint8_t* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint8_t* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint8_t* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, uint8_t* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint8_t* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT8,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (uint8_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint8_t* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint8_t* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint8_t* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, uint8_t* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint8_t IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint8_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint8_t* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (uint8_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint8_t** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (uint8_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint8_t **)malloc($2*sizeof(uint8_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_UINT8, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (uint8_t*) array_data(temp_array);
  }

  $1 = (uint8_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (uint8_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    uint8_t* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint8_t* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint8_t* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, uint8_t* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint8_t* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT8,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (uint8_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    uint8_t* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint8_t* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint8_t* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT8,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint8_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, uint8_t* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (uint8_t INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint8_t* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, uint8_t* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, uint8_t* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, uint8_t* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (uint8_t*) array_data(array);
}

/* Typemap suite for (uint8_t INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint8_t* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, uint8_t* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint8_t* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint8_t* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint8_t*) array_data(array);
}

/* Typemap suite for (uint8_t* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, uint8_t* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint8_t* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint8_t* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint8_t*) array_data(array);
}

/* Typemap suite for (uint8_t INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint8_t* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (uint8_t** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (uint8_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint8_t **)malloc($2*sizeof(uint8_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_UINT8);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_UINT8)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (uint8_t*) array_data(temp_array);
  }

  $1 = (uint8_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (uint8_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint8_t* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint8_t* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint8_t* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint8_t*) array_data(array);
}

/* Typemap suite for (uint8_t* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint8_t* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint8_t* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint8_t* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint8_t*) array_data(array);
}

/* Typemap suite for (uint8_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint8_t* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (uint8_t** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (uint8_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint8_t **)malloc($2*sizeof(uint8_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_UINT8);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_UINT8)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (uint8_t*) array_data(temp_array);
  }

  $1 = (uint8_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (uint8_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    uint8_t* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint8_t* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint8_t* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint8_t*) array_data(array);
}

/* Typemap suite for (uint8_t* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint8_t* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint8_t* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint8_t* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint8_t*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (uint8_t ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint8_t ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_UINT8);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint8_t ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint8_t* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (uint8_t* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_UINT8);
  if (!array) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
}
%typemap(argout)
  (uint8_t* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, uint8_t* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, uint8_t* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_UINT8);
  if (!array) SWIG_fail;
  $2 = (uint8_t*) array_data(array);
}
%typemap(argout)
  (int DIM1, uint8_t* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint8_t ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint8_t ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_UINT8);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint8_t ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint8_t ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint8_t ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_UINT8);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint8_t ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint8_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint8_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_UINT8);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint8_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (uint8_t** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (uint8_t*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint8_t** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, uint8_t** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , uint8_t** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, uint8_t*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, uint8_t** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT8, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (uint8_t*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint8_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint8_t** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint8_t** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, uint8_t*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, uint8_t** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT8, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (uint8_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (uint8_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint8_t** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint8_t** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, uint8_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, uint8_t** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT8, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint8_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint8_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint8_t** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, uint8_t** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint8_t* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, uint8_t** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT8, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint8_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (uint8_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint8_t** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , uint8_t** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint8_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, uint8_t** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT8, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint8_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint8_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint8_t** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint8_t** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint8_t* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint8_t** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT8, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint8_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (uint8_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint8_t** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint8_t** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint8_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint8_t** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT8, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (uint8_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (uint8_t*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint8_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, uint8_t** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , uint8_t** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, uint8_t*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, uint8_t** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT8, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (uint8_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint8_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint8_t** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint8_t** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, uint8_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, uint8_t** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT8, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (uint8_t*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint8_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint8_t** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint8_t** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, uint8_t*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, uint8_t** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT8, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint8_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint8_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint8_t** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , uint8_t** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint8_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, uint8_t** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_UINT8, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint8_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint8_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint8_t** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , uint8_t** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint8_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, uint8_t** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT8, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint8_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint8_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint8_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint8_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint8_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint8_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT8, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint8_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint8_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint8_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint8_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint8_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint8_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT8, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint8_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint8_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint8_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint8_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint8_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint8_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT8, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint8_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint8_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint8_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint8_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT8, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint8_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint8_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint8_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint8_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT8, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (uint8_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint8_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT8);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint8_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_UINT8);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (uint8_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (uint16_t IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint16_t IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint16_t* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (uint16_t* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, uint16_t* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, uint16_t* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, uint16_t* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (uint16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, uint16_t* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint16_t IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint16_t IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint16_t* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (uint16_t* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, uint16_t* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint16_t* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint16_t* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, uint16_t* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint16_t* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_UINT16,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (uint16_t* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, uint16_t* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint16_t* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint16_t* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, uint16_t* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint16_t IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint16_t IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint16_t* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (uint16_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint16_t** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (uint16_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint16_t **)malloc($2*sizeof(uint16_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_UINT16, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (uint16_t*) array_data(temp_array);
  }

  $1 = (uint16_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (uint16_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint16_t* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint16_t* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint16_t* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, uint16_t* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint16_t* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT16,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (uint16_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint16_t* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint16_t* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint16_t* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, uint16_t* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint16_t IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint16_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint16_t* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (uint16_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint16_t** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (uint16_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint16_t **)malloc($2*sizeof(uint16_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_UINT16, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (uint16_t*) array_data(temp_array);
  }

  $1 = (uint16_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (uint16_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    uint16_t* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint16_t* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint16_t* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, uint16_t* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint16_t* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT16,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (uint16_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    uint16_t* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint16_t* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint16_t* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT16,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint16_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, uint16_t* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (uint16_t INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint16_t* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, uint16_t* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, uint16_t* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, uint16_t* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (uint16_t*) array_data(array);
}

/* Typemap suite for (uint16_t INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint16_t* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, uint16_t* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint16_t* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint16_t* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint16_t*) array_data(array);
}

/* Typemap suite for (uint16_t* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, uint16_t* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint16_t* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint16_t* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint16_t*) array_data(array);
}

/* Typemap suite for (uint16_t INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint16_t* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (uint16_t** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (uint16_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint16_t **)malloc($2*sizeof(uint16_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_UINT16);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_UINT16)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (uint16_t*) array_data(temp_array);
  }

  $1 = (uint16_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (uint16_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint16_t* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint16_t* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint16_t* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint16_t*) array_data(array);
}

/* Typemap suite for (uint16_t* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint16_t* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint16_t* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint16_t* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint16_t*) array_data(array);
}

/* Typemap suite for (uint16_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint16_t* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (uint16_t** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (uint16_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint16_t **)malloc($2*sizeof(uint16_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_UINT16);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_UINT16)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (uint16_t*) array_data(temp_array);
  }

  $1 = (uint16_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (uint16_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    uint16_t* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint16_t* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint16_t* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint16_t*) array_data(array);
}

/* Typemap suite for (uint16_t* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint16_t* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint16_t* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint16_t* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint16_t*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (uint16_t ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint16_t ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_UINT16);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint16_t ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint16_t* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (uint16_t* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_UINT16);
  if (!array) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
}
%typemap(argout)
  (uint16_t* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, uint16_t* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, uint16_t* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_UINT16);
  if (!array) SWIG_fail;
  $2 = (uint16_t*) array_data(array);
}
%typemap(argout)
  (int DIM1, uint16_t* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint16_t ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint16_t ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_UINT16);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint16_t ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint16_t ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint16_t ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_UINT16);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint16_t ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint16_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint16_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_UINT16);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint16_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (uint16_t** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (uint16_t*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint16_t** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, uint16_t** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , uint16_t** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, uint16_t*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, uint16_t** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT16, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (uint16_t*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint16_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint16_t** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint16_t** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, uint16_t*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, uint16_t** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT16, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (uint16_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (uint16_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint16_t** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint16_t** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, uint16_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, uint16_t** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT16, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint16_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint16_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint16_t** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, uint16_t** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint16_t* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, uint16_t** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT16, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint16_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (uint16_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint16_t** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , uint16_t** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint16_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, uint16_t** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT16, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint16_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint16_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint16_t** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint16_t** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint16_t* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint16_t** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT16, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint16_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (uint16_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint16_t** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint16_t** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint16_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint16_t** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT16, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (uint16_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (uint16_t*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint16_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, uint16_t** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , uint16_t** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, uint16_t*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, uint16_t** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT16, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (uint16_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint16_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint16_t** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint16_t** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, uint16_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, uint16_t** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT16, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (uint16_t*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint16_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint16_t** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint16_t** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, uint16_t*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, uint16_t** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT16, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint16_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint16_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint16_t** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , uint16_t** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint16_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, uint16_t** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_UINT16, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint16_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint16_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint16_t** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , uint16_t** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint16_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, uint16_t** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT16, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint16_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint16_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint16_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint16_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint16_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint16_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT16, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint16_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint16_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint16_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint16_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint16_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint16_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT16, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint16_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint16_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint16_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint16_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint16_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint16_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT16, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint16_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint16_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint16_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint16_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT16, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint16_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint16_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint16_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint16_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT16, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (uint16_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint16_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT16);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint16_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_UINT16);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (uint16_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (uint32_t IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint32_t IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint32_t* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (uint32_t* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, uint32_t* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, uint32_t* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, uint32_t* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (uint32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, uint32_t* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint32_t IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint32_t IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint32_t* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (uint32_t* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, uint32_t* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint32_t* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint32_t* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, uint32_t* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint32_t* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_UINT32,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (uint32_t* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, uint32_t* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint32_t* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint32_t* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, uint32_t* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint32_t IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint32_t IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint32_t* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (uint32_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint32_t** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (uint32_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint32_t **)malloc($2*sizeof(uint32_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_UINT32, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (uint32_t*) array_data(temp_array);
  }

  $1 = (uint32_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (uint32_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint32_t* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint32_t* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint32_t* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, uint32_t* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint32_t* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT32,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (uint32_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint32_t* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint32_t* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint32_t* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, uint32_t* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint32_t IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint32_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint32_t* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (uint32_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint32_t** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (uint32_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint32_t **)malloc($2*sizeof(uint32_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_UINT32, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (uint32_t*) array_data(temp_array);
  }

  $1 = (uint32_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (uint32_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    uint32_t* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint32_t* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint32_t* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, uint32_t* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint32_t* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT32,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (uint32_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    uint32_t* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint32_t* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint32_t* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT32,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint32_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, uint32_t* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (uint32_t INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint32_t* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, uint32_t* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, uint32_t* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, uint32_t* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (uint32_t*) array_data(array);
}

/* Typemap suite for (uint32_t INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint32_t* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, uint32_t* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint32_t* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint32_t* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint32_t*) array_data(array);
}

/* Typemap suite for (uint32_t* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, uint32_t* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint32_t* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint32_t* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint32_t*) array_data(array);
}

/* Typemap suite for (uint32_t INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint32_t* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (uint32_t** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (uint32_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint32_t **)malloc($2*sizeof(uint32_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_UINT32);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_UINT32)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (uint32_t*) array_data(temp_array);
  }

  $1 = (uint32_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (uint32_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint32_t* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint32_t* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint32_t* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint32_t*) array_data(array);
}

/* Typemap suite for (uint32_t* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint32_t* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint32_t* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint32_t* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint32_t*) array_data(array);
}

/* Typemap suite for (uint32_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint32_t* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (uint32_t** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (uint32_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint32_t **)malloc($2*sizeof(uint32_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_UINT32);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_UINT32)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (uint32_t*) array_data(temp_array);
  }

  $1 = (uint32_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (uint32_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    uint32_t* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint32_t* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint32_t* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint32_t*) array_data(array);
}

/* Typemap suite for (uint32_t* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint32_t* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint32_t* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint32_t* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint32_t*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (uint32_t ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint32_t ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_UINT32);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint32_t ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint32_t* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (uint32_t* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_UINT32);
  if (!array) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
}
%typemap(argout)
  (uint32_t* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, uint32_t* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, uint32_t* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_UINT32);
  if (!array) SWIG_fail;
  $2 = (uint32_t*) array_data(array);
}
%typemap(argout)
  (int DIM1, uint32_t* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint32_t ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint32_t ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_UINT32);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint32_t ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint32_t ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint32_t ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_UINT32);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint32_t ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint32_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint32_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_UINT32);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint32_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (uint32_t** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (uint32_t*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint32_t** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, uint32_t** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , uint32_t** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, uint32_t*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, uint32_t** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT32, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (uint32_t*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint32_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint32_t** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint32_t** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, uint32_t*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, uint32_t** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT32, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (uint32_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (uint32_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint32_t** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint32_t** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, uint32_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, uint32_t** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT32, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint32_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint32_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint32_t** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, uint32_t** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint32_t* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, uint32_t** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT32, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint32_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (uint32_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint32_t** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , uint32_t** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint32_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, uint32_t** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT32, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint32_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint32_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint32_t** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint32_t** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint32_t* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint32_t** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT32, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint32_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (uint32_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint32_t** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint32_t** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint32_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint32_t** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT32, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (uint32_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (uint32_t*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint32_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, uint32_t** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , uint32_t** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, uint32_t*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, uint32_t** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT32, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (uint32_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint32_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint32_t** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint32_t** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, uint32_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, uint32_t** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT32, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (uint32_t*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint32_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint32_t** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint32_t** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, uint32_t*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, uint32_t** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT32, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint32_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint32_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint32_t** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , uint32_t** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint32_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, uint32_t** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_UINT32, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint32_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint32_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint32_t** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , uint32_t** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint32_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, uint32_t** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT32, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint32_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint32_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint32_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint32_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint32_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint32_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT32, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint32_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint32_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint32_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint32_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint32_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint32_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT32, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint32_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint32_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint32_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint32_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint32_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint32_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT32, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint32_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint32_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint32_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint32_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT32, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint32_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint32_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint32_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint32_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT32, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (uint32_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint32_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT32);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint32_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_UINT32);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (uint32_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (uint64_t IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint64_t IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint64_t* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (uint64_t* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, uint64_t* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, uint64_t* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, uint64_t* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (uint64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, uint64_t* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint64_t IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint64_t IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint64_t* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (uint64_t* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, uint64_t* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint64_t* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint64_t* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, uint64_t* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint64_t* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_UINT64,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (uint64_t* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, uint64_t* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint64_t* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint64_t* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, uint64_t* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint64_t IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint64_t IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint64_t* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (uint64_t* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint64_t** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (uint64_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint64_t **)malloc($2*sizeof(uint64_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_UINT64, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (uint64_t*) array_data(temp_array);
  }

  $1 = (uint64_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (uint64_t** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint64_t* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint64_t* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint64_t* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, uint64_t* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint64_t* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT64,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (uint64_t* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint64_t* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint64_t* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint64_t* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, uint64_t* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint64_t IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (uint64_t IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint64_t* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (uint64_t* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint64_t** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (uint64_t** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint64_t **)malloc($2*sizeof(uint64_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_UINT64, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (uint64_t*) array_data(temp_array);
  }

  $1 = (uint64_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (uint64_t** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    uint64_t* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint64_t* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint64_t* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, uint64_t* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (uint64_t* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT64,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (uint64_t* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    uint64_t* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint64_t* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint64_t* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_UINT64,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint64_t*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, uint64_t* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (uint64_t INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint64_t* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, uint64_t* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, uint64_t* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, uint64_t* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (uint64_t*) array_data(array);
}

/* Typemap suite for (uint64_t INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint64_t* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, uint64_t* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint64_t* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint64_t* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint64_t*) array_data(array);
}

/* Typemap suite for (uint64_t* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, uint64_t* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, uint64_t* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, uint64_t* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (uint64_t*) array_data(array);
}

/* Typemap suite for (uint64_t INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint64_t* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (uint64_t** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (uint64_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint64_t **)malloc($2*sizeof(uint64_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_UINT64);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_UINT64)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (uint64_t*) array_data(temp_array);
  }

  $1 = (uint64_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (uint64_t** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint64_t* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint64_t* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint64_t* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint64_t*) array_data(array);
}

/* Typemap suite for (uint64_t* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint64_t* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, uint64_t* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, uint64_t* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (uint64_t*) array_data(array);
}

/* Typemap suite for (uint64_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (uint64_t* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (uint64_t** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (uint64_t** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (uint64_t **)malloc($2*sizeof(uint64_t *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_UINT64);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_UINT64)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (uint64_t*) array_data(temp_array);
  }

  $1 = (uint64_t**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (uint64_t** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    uint64_t* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint64_t* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint64_t* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint64_t*) array_data(array);
}

/* Typemap suite for (uint64_t* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    uint64_t* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, uint64_t* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, uint64_t* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (uint64_t*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (uint64_t ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint64_t ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_UINT64);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint64_t ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint64_t* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (uint64_t* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_UINT64);
  if (!array) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
}
%typemap(argout)
  (uint64_t* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, uint64_t* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, uint64_t* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_UINT64);
  if (!array) SWIG_fail;
  $2 = (uint64_t*) array_data(array);
}
%typemap(argout)
  (int DIM1, uint64_t* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint64_t ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint64_t ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_UINT64);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint64_t ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint64_t ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint64_t ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_UINT64);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint64_t ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (uint64_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (uint64_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_UINT64);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (uint64_t ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (uint64_t** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (uint64_t*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint64_t** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, uint64_t** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , uint64_t** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, uint64_t*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, uint64_t** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT64, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (uint64_t*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint64_t** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint64_t** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint64_t** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, uint64_t*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, uint64_t** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT64, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (uint64_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (uint64_t** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint64_t** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint64_t** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, uint64_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, uint64_t** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT64, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint64_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint64_t** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint64_t** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, uint64_t** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint64_t* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, uint64_t** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT64, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint64_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (uint64_t** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint64_t** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , uint64_t** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint64_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, uint64_t** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT64, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint64_t* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (uint64_t** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint64_t** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint64_t** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint64_t* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint64_t** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT64, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint64_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (uint64_t** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint64_t** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint64_t** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint64_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint64_t** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT64, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (uint64_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (uint64_t*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint64_t** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, uint64_t** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , uint64_t** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, uint64_t*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, uint64_t** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_UINT64, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (uint64_t*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint64_t** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint64_t** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint64_t** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, uint64_t*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, uint64_t** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT64, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (uint64_t*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint64_t** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, uint64_t** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , uint64_t** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, uint64_t*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, uint64_t** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_UINT64, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint64_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint64_t** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint64_t** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , uint64_t** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint64_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, uint64_t** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_UINT64, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (uint64_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint64_t** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      uint64_t** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , uint64_t** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, uint64_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, uint64_t** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_UINT64, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint64_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint64_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint64_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint64_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint64_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint64_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT64, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint64_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint64_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint64_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint64_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint64_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint64_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT64, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint64_t* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (uint64_t** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint64_t** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint64_t** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint64_t* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint64_t** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT64, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (uint64_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (uint64_t** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (uint64_t* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (uint64_t** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT64, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      uint64_t** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , uint64_t** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, uint64_t* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, uint64_t** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_UINT64, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (uint64_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (uint64_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_UINT64);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (uint64_t* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_UINT64);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (uint64_t*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/


/* ***************************************************************
 * The follow macro expansion does not work, because C++ bool is 4
 * bytes and NPY_BOOL is 1 byte
 *
 *    %numpy_typemaps(bool, NPY_BOOL, int)
 */

/* ***************************************************************
 * On my Mac, I get the following warning for this macro expansion:
 * 'swig/python detected a memory leak of type 'long double *', no destructor found.'
 *
 *    %numpy_typemaps(long double, NPY_LONGDOUBLE, int)
 */



%includefile "/home/balos1/.local/share/swig/4.0.0/python/std_complex.i" %beginfile
/*
 *  STD C++ complex typemaps
 */

%includefile "/home/balos1/.local/share/swig/4.0.0/python/pycomplex.swg" %beginfile
/*
  Defines the As/From converters for double/float complex, you need to
  provide complex Type, the Name you want to use in the converters,
  the complex Constructor method, and the Real and Imag complex
  accessor methods.

  See the std_complex.i and ccomplex.i for concrete examples.
*/

/* the common from converter */











/* the double case */
























/* the float case */







































%endoffile

%{
#include <complex> 
%}

namespace std {
  %feature("naturalvar") complex;
  template<typename T> class complex;
  %template() complex<double>;
  %template() complex<float>;
}

/* defining the complex as/from converters */

 /*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pycomplex.swg,23,%swig_cplxdbl_conv@*/
%fragment("SWIG_" "AsVal" "_" {std::complex<double>},"header",
	  fragment="SWIG_" "AsVal" "_" {double})
{
SWIGINTERN int
SWIG_AsVal_std_complex_Sl_double_Sg_  (PyObject *o, std::complex<double>* val)
{
  if (PyComplex_Check(o)) {
    if (val) *val = std::complex<double>(PyComplex_RealAsDouble(o), PyComplex_ImagAsDouble(o));
    return SWIG_OK;
  } else {
    double d;    
    int res = SWIG_AddCast(SWIG_AsVal_double (o, &d));
    if (SWIG_IsOK(res)) {
      if (val) *val = std::complex<double>(d, 0.0);
      return res;
    }
  }
  return SWIG_TypeError;
}
}
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pycomplex.swg,11,%swig_fromcplx_conv@*/
%fragment("SWIG_" "From" "_" {std::complex<double>},"header")
{
SWIGINTERNINLINE PyObject*
SWIG_From_std_complex_Sl_double_Sg_  (/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/swigmacros.swg,104,%ifcplusplus@*/

const std::complex<double>&



/*@SWIG@*/ c)
{
  return PyComplex_FromDoubles(std::real(c), std::imag(c));
}
}
/*@SWIG@*/;
/*@SWIG@*/
 /*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pycomplex.swg,48,%swig_cplxflt_conv@*/
%fragment("SWIG_" "AsVal" "_" {std::complex<float>},"header",
          fragment="SWIG_" "AsVal" "_" {float}) {
SWIGINTERN int
SWIG_AsVal_std_complex_Sl_float_Sg_ (PyObject *o, std::complex<float> *val)
{
  if (PyComplex_Check(o)) {
    double re = PyComplex_RealAsDouble(o);
    double im = PyComplex_ImagAsDouble(o);
    if ((-FLT_MAX <= re && re <= FLT_MAX) && (-FLT_MAX <= im && im <= FLT_MAX)) {
      if (val) *val = std::complex<float>(static_cast< float >(re),
				  static_cast< float >(im));
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }    
  } else {
    float re;
    int res = SWIG_AddCast(SWIG_AsVal_float (o, &re));
    if (SWIG_IsOK(res)) {
      if (val) *val = std::complex<float>(re, 0.0);
      return res;
    }
  }
  return SWIG_TypeError;
}
}

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/python/pycomplex.swg,11,%swig_fromcplx_conv@*/
%fragment("SWIG_" "From" "_" {std::complex<float>},"header")
{
SWIGINTERNINLINE PyObject*
SWIG_From_std_complex_Sl_float_Sg_  (/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/swigmacros.swg,104,%ifcplusplus@*/

const std::complex<float>&



/*@SWIG@*/ c)
{
  return PyComplex_FromDoubles(std::real(c), std::imag(c));
}
}
/*@SWIG@*/;
/*@SWIG@*/

/* defining the typemaps */

/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<double>}) std::complex<double> (std::complex<double> val, int ecode = 0) {
    ecode = SWIG_AsVal_std_complex_Sl_double_Sg_($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) std::complex<double> "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<double>}) const std::complex<double> & ($*ltype temp, std::complex<double> val, int ecode = 0) {  
    ecode = SWIG_AsVal_std_complex_Sl_double_Sg_($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const std::complex<double>& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {std::complex<double>}) std::complex<double> {
    std::complex<double> val;
    int res = SWIG_AsVal_std_complex_Sl_double_Sg_($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<double>}) std::complex<double> *DIRECTOROUT(std::complex<double> swig_val, int swig_res) {
    swig_res = SWIG_AsVal_std_complex_Sl_double_Sg_($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<double>}) std::complex<double> {
    std::complex<double> swig_val;
    int swig_res = SWIG_AsVal_std_complex_Sl_double_Sg_($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<double>},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const std::complex<double>& {  
    std::complex<double> swig_val;
    int swig_res = SWIG_AsVal_std_complex_Sl_double_Sg_($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const std::complex<double> & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {std::complex<double>}) std::complex<double> &DIRECTOROUT = std::complex<double>
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=100,fragment="SWIG_" "AsVal" "_" {std::complex<double>}) std::complex<double>, const std::complex<double>& {
    int res = SWIG_AsVal_std_complex_Sl_double_Sg_($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<double>}) std::complex<double> *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      std::complex<double> val; 
      int ecode = SWIG_AsVal_std_complex_Sl_double_Sg_($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<double>}) std::complex<double> &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      std::complex<double> val;
      int ecode = SWIG_AsVal_std_complex_Sl_double_Sg_($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") std::complex<double> *INPUT, std::complex<double> &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=100,fragment="SWIG_" "AsVal" "_" {std::complex<double>}) std::complex<double> *INPUT, std::complex<double> &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_std_complex_Sl_double_Sg_($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {std::complex<double>}) std::complex<double>, const std::complex<double> {
    $result = SWIG_From_std_complex_Sl_double_Sg_(static_cast< std::complex<double> >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {std::complex<double>}) const std::complex<double>& {
    $result = SWIG_From_std_complex_Sl_double_Sg_(static_cast< std::complex<double> >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {std::complex<double>}) std::complex<double>, const std::complex<double>&  {
    $result = SWIG_From_std_complex_Sl_double_Sg_(static_cast< std::complex<double> >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {std::complex<double>}) std::complex<double> {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_std_complex_Sl_double_Sg_(static_cast< std::complex<double> >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {std::complex<double>}) std::complex<double> *DIRECTORIN {
    $input = SWIG_From_std_complex_Sl_double_Sg_(static_cast< std::complex<double> >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {std::complex<double>}) std::complex<double>, const std::complex<double>& {
    $input = SWIG_From_std_complex_Sl_double_Sg_(static_cast< std::complex<double> >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {std::complex<double>}) std::complex<double> {
    SWIG_Python_Raise(SWIG_From_std_complex_Sl_double_Sg_(static_cast< std::complex<double> >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::complex<double> *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::complex<double> &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {std::complex<double>}) std::complex<double> *OUTPUT, std::complex<double> &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_std_complex_Sl_double_Sg_((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) std::complex<double> *INOUT = std::complex<double> *INPUT;
 %typemap(in) std::complex<double> &INOUT = std::complex<double> &INPUT;
 %typemap(typecheck) std::complex<double> *INOUT = std::complex<double> *INPUT;
 %typemap(typecheck) std::complex<double> &INOUT = std::complex<double> &INPUT;
 %typemap(argout) std::complex<double> *INOUT = std::complex<double> *OUTPUT;
 %typemap(argout) std::complex<double> &INOUT = std::complex<double> &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;
/*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,208,%typemaps_asvalfromn@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,197,%typemaps_asvalfrom@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,171,%typemaps_asval@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,33,%value_in_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<float>}) std::complex<float> (std::complex<float> val, int ecode = 0) {
    ecode = SWIG_AsVal_std_complex_Sl_float_Sg_($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$ltype""'");
    } 
    $1 = static_cast< $ltype >(val);
  }
  %typemap(freearg) std::complex<float> "";
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<float>}) const std::complex<float> & ($*ltype temp, std::complex<float> val, int ecode = 0) {  
    ecode = SWIG_AsVal_std_complex_Sl_float_Sg_($input, &val);
    if (!SWIG_IsOK(ecode)) {
      SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
    } 
    temp = static_cast< $*ltype >(val);
    $1 = &temp;
  }
  %typemap(freearg) const std::complex<float>& "";
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,66,%value_varin_typemap@*/
  %typemap(varin,fragment="SWIG_" "AsVal" "_" {std::complex<float>}) std::complex<float> {
    std::complex<float> val;
    int res = SWIG_AsVal_std_complex_Sl_float_Sg_($input, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""$name""' of type '""$type""'");
    }
    $1 = static_cast< $ltype >(val);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,109,%value_directorout_typemap@*/
  %typemap(directorargout,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<float>}) std::complex<float> *DIRECTOROUT(std::complex<float> swig_val, int swig_res) {
    swig_res = SWIG_AsVal_std_complex_Sl_float_Sg_($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<float>}) std::complex<float> {
    std::complex<float> swig_val;
    int swig_res = SWIG_AsVal_std_complex_Sl_float_Sg_($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    }
    $result = static_cast< $type >(swig_val);
  }
  %typemap(directorout,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<float>},warning= "473:Returning a pointer or reference in a director method is not recommended." ) const std::complex<float>& {  
    std::complex<float> swig_val;
    int swig_res = SWIG_AsVal_std_complex_Sl_float_Sg_($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""$type""'");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const std::complex<float> & {
    if (director) {
      director->swig_release_ownership(SWIG_as_voidptr($input));
    }
  }
  %typemap(directorout,fragment="SWIG_" "AsVal" "_" {std::complex<float>}) std::complex<float> &DIRECTOROUT = std::complex<float>
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,161,%value_typecheck_typemap@*/
  %typemap(typecheck,precedence=95,fragment="SWIG_" "AsVal" "_" {std::complex<float>}) std::complex<float>, const std::complex<float>& {
    int res = SWIG_AsVal_std_complex_Sl_float_Sg_($input, NULL);
    $1 = SWIG_CheckState(res);
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,250,%value_input_typemap@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,79,%_value_input_typemap@*/
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<float>}) std::complex<float> *INPUT ($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      std::complex<float> val; 
      int ecode = SWIG_AsVal_std_complex_Sl_float_Sg_($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment="SWIG_" "AsVal" "_" {std::complex<float>}) std::complex<float> &INPUT($*ltype temp, int res = 0) {
    if (!(SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&$1),$descriptor,$disown))))) {
      std::complex<float> val;
      int ecode = SWIG_AsVal_std_complex_Sl_float_Sg_($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$*ltype""'");
      }
      temp = static_cast< $*ltype >(val);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") std::complex<float> *INPUT, std::complex<float> &INPUT {
    if (SWIG_IsNewObj(res$argnum)) delete $1;
  }
  %typemap(typecheck,noblock=1,precedence=95,fragment="SWIG_" "AsVal" "_" {std::complex<float>}) std::complex<float> *INPUT, std::complex<float> &INPUT {
    void *ptr = 0;
    int res = SWIG_AsVal_std_complex_Sl_float_Sg_($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = (SWIG_IsOK((res = SWIG_ConvertPtr($input,SWIG_as_voidptrptr(&ptr),$1_descriptor,0))));
    }
  }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,183,%typemaps_from@*/
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,55,%value_out_typemap@*/
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {std::complex<float>}) std::complex<float>, const std::complex<float> {
    $result = SWIG_From_std_complex_Sl_float_Sg_(static_cast< std::complex<float> >($1)); 
  }
  %typemap(out,noblock=1,fragment="SWIG_" "From" "_" {std::complex<float>}) const std::complex<float>& {
    $result = SWIG_From_std_complex_Sl_float_Sg_(static_cast< std::complex<float> >(*$1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,79,%value_varout_typemap@*/
  %typemap(varout,noblock=1,fragment="SWIG_" "From" "_" {std::complex<float>}) std::complex<float>, const std::complex<float>&  {
    $result = SWIG_From_std_complex_Sl_float_Sg_(static_cast< std::complex<float> >($1));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,87,%value_constcode_typemap@*/
  %typemap(constcode,noblock=1,fragment="SWIG_" "From" "_" {std::complex<float>}) std::complex<float> {
    SWIG_Python_SetConstant(d, "$symname",SWIG_From_std_complex_Sl_float_Sg_(static_cast< std::complex<float> >($value)));
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,98,%value_directorin_typemap@*/
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {std::complex<float>}) std::complex<float> *DIRECTORIN {
    $input = SWIG_From_std_complex_Sl_float_Sg_(static_cast< std::complex<float> >(*$1)); 
  }
  %typemap(directorin,noblock=1,fragment="SWIG_" "From" "_" {std::complex<float>}) std::complex<float>, const std::complex<float>& {
    $input = SWIG_From_std_complex_Sl_float_Sg_(static_cast< std::complex<float> >($1)); 
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/valtypes.swg,153,%value_throws_typemap@*/
  %typemap(throws,noblock=1,fragment="SWIG_" "From" "_" {std::complex<float>}) std::complex<float> {
    SWIG_Python_Raise(SWIG_From_std_complex_Sl_float_Sg_(static_cast< std::complex<float> >($1)), "$type", 0); SWIG_fail;
  }
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,258,%value_output_typemap@*/		
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,175,%_value_output_typemap@*/
 %typemap(in,numinputs=0,noblock=1) 
   std::complex<float> *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   std::complex<float> &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment="SWIG_" "From" "_" {std::complex<float>}) std::complex<float> *OUTPUT, std::complex<float> &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     $result = SWIG_Python_AppendOutput($result, SWIG_From_std_complex_Sl_float_Sg_((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
     $result = SWIG_Python_AppendOutput($result, SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
/*@SWIG@*/
/*@SWIG@*/;
/*@SWIG@*/;
  /*@SWIG:/home/balos1/.local/share/swig/4.0.0/typemaps/inoutlist.swg,230,%_value_inout_typemap@*/
 %typemap(in) std::complex<float> *INOUT = std::complex<float> *INPUT;
 %typemap(in) std::complex<float> &INOUT = std::complex<float> &INPUT;
 %typemap(typecheck) std::complex<float> *INOUT = std::complex<float> *INPUT;
 %typemap(typecheck) std::complex<float> &INOUT = std::complex<float> &INPUT;
 %typemap(argout) std::complex<float> *INOUT = std::complex<float> *OUTPUT;
 %typemap(argout) std::complex<float> &INOUT = std::complex<float> &OUTPUT;
/*@SWIG@*/;
/*@SWIG@*/




;
/*@SWIG@*/;

%endoffile

/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (std::complex<float> IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float> IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float> IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (std::complex<float> IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<float>* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (std::complex<float>* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, std::complex<float>* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, std::complex<float>* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, std::complex<float>* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (std::complex<float>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, std::complex<float>* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<float> IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float> IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float> IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (std::complex<float> IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<float>* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (std::complex<float>* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, std::complex<float>* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, std::complex<float>* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, std::complex<float>* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (std::complex<float>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, std::complex<float>* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<float>* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_CFLOAT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (std::complex<float>* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, std::complex<float>* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, std::complex<float>* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, std::complex<float>* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (std::complex<float>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, std::complex<float>* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<float> IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float> IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float> IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (std::complex<float> IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<float>* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (std::complex<float>* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<float>** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (std::complex<float>** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (std::complex<float> **)malloc($2*sizeof(std::complex<float> *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_CFLOAT, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (std::complex<float>*) array_data(temp_array);
  }

  $1 = (std::complex<float>**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (std::complex<float>** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    std::complex<float>* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, std::complex<float>* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, std::complex<float>* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (std::complex<float>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, std::complex<float>* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<float>* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_CFLOAT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (std::complex<float>* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    std::complex<float>* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, std::complex<float>* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, std::complex<float>* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (std::complex<float>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, std::complex<float>* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<float> IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float> IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float> IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (std::complex<float> IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<float>* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (std::complex<float>* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<float>** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (std::complex<float>** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (std::complex<float> **)malloc($2*sizeof(std::complex<float> *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_CFLOAT, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (std::complex<float>*) array_data(temp_array);
  }

  $1 = (std::complex<float>**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (std::complex<float>** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    std::complex<float>* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<float>* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<float>* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (std::complex<float>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<float>* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<float>* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_CFLOAT,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (std::complex<float>* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    std::complex<float>* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<float>* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<float>* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_CFLOAT,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (std::complex<float>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<float>* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (std::complex<float> INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float> INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float> INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (std::complex<float>* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, std::complex<float>* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, std::complex<float>* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, std::complex<float>* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (std::complex<float>*) array_data(array);
}

/* Typemap suite for (std::complex<float> INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float> INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float> INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (std::complex<float>* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, std::complex<float>* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, std::complex<float>* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, std::complex<float>* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (std::complex<float>*) array_data(array);
}

/* Typemap suite for (std::complex<float>* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, std::complex<float>* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, std::complex<float>* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, std::complex<float>* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (std::complex<float>*) array_data(array);
}

/* Typemap suite for (std::complex<float> INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float> INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float> INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (std::complex<float>* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (std::complex<float>** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (std::complex<float>** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (std::complex<float> **)malloc($2*sizeof(std::complex<float> *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_CFLOAT);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_CFLOAT)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (std::complex<float>*) array_data(temp_array);
  }

  $1 = (std::complex<float>**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (std::complex<float>** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    std::complex<float>* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, std::complex<float>* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, std::complex<float>* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (std::complex<float>*) array_data(array);
}

/* Typemap suite for (std::complex<float>* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    std::complex<float>* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, std::complex<float>* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, std::complex<float>* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (std::complex<float>*) array_data(array);
}

/* Typemap suite for (std::complex<float> INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float> INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float> INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (std::complex<float>* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (std::complex<float>** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (std::complex<float>** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (std::complex<float> **)malloc($2*sizeof(std::complex<float> *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_CFLOAT);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_CFLOAT)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (std::complex<float>*) array_data(temp_array);
  }

  $1 = (std::complex<float>**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (std::complex<float>** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    std::complex<float>* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<float>* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<float>* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (std::complex<float>*) array_data(array);
}

/* Typemap suite for (std::complex<float>* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    std::complex<float>* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<float>* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<float>* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (std::complex<float>*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (std::complex<float> ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (std::complex<float> ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_CFLOAT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (std::complex<float> ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (std::complex<float>* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (std::complex<float>* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_CFLOAT);
  if (!array) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
}
%typemap(argout)
  (std::complex<float>* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, std::complex<float>* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, std::complex<float>* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_CFLOAT);
  if (!array) SWIG_fail;
  $2 = (std::complex<float>*) array_data(array);
}
%typemap(argout)
  (int DIM1, std::complex<float>* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (std::complex<float> ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (std::complex<float> ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_CFLOAT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (std::complex<float> ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (std::complex<float> ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (std::complex<float> ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_CFLOAT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (std::complex<float> ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (std::complex<float> ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (std::complex<float> ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_CFLOAT);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (std::complex<float> ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (std::complex<float>** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (std::complex<float>*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (std::complex<float>** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, std::complex<float>** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , std::complex<float>** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, std::complex<float>*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, std::complex<float>** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_CFLOAT, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (std::complex<float>*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (std::complex<float>** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, std::complex<float>** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , std::complex<float>** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, std::complex<float>*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, std::complex<float>** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CFLOAT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (std::complex<float>*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (std::complex<float>** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, std::complex<float>** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , std::complex<float>** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, std::complex<float>*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, std::complex<float>** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CFLOAT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (std::complex<float>* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (std::complex<float>** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      std::complex<float>** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, std::complex<float>** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, std::complex<float>* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, std::complex<float>** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CFLOAT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (std::complex<float>* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (std::complex<float>** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      std::complex<float>** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , std::complex<float>** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, std::complex<float>* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, std::complex<float>** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CFLOAT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (std::complex<float>* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (std::complex<float>** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      std::complex<float>** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , std::complex<float>** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, std::complex<float>* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, std::complex<float>** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CFLOAT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (std::complex<float>* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (std::complex<float>** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      std::complex<float>** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , std::complex<float>** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, std::complex<float>* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, std::complex<float>** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CFLOAT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (std::complex<float>** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (std::complex<float>*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (std::complex<float>** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, std::complex<float>** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , std::complex<float>** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, std::complex<float>*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, std::complex<float>** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_CFLOAT, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (std::complex<float>*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (std::complex<float>** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, std::complex<float>** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , std::complex<float>** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, std::complex<float>*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, std::complex<float>** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CFLOAT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (std::complex<float>*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (std::complex<float>** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, std::complex<float>** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , std::complex<float>** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, std::complex<float>*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, std::complex<float>** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CFLOAT, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (std::complex<float>* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (std::complex<float>** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      std::complex<float>** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , std::complex<float>** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, std::complex<float>* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, std::complex<float>** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_CFLOAT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (std::complex<float>* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (std::complex<float>** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      std::complex<float>** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , std::complex<float>** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, std::complex<float>* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, std::complex<float>** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CFLOAT, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (std::complex<float>* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (std::complex<float>** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      std::complex<float>** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , std::complex<float>** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, std::complex<float>* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, std::complex<float>** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CFLOAT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (std::complex<float>* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (std::complex<float>** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      std::complex<float>** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , std::complex<float>** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, std::complex<float>* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, std::complex<float>** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CFLOAT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (std::complex<float>* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (std::complex<float>** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      std::complex<float>** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , std::complex<float>** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, std::complex<float>* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, std::complex<float>** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CFLOAT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<float>** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (std::complex<float>** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (std::complex<float>* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (std::complex<float>** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CFLOAT, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      std::complex<float>** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , std::complex<float>** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, std::complex<float>* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, std::complex<float>** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CFLOAT, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (std::complex<float>* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<float>* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CFLOAT);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<float>* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_CFLOAT);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (std::complex<float>*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/
/*@SWIG:numpy.i,717,%numpy_typemaps@*/

/************************/
/* Input Array Typemaps */
/************************/

/* Typemap suite for (std::complex<double> IN_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double> IN_ARRAY1[ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double> IN_ARRAY1[ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (std::complex<double> IN_ARRAY1[ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<double>* IN_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* IN_ARRAY1, int DIM1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* IN_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = { -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = (int) array_size(array,0);
}
%typemap(freearg)
  (std::complex<double>* IN_ARRAY1, int DIM1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, std::complex<double>* IN_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, std::complex<double>* IN_ARRAY1)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, std::complex<double>* IN_ARRAY1)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[1] = {-1};
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 1) ||
      !require_size(array, size, 1)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (std::complex<double>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, std::complex<double>* IN_ARRAY1)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<double> IN_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double> IN_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double> IN_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (std::complex<double> IN_ARRAY2[ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<double>* IN_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* IN_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* IN_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (std::complex<double>* IN_ARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, std::complex<double>* IN_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, std::complex<double>* IN_ARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, std::complex<double>* IN_ARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (std::complex<double>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, std::complex<double>* IN_ARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<double>* IN_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* IN_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* IN_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                NPY_CDOUBLE,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}
%typemap(freearg)
  (std::complex<double>* IN_FARRAY2, int DIM1, int DIM2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, std::complex<double>* IN_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, std::complex<double>* IN_FARRAY2)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, std::complex<double>* IN_FARRAY2)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[2] = { -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 2) ||
      !require_size(array, size, 2) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (std::complex<double>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, std::complex<double>* IN_FARRAY2)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<double> IN_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double> IN_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double> IN_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_contiguous_allow_conversion($input,
                                                   NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (std::complex<double> IN_ARRAY3[ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<double>* IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (std::complex<double>* IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<double>** IN_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
  (std::complex<double>** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (std::complex<double> **)malloc($2*sizeof(std::complex<double> *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_CDOUBLE, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 2)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (std::complex<double>*) array_data(temp_array);
  }

  $1 = (std::complex<double>**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (std::complex<double>** IN_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    std::complex<double>* IN_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, std::complex<double>* IN_ARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, std::complex<double>* IN_ARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (std::complex<double>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, std::complex<double>* IN_ARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<double>* IN_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_CDOUBLE,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) | !require_fortran(array)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}
%typemap(freearg)
  (std::complex<double>* IN_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    std::complex<double>* IN_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, std::complex<double>* IN_FARRAY3)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, std::complex<double>* IN_FARRAY3)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[3] = { -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input,
                                                   NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 3) ||
      !require_size(array, size, 3) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (std::complex<double>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, std::complex<double>* IN_FARRAY3)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<double> IN_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double> IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double> IN_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(freearg)
  (std::complex<double> IN_ARRAY4[ANY][ANY][ANY][ANY])
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<double>* IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_contiguous_allow_conversion($input, NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (std::complex<double>* IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<double>** IN_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  /* for now, only concerned with lists */
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (std::complex<double>** array=NULL, PyArrayObject** object_array=NULL, int* is_new_object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;
  int is_new_object;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (std::complex<double> **)malloc($2*sizeof(std::complex<double> *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));
  is_new_object_array = (int *)calloc($2,sizeof(int));

  if (array == NULL || object_array == NULL || is_new_object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_contiguous_allow_conversion(PySequence_GetItem($input,i), NPY_CDOUBLE, &is_new_object);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;
    is_new_object_array[i] = is_new_object;

    if (!temp_array || !require_dimensions(temp_array, 3)) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (std::complex<double>*) array_data(temp_array);
  }

  $1 = (std::complex<double>**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (std::complex<double>** IN_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  Py_ssize_t i;

  if (array$argnum!=NULL) free(array$argnum);

  /*freeing the individual arrays if needed */
  if (object_array$argnum!=NULL)
  {
    if (is_new_object_array$argnum!=NULL)
    {
      for (i=0; i<$2; i++)
      {
        if (object_array$argnum[i] != NULL && is_new_object_array$argnum[i])
        { Py_DECREF(object_array$argnum[i]); }
      }
      free(is_new_object_array$argnum);
    }
    free(object_array$argnum);
  }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    std::complex<double>* IN_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<double>* IN_ARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<double>* IN_ARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1};
  array = obj_to_array_contiguous_allow_conversion($input, NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (std::complex<double>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<double>* IN_ARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (std::complex<double>* IN_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1, -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_CDOUBLE,
                                                &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) | !require_fortran(array)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}
%typemap(freearg)
  (std::complex<double>* IN_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    std::complex<double>* IN_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<double>* IN_FARRAY4)
{
  $1 = is_array($input) || PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<double>* IN_FARRAY4)
  (PyArrayObject* array=NULL, int is_new_object=0)
{
  npy_intp size[4] = { -1, -1, -1 , -1 };
  array = obj_to_array_fortran_allow_conversion($input, NPY_CDOUBLE,
                                                   &is_new_object);
  if (!array || !require_dimensions(array, 4) ||
      !require_size(array, size, 4) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (std::complex<double>*) array_data(array);
}
%typemap(freearg)
  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<double>* IN_FARRAY4)
{
  if (is_new_object$argnum && array$argnum)
    { Py_DECREF(array$argnum); }
}

/***************************/
/* In-Place Array Typemaps */
/***************************/

/* Typemap suite for (std::complex<double> INPLACE_ARRAY1[ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double> INPLACE_ARRAY1[ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double> INPLACE_ARRAY1[ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[1] = { $1_dim0 };
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,1) || !require_size(array, size, 1) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (std::complex<double>* INPLACE_ARRAY1, int DIM1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* INPLACE_ARRAY1, int DIM1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* INPLACE_ARRAY1, int DIM1)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/* Typemap suite for (int DIM1, std::complex<double>* INPLACE_ARRAY1)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, std::complex<double>* INPLACE_ARRAY1)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, std::complex<double>* INPLACE_ARRAY1)
  (PyArrayObject* array=NULL, int i=0)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,1) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = 1;
  for (i=0; i < array_numdims(array); ++i) $1 *= array_size(array,i);
  $2 = (std::complex<double>*) array_data(array);
}

/* Typemap suite for (std::complex<double> INPLACE_ARRAY2[ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double> INPLACE_ARRAY2[ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double> INPLACE_ARRAY2[ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[2] = { $1_dim0, $1_dim1 };
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,2) || !require_size(array, size, 2) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (std::complex<double>* INPLACE_ARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* INPLACE_ARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* INPLACE_ARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, std::complex<double>* INPLACE_ARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, std::complex<double>* INPLACE_ARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, std::complex<double>* INPLACE_ARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (std::complex<double>*) array_data(array);
}

/* Typemap suite for (std::complex<double>* INPLACE_FARRAY2, int DIM1, int DIM2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* INPLACE_FARRAY2, int DIM1, int DIM2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* INPLACE_FARRAY2, int DIM1, int DIM2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
}

/* Typemap suite for (int DIM1, int DIM2, std::complex<double>* INPLACE_FARRAY2)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, std::complex<double>* INPLACE_FARRAY2)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, std::complex<double>* INPLACE_FARRAY2)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,2) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (std::complex<double>*) array_data(array);
}

/* Typemap suite for (std::complex<double> INPLACE_ARRAY3[ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double> INPLACE_ARRAY3[ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double> INPLACE_ARRAY3[ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,3) || !require_size(array, size, 3) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (std::complex<double>* INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (std::complex<double>** INPLACE_ARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
  (std::complex<double>** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[2] = { -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (std::complex<double> **)malloc($2*sizeof(std::complex<double> *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_CDOUBLE);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 2) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_CDOUBLE)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
    }

    if (!require_size(temp_array, size, 2)) SWIG_fail;

    array[i] = (std::complex<double>*) array_data(temp_array);
  }

  $1 = (std::complex<double>**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
}
%typemap(freearg)
  (std::complex<double>** INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    std::complex<double>* INPLACE_ARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, std::complex<double>* INPLACE_ARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, std::complex<double>* INPLACE_ARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (std::complex<double>*) array_data(array);
}

/* Typemap suite for (std::complex<double>* INPLACE_FARRAY3, int DIM1, int DIM2,
 *                    int DIM3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    std::complex<double>* INPLACE_FARRAY3)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, std::complex<double>* INPLACE_FARRAY3)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, std::complex<double>* INPLACE_FARRAY3)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,3) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (std::complex<double>*) array_data(array);
}

/* Typemap suite for (std::complex<double> INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double> INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double> INPLACE_ARRAY4[ANY][ANY][ANY][ANY])
  (PyArrayObject* array=NULL)
{
  npy_intp size[4] = { $1_dim0, $1_dim1, $1_dim2 , $1_dim3 };
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,4) || !require_size(array, size, 4) ||
      !require_contiguous(array) || !require_native(array)) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}

/* Typemap suite for (std::complex<double>* INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (std::complex<double>** INPLACE_ARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = PySequence_Check($input);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (std::complex<double>** array=NULL, PyArrayObject** object_array=NULL)
{
  npy_intp size[3] = { -1, -1, -1 };
  PyArrayObject* temp_array;
  Py_ssize_t i;

  /* length of the list */
  $2 = PyList_Size($input);

  /* the arrays */
  array = (std::complex<double> **)malloc($2*sizeof(std::complex<double> *));
  object_array = (PyArrayObject **)calloc($2,sizeof(PyArrayObject *));

  if (array == NULL || object_array == NULL)
  {
    SWIG_fail;
  }

  for (i=0; i<$2; i++)
  {
    temp_array = obj_to_array_no_conversion(PySequence_GetItem($input,i), NPY_CDOUBLE);

    /* the new array must be stored so that it can be destroyed in freearg */
    object_array[i] = temp_array;

    if ( !temp_array || !require_dimensions(temp_array, 3) ||
      !require_contiguous(temp_array) ||
      !require_native(temp_array) ||
      !PyArray_EquivTypenums(array_type(temp_array), NPY_CDOUBLE)
    ) SWIG_fail;

    /* store the size of the first array in the list, then use that for comparison. */
    if (i == 0)
    {
      size[0] = array_size(temp_array,0);
      size[1] = array_size(temp_array,1);
      size[2] = array_size(temp_array,2);
    }

    if (!require_size(temp_array, size, 3)) SWIG_fail;

    array[i] = (std::complex<double>*) array_data(temp_array);
  }

  $1 = (std::complex<double>**) array;
  $3 = (int) size[0];
  $4 = (int) size[1];
  $5 = (int) size[2];
}
%typemap(freearg)
  (std::complex<double>** INPLACE_ARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  if (array$argnum!=NULL) free(array$argnum);
  if (object_array$argnum!=NULL) free(object_array$argnum);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3, int DIM4,
 *                    std::complex<double>* INPLACE_ARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<double>* INPLACE_ARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<double>* INPLACE_ARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (std::complex<double>*) array_data(array);
}

/* Typemap suite for (std::complex<double>* INPLACE_FARRAY4, int DIM1, int DIM2,
 *                    int DIM3, int DIM4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* INPLACE_FARRAY4, int DIM1, int DIM2, int DIM3, int DIM4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array) ||
      !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = (int) array_size(array,0);
  $3 = (int) array_size(array,1);
  $4 = (int) array_size(array,2);
  $5 = (int) array_size(array,3);
}

/* Typemap suite for (int DIM1, int DIM2, int DIM3,
 *                    std::complex<double>* INPLACE_FARRAY4)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<double>* INPLACE_FARRAY4)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (int DIM1, int DIM2, int DIM3, int DIM4, std::complex<double>* INPLACE_FARRAY4)
  (PyArrayObject* array=NULL)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_dimensions(array,4) || !require_contiguous(array)
      || !require_native(array) || !require_fortran(array)) SWIG_fail;
  $1 = (int) array_size(array,0);
  $2 = (int) array_size(array,1);
  $3 = (int) array_size(array,2);
  $4 = (int) array_size(array,3);
  $5 = (std::complex<double>*) array_data(array);
}

/*************************/
/* Argout Array Typemaps */
/*************************/

/* Typemap suite for (std::complex<double> ARGOUT_ARRAY1[ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (std::complex<double> ARGOUT_ARRAY1[ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[1] = { $1_dim0 };
  array = PyArray_SimpleNew(1, dims, NPY_CDOUBLE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (std::complex<double> ARGOUT_ARRAY1[ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (std::complex<double>* ARGOUT_ARRAY1, int DIM1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (std::complex<double>* ARGOUT_ARRAY1, int DIM1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $2 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $2;
  array = PyArray_SimpleNew(1, dims, NPY_CDOUBLE);
  if (!array) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
}
%typemap(argout)
  (std::complex<double>* ARGOUT_ARRAY1, int DIM1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (int DIM1, std::complex<double>* ARGOUT_ARRAY1)
 */
%typemap(in,numinputs=1,
         fragment="NumPy_Fragments")
  (int DIM1, std::complex<double>* ARGOUT_ARRAY1)
  (PyObject* array = NULL)
{
  npy_intp dims[1];
  if (!PyInt_Check($input))
  {
    const char* typestring = pytype_string($input);
    PyErr_Format(PyExc_TypeError,
                 "Int dimension expected.  '%s' given.",
                 typestring);
    SWIG_fail;
  }
  $1 = (int) PyInt_AsLong($input);
  dims[0] = (npy_intp) $1;
  array = PyArray_SimpleNew(1, dims, NPY_CDOUBLE);
  if (!array) SWIG_fail;
  $2 = (std::complex<double>*) array_data(array);
}
%typemap(argout)
  (int DIM1, std::complex<double>* ARGOUT_ARRAY1)
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (std::complex<double> ARGOUT_ARRAY2[ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (std::complex<double> ARGOUT_ARRAY2[ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[2] = { $1_dim0, $1_dim1 };
  array = PyArray_SimpleNew(2, dims, NPY_CDOUBLE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (std::complex<double> ARGOUT_ARRAY2[ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (std::complex<double> ARGOUT_ARRAY3[ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (std::complex<double> ARGOUT_ARRAY3[ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[3] = { $1_dim0, $1_dim1, $1_dim2 };
  array = PyArray_SimpleNew(3, dims, NPY_CDOUBLE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (std::complex<double> ARGOUT_ARRAY3[ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/* Typemap suite for (std::complex<double> ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
 */
%typemap(in,numinputs=0,
         fragment="NumPy_Backward_Compatibility,NumPy_Macros")
  (std::complex<double> ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
  (PyObject* array = NULL)
{
  npy_intp dims[4] = { $1_dim0, $1_dim1, $1_dim2, $1_dim3 };
  array = PyArray_SimpleNew(4, dims, NPY_CDOUBLE);
  if (!array) SWIG_fail;
  $1 = ($1_ltype) array_data(array);
}
%typemap(argout)
  (std::complex<double> ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])
{
  $result = SWIG_Python_AppendOutput($result,(PyObject*)array$argnum);
}

/*****************************/
/* Argoutview Array Typemaps */
/*****************************/

/* Typemap suite for (std::complex<double>** ARGOUTVIEW_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEW_ARRAY1, int* DIM1    )
  (std::complex<double>*  data_temp = NULL , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (std::complex<double>** ARGOUTVIEW_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, std::complex<double>** ARGOUTVIEW_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , std::complex<double>** ARGOUTVIEW_ARRAY1)
  (int  dim_temp, std::complex<double>*  data_temp = NULL )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, std::complex<double>** ARGOUTVIEW_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_CDOUBLE, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEW_ARRAY2, int* DIM1     , int* DIM2     )
  (std::complex<double>*  data_temp = NULL , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (std::complex<double>** ARGOUTVIEW_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, std::complex<double>** ARGOUTVIEW_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , std::complex<double>** ARGOUTVIEW_ARRAY2)
  (int  dim1_temp, int  dim2_temp, std::complex<double>*  data_temp = NULL )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, std::complex<double>** ARGOUTVIEW_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CDOUBLE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEW_FARRAY2, int* DIM1     , int* DIM2     )
  (std::complex<double>*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (std::complex<double>** ARGOUTVIEW_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, std::complex<double>** ARGOUTVIEW_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , std::complex<double>** ARGOUTVIEW_FARRAY2)
  (int  dim1_temp, int  dim2_temp, std::complex<double>*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, std::complex<double>** ARGOUTVIEW_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CDOUBLE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEW_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (std::complex<double>* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (std::complex<double>** ARGOUTVIEW_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      std::complex<double>** ARGOUTVIEW_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1, int* DIM2, int* DIM3, std::complex<double>** ARGOUTVIEW_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, std::complex<double>* data_temp = NULL)
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, std::complex<double>** ARGOUTVIEW_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CDOUBLE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEW_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (std::complex<double>* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (std::complex<double>** ARGOUTVIEW_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      std::complex<double>** ARGOUTVIEW_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , std::complex<double>** ARGOUTVIEW_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, std::complex<double>* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, std::complex<double>** ARGOUTVIEW_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CDOUBLE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEW_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (std::complex<double>* data_temp = NULL  , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (std::complex<double>** ARGOUTVIEW_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      std::complex<double>** ARGOUTVIEW_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , std::complex<double>** ARGOUTVIEW_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, std::complex<double>* data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, std::complex<double>** ARGOUTVIEW_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CDOUBLE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEW_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (std::complex<double>* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (std::complex<double>** ARGOUTVIEW_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      std::complex<double>** ARGOUTVIEW_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , std::complex<double>** ARGOUTVIEW_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, std::complex<double>* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, std::complex<double>** ARGOUTVIEW_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CDOUBLE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;
  $result = SWIG_Python_AppendOutput($result,obj);
}

/*************************************/
/* Managed Argoutview Array Typemaps */
/*************************************/

/* Typemap suite for (std::complex<double>** ARGOUTVIEWM_ARRAY1, int* DIM1)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEWM_ARRAY1, int* DIM1    )
  (std::complex<double>*  data_temp = NULL  , int  dim_temp)
{
  $1 = &data_temp;
  $2 = &dim_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (std::complex<double>** ARGOUTVIEWM_ARRAY1, int* DIM1)
{
  npy_intp dims[1] = { *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, std::complex<double>** ARGOUTVIEWM_ARRAY1)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , std::complex<double>** ARGOUTVIEWM_ARRAY1)
  (int  dim_temp, std::complex<double>*  data_temp = NULL  )
{
  $1 = &dim_temp;
  $2 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, std::complex<double>** ARGOUTVIEWM_ARRAY1)
{
  npy_intp dims[1] = { *$1 };
  PyObject* obj = PyArray_SimpleNewFromData(1, dims, NPY_CDOUBLE, (void*)(*$2));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEWM_ARRAY2, int* DIM1     , int* DIM2     )
  (std::complex<double>*  data_temp = NULL  , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (std::complex<double>** ARGOUTVIEWM_ARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, std::complex<double>** ARGOUTVIEWM_ARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , std::complex<double>** ARGOUTVIEWM_ARRAY2)
  (int  dim1_temp, int  dim2_temp, std::complex<double>*  data_temp = NULL  )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, std::complex<double>** ARGOUTVIEWM_ARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CDOUBLE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEWM_FARRAY2, int* DIM1     , int* DIM2     )
  (std::complex<double>*  data_temp = NULL   , int  dim1_temp, int  dim2_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (std::complex<double>** ARGOUTVIEWM_FARRAY2, int* DIM1, int* DIM2)
{
  npy_intp dims[2] = { *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, std::complex<double>** ARGOUTVIEWM_FARRAY2)
 */
%typemap(in,numinputs=0)
  (int* DIM1     , int* DIM2     , std::complex<double>** ARGOUTVIEWM_FARRAY2)
  (int  dim1_temp, int  dim2_temp, std::complex<double>*  data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, std::complex<double>** ARGOUTVIEWM_FARRAY2)
{
  npy_intp dims[2] = { *$1, *$2 };
  PyObject* obj = PyArray_SimpleNewFromData(2, dims, NPY_CDOUBLE, (void*)(*$3));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEWM_ARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (std::complex<double>* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (std::complex<double>** ARGOUTVIEWM_ARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      std::complex<double>** ARGOUTVIEWM_ARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , std::complex<double>** ARGOUTVIEWM_ARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, std::complex<double>* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, std::complex<double>** ARGOUTVIEWM_ARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj= PyArray_SimpleNewFromData(3, dims, NPY_CDOUBLE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2,
                      int* DIM3)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEWM_FARRAY3, int* DIM1    , int* DIM2    , int* DIM3    )
  (std::complex<double>* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (std::complex<double>** ARGOUTVIEWM_FARRAY3, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[3] = { *$2, *$3, *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3,
                      std::complex<double>** ARGOUTVIEWM_FARRAY3)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , std::complex<double>** ARGOUTVIEWM_FARRAY3)
  (int dim1_temp, int dim2_temp, int dim3_temp, std::complex<double>* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, std::complex<double>** ARGOUTVIEWM_FARRAY3)
{
  npy_intp dims[3] = { *$1, *$2, *$3 };
  PyObject* obj = PyArray_SimpleNewFromData(3, dims, NPY_CDOUBLE, (void*)(*$4));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (std::complex<double>* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (std::complex<double>** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      std::complex<double>** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , std::complex<double>** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, std::complex<double>* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, std::complex<double>** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CDOUBLE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (std::complex<double>* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (std::complex<double>** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      std::complex<double>** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , std::complex<double>** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, std::complex<double>* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, std::complex<double>** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CDOUBLE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEWM_ARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (std::complex<double>* data_temp = NULL   , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (std::complex<double>** ARGOUTVIEWM_ARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      std::complex<double>** ARGOUTVIEWM_ARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , std::complex<double>** ARGOUTVIEWM_ARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, std::complex<double>* data_temp = NULL   )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, std::complex<double>** ARGOUTVIEWM_ARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CDOUBLE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (std::complex<double>** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2,
                      int* DIM3, int* DIM4)
 */
%typemap(in,numinputs=0)
  (std::complex<double>** ARGOUTVIEWM_FARRAY4, int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    )
  (std::complex<double>* data_temp = NULL    , int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp)
{
  $1 = &data_temp;
  $2 = &dim1_temp;
  $3 = &dim2_temp;
  $4 = &dim3_temp;
  $5 = &dim4_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (std::complex<double>** ARGOUTVIEWM_FARRAY4, int* DIM1, int* DIM2, int* DIM3, int* DIM4)
{
  npy_intp dims[4] = { *$2, *$3, *$4 , *$5 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CDOUBLE, (void*)(*$1));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/* Typemap suite for (int* DIM1, int* DIM2, int* DIM3, int* DIM4,
                      std::complex<double>** ARGOUTVIEWM_FARRAY4)
 */
%typemap(in,numinputs=0)
  (int* DIM1    , int* DIM2    , int* DIM3    , int* DIM4    , std::complex<double>** ARGOUTVIEWM_FARRAY4)
  (int dim1_temp, int dim2_temp, int dim3_temp, int dim4_temp, std::complex<double>* data_temp = NULL    )
{
  $1 = &dim1_temp;
  $2 = &dim2_temp;
  $3 = &dim3_temp;
  $4 = &dim4_temp;
  $5 = &data_temp;
}
%typemap(argout,
         fragment="NumPy_Backward_Compatibility,NumPy_Array_Requirements,NumPy_Utilities")
  (int* DIM1, int* DIM2, int* DIM3, int* DIM4, std::complex<double>** ARGOUTVIEWM_FARRAY4)
{
  npy_intp dims[4] = { *$1, *$2, *$3 , *$4 };
  PyObject* obj = PyArray_SimpleNewFromData(4, dims, NPY_CDOUBLE, (void*)(*$5));
  PyArrayObject* array = (PyArrayObject*) obj;

  if (!array || !require_fortran(array)) SWIG_fail;

#ifdef SWIGPY_USE_CAPSULE
    PyObject* cap = PyCapsule_New((void*)(*$1), SWIGPY_CAPSULE_NAME, free_cap);
#else
    PyObject* cap = PyCObject_FromVoidPtr((void*)(*$1), free);
#endif

#if NPY_API_VERSION < 0x00000007
  PyArray_BASE(array) = cap;
#else
  PyArray_SetBaseObject(array,cap);
#endif

  $result = SWIG_Python_AppendOutput($result,obj);
}

/**************************************/
/* In-Place Array Typemap - flattened */
/**************************************/

/* Typemap suite for (std::complex<double>* INPLACE_ARRAY_FLAT, int DIM_FLAT)
 */
 %typemap(typecheck, precedence=     1090    ,fragment="NumPy_Macros") 

  (std::complex<double>* INPLACE_ARRAY_FLAT, int DIM_FLAT)
{
  $1 = is_array($input) && PyArray_EquivTypenums(array_type($input),
                                                 NPY_CDOUBLE);
}
%typemap(in,
         fragment="NumPy_Fragments")
  (std::complex<double>* INPLACE_ARRAY_FLAT, int DIM_FLAT)
  (PyArrayObject* array=NULL, int i=1)
{
  array = obj_to_array_no_conversion($input, NPY_CDOUBLE);
  if (!array || !require_c_or_f_contiguous(array)
      || !require_native(array)) SWIG_fail;
  $1 = (std::complex<double>*) array_data(array);
  $2 = 1;
  for (i=0; i < array_numdims(array); ++i) $2 *= array_size(array,i);
}

/*@SWIG@*/




%endoffile
%insert("init") %{
import_array();
%}

// -------------------------------
// Bring in shared sundials stuff.
// -------------------------------

%includefile "../sundials/sundials.i" %beginfile
// ---------------------------------------------------------------
// Programmer: Cody J. Balos @ LLNL
// ---------------------------------------------------------------
// SUNDIALS Copyright Start
// Copyright (c) 2002-2019, Lawrence Livermore National Security
// and Southern Methodist University.
// All rights reserved.
//
// See the top-level LICENSE and NOTICE files for details.
//
// SPDX-License-Identifier: BSD-3-Clause
// SUNDIALS Copyright End
// ---------------------------------------------------------------
// Swig interface file
// ---------------------------------------------------------------

// Inform SWIG of the SUNDIALS_EXPORT macro



// Inform SWIG of the configure-provided types





// Rename generic structs
%rename(N_Vector) _generic_N_Vector;
%rename(N_Vector_Ops) _generic_N_Vector_Ops;
%rename(SUNMatrix) _generic_SUNMatrix;
%rename(SUNMatrix_Ops) _generic_SUNMatrix_Ops;
%rename(SUNLinearSolver) _generic_SUNLinearSolver;
%rename(SUNLinearSolver_Ops) _generic_SUNLinearSolver_Ops;
%rename(SUNNonlinearSolver) _generic_SUNNonlinearSolver;
%rename(SUNNonlinearSolver_Ops) _generic_SUNNonlinearSolver_Ops;

// Apply typemaps for arrays/poitners
%apply (int DIM1, double* IN_ARRAY1) {(sunindextype vec_length, realtype *v_data)}
%apply (int* DIM1, double** ARGOUTVIEW_ARRAY1) {(sunindextype *length, realtype **data)}

// Include generic sundials stuff
%{
#include "sundials/sundials_types.h"
#include "sundials/sundials_nvector.h"
#include "sundials/sundials_matrix.h"
#include "sundials/sundials_iterative.h"
#include "sundials/sundials_linearsolver.h"
#include "sundials/sundials_nonlinearsolver.h"
#include "nvector_pyhelp.h"
%}
%includefile "/home/balos1/Workspace/SUNDIALS/repos/feature/python-kinsol/instdir/include/sundials/sundials_types.h" %beginfile
/* -----------------------------------------------------------------
 * Programmer(s): Scott Cohen, Alan Hindmarsh, Radu Serban,
 *                Aaron Collier, and Slaven Peles @ LLNL
 * -----------------------------------------------------------------
 * SUNDIALS Copyright Start
 * Copyright (c) 2002-2021, Lawrence Livermore National Security
 * and Southern Methodist University.
 * All rights reserved.
 *
 * See the top-level LICENSE and NOTICE files for details.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 * SUNDIALS Copyright End
 * -----------------------------------------------------------------
 * This header file exports three types: realtype, sunindextype and
 * booleantype, as well as the constants SUNTRUE and SUNFALSE.
 *
 * Users should include the header file sundials_types.h in every
 * program file and use the exported name realtype instead of
 * float, double or long double.
 *
 * The constants SUNDIALS_SINGLE_PRECISION, SUNDIALS_DOUBLE_PRECISION
 * and SUNDIALS_LONG_DOUBLE_PRECISION indicate the underlying data
 * type of realtype.
 *
 * The legal types for realtype are float, double and long double.
 *
 * The constants SUNDIALS_INT64_T and SUNDIALS_INT32_T indicate
 * the underlying data type of sunindextype -- the integer data type
 * used for vector and matrix indices.
 *
 * Data types are set at the configuration stage.
 *
 * The macro RCONST gives the user a convenient way to define
 * real-valued literal constants. To use the constant 1.0, for example,
 * the user should write the following:
 *
 *   #define ONE RCONST(1.0)
 *
 * If realtype is defined as a double, then RCONST(1.0) expands
 * to 1.0. If realtype is defined as a float, then RCONST(1.0)
 * expands to 1.0F. If realtype is defined as a long double,
 * then RCONST(1.0) expands to 1.0L. There is never a need to
 * explicitly cast 1.0 to (realtype). The macro can be used for
 * literal constants only. It cannot be used for expressions.
 * -----------------------------------------------------------------*/














extern "C" {


/*
 *------------------------------------------------------------------
 * Macro _SUNDIALS_STRUCT_
 * The _SUNDIALS_STRUCT_ macro is defined as a `struct` unless
 * generating the SWIG interfaces - in that case it is defined as
 * nothing. This is needed to work around a bug in SWIG which prevents
 * it from properly parsing our generic module structures. 
 *------------------------------------------------------------------
 */






/*
 *------------------------------------------------------------------
 * Type realtype
 * Macro RCONST
 * Constants BIG_REAL, SMALL_REAL, and UNIT_ROUNDOFF
 *------------------------------------------------------------------
 */











typedef double realtype;
















/*
 *------------------------------------------------------------------
 * Type : sunindextype
 *------------------------------------------------------------------
 * Defines integer type to be used for vector and matrix indices.
 * User can build sundials to use 32- or 64-bit signed integers.
 * If compiler does not support portable data types, the SUNDIALS
 * CMake build system tries to find a type of the desired size.
 *------------------------------------------------------------------
 */

typedef int32_t sunindextype;

/*
 *------------------------------------------------------------------
 * Type : booleantype
 *------------------------------------------------------------------
 * Constants : SUNFALSE and SUNTRUE
 *------------------------------------------------------------------
 * ANSI C does not have a built-in boolean data type. Below is the
 * definition for a new type called booleantype. The advantage of
 * using the name booleantype (instead of int) is an increase in
 * code readability. It also allows the programmer to make a
 * distinction between int and boolean data. Variables of type
 * booleantype are intended to have only the two values SUNFALSE and
 * SUNTRUE which are defined below to be equal to 0 and 1,
 * respectively.
 *------------------------------------------------------------------
 */






%constant SUNFALSE = 0;



%constant SUNTRUE = 1;



}



%endoffile
%includefile "/home/balos1/Workspace/SUNDIALS/repos/feature/python-kinsol/instdir/include/sundials/sundials_nvector.h" %beginfile
/* -----------------------------------------------------------------
 * Programmer(s): Radu Serban and Aaron Collier @ LLNL
 * -----------------------------------------------------------------
 * SUNDIALS Copyright Start
 * Copyright (c) 2002-2021, Lawrence Livermore National Security
 * and Southern Methodist University.
 * All rights reserved.
 *
 * See the top-level LICENSE and NOTICE files for details.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 * SUNDIALS Copyright End
 * -----------------------------------------------------------------
 * This is the header file for a generic NVECTOR package.
 * It defines the N_Vector structure (_generic_N_Vector) which
 * contains the following fields:
 *   - an implementation-dependent 'content' field which contains
 *     the description and actual data of the vector
 *   - an 'ops' filed which contains a structure listing operations
 *     acting on such vectors
 * -----------------------------------------------------------------
 * This header file contains:
 *   - enumeration constants for all SUNDIALS-defined vector types,
 *     as well as a generic type for user-supplied vector types,
 *   - type declarations for the _generic_N_Vector and
 *     _generic_N_Vector_Ops structures, as well as references to
 *     pointers to such structures (N_Vector), and
 *   - prototypes for the vector functions which operate on
 *     N_Vector objects.
 * -----------------------------------------------------------------
 * At a minimum, a particular implementation of an NVECTOR must
 * do the following:
 *   - specify the 'content' field of N_Vector,
 *   - implement the operations on those N_Vector objects,
 *   - provide a constructor routine for new N_Vector objects
 *
 * Additionally, an NVECTOR implementation may provide the following:
 *   - macros to access the underlying N_Vector data
 *   - a constructor for an array of N_Vectors
 *   - a constructor for an empty N_Vector (i.e., a new N_Vector with
 *     a NULL data pointer).
 *   - a routine to print the content of an N_Vector
 * -----------------------------------------------------------------*/










extern "C" {



/* -----------------------------------------------------------------
 * Implemented N_Vector types
 * ----------------------------------------------------------------- */

typedef enum {
  SUNDIALS_NVEC_SERIAL,
  SUNDIALS_NVEC_PARALLEL,
  SUNDIALS_NVEC_OPENMP,
  SUNDIALS_NVEC_PTHREADS,
  SUNDIALS_NVEC_PARHYP,
  SUNDIALS_NVEC_PETSC,
  SUNDIALS_NVEC_CUDA,
  SUNDIALS_NVEC_HIP,
  SUNDIALS_NVEC_SYCL,
  SUNDIALS_NVEC_RAJA,
  SUNDIALS_NVEC_OPENMPDEV,
  SUNDIALS_NVEC_TRILINOS,
  SUNDIALS_NVEC_MANYVECTOR,
  SUNDIALS_NVEC_MPIMANYVECTOR,
  SUNDIALS_NVEC_MPIPLUSX,
  SUNDIALS_NVEC_CUSTOM
} N_Vector_ID;


/* -----------------------------------------------------------------
 * Generic definition of N_Vector
 * ----------------------------------------------------------------- */

/* Forward reference for pointer to N_Vector_Ops object */
typedef  _generic_N_Vector_Ops *N_Vector_Ops;

/* Forward reference for pointer to N_Vector object */
typedef  _generic_N_Vector *N_Vector;

/* Define array of N_Vectors */
typedef N_Vector *N_Vector_S;

/* Structure containing function pointers to vector operations  */
struct _generic_N_Vector_Ops {
  N_Vector_ID  (*nvgetvectorid)(N_Vector);
  N_Vector     (*nvclone)(N_Vector);
  N_Vector     (*nvcloneempty)(N_Vector);
  void         (*nvdestroy)(N_Vector);
  void         (*nvspace)(N_Vector, sunindextype *, sunindextype *);
  realtype*    (*nvgetarraypointer)(N_Vector);
  realtype*    (*nvgetdevicearraypointer)(N_Vector);
  void         (*nvsetarraypointer)(realtype *, N_Vector);
  void*        (*nvgetcommunicator)(N_Vector);
  sunindextype (*nvgetlength)(N_Vector);

  /* standard vector operations */
  void        (*nvlinearsum)(realtype, N_Vector, realtype, N_Vector, N_Vector);
  void        (*nvconst)(realtype, N_Vector);
  void        (*nvprod)(N_Vector, N_Vector, N_Vector);
  void        (*nvdiv)(N_Vector, N_Vector, N_Vector);
  void        (*nvscale)(realtype, N_Vector, N_Vector);
  void        (*nvabs)(N_Vector, N_Vector);
  void        (*nvinv)(N_Vector, N_Vector);
  void        (*nvaddconst)(N_Vector, realtype, N_Vector);
  realtype    (*nvdotprod)(N_Vector, N_Vector);
  realtype    (*nvmaxnorm)(N_Vector);
  realtype    (*nvwrmsnorm)(N_Vector, N_Vector);
  realtype    (*nvwrmsnormmask)(N_Vector, N_Vector, N_Vector);
  realtype    (*nvmin)(N_Vector);
  realtype    (*nvwl2norm)(N_Vector, N_Vector);
  realtype    (*nvl1norm)(N_Vector);
  void        (*nvcompare)(realtype, N_Vector, N_Vector);
  int (*nvinvtest)(N_Vector, N_Vector);
  int (*nvconstrmask)(N_Vector, N_Vector, N_Vector);
  realtype    (*nvminquotient)(N_Vector, N_Vector);

  /* fused vector operations */
  int (*nvlinearcombination)(int, realtype*, N_Vector*, N_Vector);
  int (*nvscaleaddmulti)(int, realtype*, N_Vector, N_Vector*, N_Vector*);
  int (*nvdotprodmulti)(int, N_Vector, N_Vector*, realtype*);

  /* vector array operations */
  int (*nvlinearsumvectorarray)(int, realtype, N_Vector*, realtype, N_Vector*,
                                N_Vector*);
  int (*nvscalevectorarray)(int, realtype*, N_Vector*, N_Vector*);
  int (*nvconstvectorarray)(int, realtype, N_Vector*);
  int (*nvwrmsnormvectorarray)(int, N_Vector*, N_Vector*, realtype*);
  int (*nvwrmsnormmaskvectorarray)(int, N_Vector*, N_Vector*, N_Vector, realtype*);
  int (*nvscaleaddmultivectorarray)(int, int, realtype*, N_Vector*, N_Vector**, N_Vector**);
  int (*nvlinearcombinationvectorarray)(int, int, realtype*, N_Vector**, N_Vector*);

  /* OPTIONAL local reduction kernels (no parallel communication) */
  realtype (*nvdotprodlocal)(N_Vector, N_Vector);
  realtype (*nvmaxnormlocal)(N_Vector);
  realtype (*nvminlocal)(N_Vector);
  realtype (*nvl1normlocal)(N_Vector);
  int (*nvinvtestlocal)(N_Vector, N_Vector);
  int (*nvconstrmasklocal)(N_Vector, N_Vector, N_Vector);
  realtype (*nvminquotientlocal)(N_Vector, N_Vector);
  realtype (*nvwsqrsumlocal)(N_Vector, N_Vector);
  realtype (*nvwsqrsummasklocal)(N_Vector, N_Vector, N_Vector);

  /* OPTIONAL XBraid interface operations */
  int (*nvbufsize)(N_Vector, sunindextype*);
  int (*nvbufpack)(N_Vector, void*);
  int (*nvbufunpack)(N_Vector, void*);

  /* debugging functions (called when SUNDIALS_DEBUG_PRINTVEC is defined) */
  void (*nvprint)(N_Vector);
  void (*nvprintfile)(N_Vector, FILE*);
};

/* A vector is a structure with an implementation-dependent
   'content' field, and a pointer to a structure of vector
   operations corresponding to that implementation. */
struct _generic_N_Vector {
  void *content;
  N_Vector_Ops ops;
};


/* -----------------------------------------------------------------
 * Functions exported by NVECTOR module
 * ----------------------------------------------------------------- */

 N_Vector N_VNewEmpty();
 void N_VFreeEmpty(N_Vector v);
 int N_VCopyOps(N_Vector w, N_Vector v);

 N_Vector_ID N_VGetVectorID(N_Vector w);
 N_Vector N_VClone(N_Vector w);
 N_Vector N_VCloneEmpty(N_Vector w);
 void N_VDestroy(N_Vector v);
 void N_VSpace(N_Vector v, sunindextype *lrw, sunindextype *liw);
 realtype *N_VGetArrayPointer(N_Vector v);
 realtype *N_VGetDeviceArrayPointer(N_Vector v);
 void N_VSetArrayPointer(realtype *v_data, N_Vector v);
 void *N_VGetCommunicator(N_Vector v);
 sunindextype N_VGetLength(N_Vector v);

/* standard vector operations */
 void N_VLinearSum(realtype a, N_Vector x, realtype b,
                                  N_Vector y, N_Vector z);
 void N_VConst(realtype c, N_Vector z);
 void N_VProd(N_Vector x, N_Vector y, N_Vector z);
 void N_VDiv(N_Vector x, N_Vector y, N_Vector z);
 void N_VScale(realtype c, N_Vector x, N_Vector z);
 void N_VAbs(N_Vector x, N_Vector z);
 void N_VInv(N_Vector x, N_Vector z);
 void N_VAddConst(N_Vector x, realtype b, N_Vector z);
 realtype N_VDotProd(N_Vector x, N_Vector y);
 realtype N_VMaxNorm(N_Vector x);
 realtype N_VWrmsNorm(N_Vector x, N_Vector w);
 realtype N_VWrmsNormMask(N_Vector x, N_Vector w, N_Vector id);
 realtype N_VMin(N_Vector x);
 realtype N_VWL2Norm(N_Vector x, N_Vector w);
 realtype N_VL1Norm(N_Vector x);
 void N_VCompare(realtype c, N_Vector x, N_Vector z);
 int N_VInvTest(N_Vector x, N_Vector z);
 int N_VConstrMask(N_Vector c, N_Vector x, N_Vector m);
 realtype N_VMinQuotient(N_Vector num, N_Vector denom);

/* OPTIONAL fused vector operations */
 int N_VLinearCombination(int nvec, realtype* c, N_Vector* X,
                                         N_Vector z);

 int N_VScaleAddMulti(int nvec, realtype* a, N_Vector x,
                                     N_Vector* Y, N_Vector* Z);

 int N_VDotProdMulti(int nvec, N_Vector x, N_Vector* Y,
                                    realtype* dotprods);

/* OPTIONAL vector array operations */
 int N_VLinearSumVectorArray(int nvec,
                                            realtype a, N_Vector* X,
                                            realtype b, N_Vector* Y,
                                            N_Vector* Z);

 int N_VScaleVectorArray(int nvec, realtype* c, N_Vector* X,
                                        N_Vector* Z);

 int N_VConstVectorArray(int nvec, realtype c, N_Vector* Z);

 int N_VWrmsNormVectorArray(int nvec, N_Vector* X, N_Vector* W,
                                           realtype* nrm);

 int N_VWrmsNormMaskVectorArray(int nvec, N_Vector* X,
                                               N_Vector* W, N_Vector id,
                                               realtype* nrm);

 int N_VScaleAddMultiVectorArray(int nvec, int nsum,
                                                realtype* a, N_Vector* X,
                                                N_Vector** Y, N_Vector** Z);

 int N_VLinearCombinationVectorArray(int nvec, int nsum,
                                                    realtype* c, N_Vector** X,
                                                    N_Vector* Z);

/* OPTIONAL local reduction kernels (no parallel communication) */
 realtype N_VDotProdLocal(N_Vector x, N_Vector y);
 realtype N_VMaxNormLocal(N_Vector x);
 realtype N_VMinLocal(N_Vector x);
 realtype N_VL1NormLocal(N_Vector x);
 realtype N_VWSqrSumLocal(N_Vector x, N_Vector w);
 realtype N_VWSqrSumMaskLocal(N_Vector x, N_Vector w, N_Vector id);
 int N_VInvTestLocal(N_Vector x, N_Vector z);
 int N_VConstrMaskLocal(N_Vector c, N_Vector x, N_Vector m);
 realtype N_VMinQuotientLocal(N_Vector num, N_Vector denom);

/* OPTIONAL XBraid interface operations */
 int N_VBufSize(N_Vector x, sunindextype *size);
 int N_VBufPack(N_Vector x, void *buf);
 int N_VBufUnpack(N_Vector x, void *buf);

/* -----------------------------------------------------------------
 * Additional functions exported by NVECTOR module
 * ----------------------------------------------------------------- */

 N_Vector* N_VNewVectorArray(int count);
 N_Vector* N_VCloneEmptyVectorArray(int count, N_Vector w);
 N_Vector* N_VCloneVectorArray(int count, N_Vector w);
 void N_VDestroyVectorArray(N_Vector* vs, int count);

/* These function are really only for users of the Fortran interface */
 N_Vector N_VGetVecAtIndexVectorArray(N_Vector* vs, int index);
 void N_VSetVecAtIndexVectorArray(N_Vector* vs, int index, N_Vector w);


/* -----------------------------------------------------------------
 * Debugging functions
 * ----------------------------------------------------------------- */

 void N_VPrint(N_Vector v);
 void N_VPrintFile(N_Vector v, FILE* outfile);



}



%endoffile
%includefile "/home/balos1/Workspace/SUNDIALS/repos/feature/python-kinsol/instdir/include/sundials/sundials_matrix.h" %beginfile
/* -----------------------------------------------------------------
 * Programmer(s): Daniel Reynolds @ SMU
 *                David Gardner, Carol Woodward, Slaven Peles,
 *                Cody Balos @ LLNL
 * -----------------------------------------------------------------
 * SUNDIALS Copyright Start
 * Copyright (c) 2002-2021, Lawrence Livermore National Security
 * and Southern Methodist University.
 * All rights reserved.
 *
 * See the top-level LICENSE and NOTICE files for details.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 * SUNDIALS Copyright End
 * -----------------------------------------------------------------
 * This is the header file for a generic matrix package.
 * It defines the SUNMatrix structure (_generic_SUNMatrix) which
 * contains the following fields:
 *   - an implementation-dependent 'content' field which contains
 *     the description and actual data of the matrix
 *   - an 'ops' filed which contains a structure listing operations
 *     acting on such matrices
 * -----------------------------------------------------------------
 * This header file contains:
 *   - enumeration constants for all SUNDIALS-defined matrix types,
 *     as well as a generic type for user-supplied matrix types,
 *   - type declarations for the _generic_SUNMatrix and
 *     _generic_SUNMatrix_Ops structures, as well as references to
 *     pointers to such structures (SUNMatrix), and
 *   - prototypes for the matrix functions which operate on
 *     SUNMatrix objects.
 * -----------------------------------------------------------------
 * At a minimum, a particular implementation of a SUNMatrix must
 * do the following:
 *   - specify the 'content' field of SUNMatrix,
 *   - implement the operations on those SUNMatrix objects,
 *   - provide a constructor routine for new SUNMatrix objects
 *
 * Additionally, a SUNMatrix implementation may provide the following:
 *   - macros to access the underlying SUNMatrix data
 *   - a routine to print the content of a SUNMatrix
 * -----------------------------------------------------------------*/








extern "C" {



/* -----------------------------------------------------------------
 * Implemented SUNMatrix types
 * ----------------------------------------------------------------- */

typedef enum {
  SUNMATRIX_DENSE,
  SUNMATRIX_MAGMADENSE,
  SUNMATRIX_ONEMKLDENSE,
  SUNMATRIX_BAND,
  SUNMATRIX_SPARSE,
  SUNMATRIX_SLUNRLOC,
  SUNMATRIX_CUSPARSE,
  SUNMATRIX_CUSTOM
} SUNMatrix_ID;


/* -----------------------------------------------------------------
 * Generic definition of SUNMatrix
 * ----------------------------------------------------------------- */

/* Forward reference for pointer to SUNMatrix_Ops object */
typedef  _generic_SUNMatrix_Ops *SUNMatrix_Ops;

/* Forward reference for pointer to SUNMatrix object */
typedef  _generic_SUNMatrix *SUNMatrix;

/* Structure containing function pointers to matrix operations  */
struct _generic_SUNMatrix_Ops {
  SUNMatrix_ID (*getid)(SUNMatrix);
  SUNMatrix    (*clone)(SUNMatrix);
  void         (*destroy)(SUNMatrix);
  int          (*zero)(SUNMatrix);
  int          (*copy)(SUNMatrix, SUNMatrix);
  int          (*scaleadd)(realtype, SUNMatrix, SUNMatrix);
  int          (*scaleaddi)(realtype, SUNMatrix);
  int          (*matvecsetup)(SUNMatrix);
  int          (*matvec)(SUNMatrix, N_Vector, N_Vector);
  int          (*space)(SUNMatrix, long int*, long int*);
};

/* A matrix is a structure with an implementation-dependent
   'content' field, and a pointer to a structure of matrix
   operations corresponding to that implementation.  */
struct _generic_SUNMatrix {
  void *content;
  SUNMatrix_Ops ops;
};


/* -----------------------------------------------------------------
 * Functions exported by SUNMatrix module
 * ----------------------------------------------------------------- */

 SUNMatrix SUNMatNewEmpty();
 void SUNMatFreeEmpty(SUNMatrix A);
 int SUNMatCopyOps(SUNMatrix A, SUNMatrix B);
 SUNMatrix_ID SUNMatGetID(SUNMatrix A);
 SUNMatrix SUNMatClone(SUNMatrix A);
 void SUNMatDestroy(SUNMatrix A);
 int SUNMatZero(SUNMatrix A);
 int SUNMatCopy(SUNMatrix A, SUNMatrix B);
 int SUNMatScaleAdd(realtype c, SUNMatrix A, SUNMatrix B);
 int SUNMatScaleAddI(realtype c, SUNMatrix A);
 int SUNMatMatvecSetup(SUNMatrix A);
 int SUNMatMatvec(SUNMatrix A, N_Vector x, N_Vector y);
 int SUNMatSpace(SUNMatrix A, long int *lenrw, long int *leniw);

/*
 * -----------------------------------------------------------------
 * IV. SUNMatrix error codes
 * ---------------------------------------------------------------
 */

%constant SUNMAT_SUCCESS = 0; /* function successfull          */
%constant SUNMAT_ILL_INPUT = -701; /* illegal function input        */
%constant SUNMAT_MEM_FAIL = -702; /* failed memory access/alloc    */
%constant SUNMAT_OPERATION_FAIL = -703; /* a SUNMatrix operation returned nonzero */
%constant SUNMAT_MATVEC_SETUP_REQUIRED = -704; /* the SUNMatMatvecSetup routine needs to be called */


}


%endoffile
%includefile "/home/balos1/Workspace/SUNDIALS/repos/feature/python-kinsol/instdir/include/sundials/sundials_iterative.h" %beginfile
/* -----------------------------------------------------------------
 * Programmer(s): Scott D. Cohen and Alan C. Hindmarsh @ LLNL
 * -----------------------------------------------------------------
 * SUNDIALS Copyright Start
 * Copyright (c) 2002-2021, Lawrence Livermore National Security
 * and Southern Methodist University.
 * All rights reserved.
 *
 * See the top-level LICENSE and NOTICE files for details.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 * SUNDIALS Copyright End
 * -----------------------------------------------------------------
 * This header file contains declarations intended for use by
 * generic iterative solvers of Ax = b. The enumeration gives
 * symbolic names for the type  of preconditioning to be used.
 * The function type declarations give the prototypes for the
 * functions to be called within an iterative linear solver, that
 * are responsible for
 *    multiplying A by a given vector v (ATimesFn),
 *    setting up a preconditioner P (PSetupFn), and
 *    solving the preconditioner equation Pz = r (PSolveFn).
 * -----------------------------------------------------------------*/







extern "C" {



/*
 * -----------------------------------------------------------------
 * enum : types of preconditioning
 * -----------------------------------------------------------------
 * PREC_NONE  : The iterative linear solver should not use
 *              preconditioning.
 *
 * PREC_LEFT  : The iterative linear solver uses preconditioning on
 *              the left only.
 *
 * PREC_RIGHT : The iterative linear solver uses preconditioning on
 *              the right only.
 *
 * PREC_BOTH  : The iterative linear solver uses preconditioning on
 *              both the left and the right.
 * -----------------------------------------------------------------
 */

enum { PREC_NONE, PREC_LEFT, PREC_RIGHT, PREC_BOTH };

/*
 * -----------------------------------------------------------------
 * enum : types of Gram-Schmidt routines
 * -----------------------------------------------------------------
 * MODIFIED_GS  : The iterative solver uses the modified
 *                Gram-Schmidt routine ModifiedGS listed in this
 *                file.
 *
 * CLASSICAL_GS : The iterative solver uses the classical
 *                Gram-Schmidt routine ClassicalGS listed in this
 *                file.
 * -----------------------------------------------------------------
 */

enum { MODIFIED_GS = 1, CLASSICAL_GS = 2 };

/*
 * -----------------------------------------------------------------
 * Type: ATimesFn
 * -----------------------------------------------------------------
 * An ATimesFn multiplies Av and stores the result in z. The
 * caller is responsible for allocating memory for the z vector.
 * The parameter A_data is a pointer to any information about A
 * which the function needs in order to do its job. The vector v
 * is unchanged. An ATimesFn returns 0 if successful and a
 * non-zero value if unsuccessful.
 * -----------------------------------------------------------------
 */

typedef int (*ATimesFn)(void *A_data, N_Vector v, N_Vector z);

/*
 * -----------------------------------------------------------------
 * Type: PSetupFn
 * -----------------------------------------------------------------
 * A PSetupFn is an integrator-supplied routine that accesses data
 * stored in the integrator memory structure (P_data), and calls
 * the user-supplied, integrator-specific preconditioner setup
 * routine.
 * -----------------------------------------------------------------
 */

typedef int (*PSetupFn)(void *P_data);

/*
 * -----------------------------------------------------------------
 * Type: PSolveFn
 * -----------------------------------------------------------------
 * A PSolveFn solves the preconditioner equation Pz = r for the
 * vector z. The caller is responsible for allocating memory for
 * the z vector. The parameter P_data is a pointer to any
 * information about P which the function needs in order to do
 * its job. The parameter lr is input, and indicates whether P
 * is to be taken as the left preconditioner or the right
 * preconditioner: lr = 1 for left and lr = 2 for right.
 * If preconditioning is on one side only, lr can be ignored.
 * If the preconditioner is iterative, then it should strive to
 * solve the preconditioner equation so that
 *     || Pz - r ||_wrms < tol
 * where the weight vector for the WRMS norm may be accessed from
 * the main integrator memory structure.
 * The vector r should not be modified by the PSolveFn.
 * A PSolveFn returns 0 if successful and a non-zero value if
 * unsuccessful.  On a failure, a negative return value indicates
 * an unrecoverable condition, while a positive value indicates
 * a recoverable one, in which the calling routine may reattempt
 * the solution after updating preconditioner data.
 * -----------------------------------------------------------------
 */

typedef int (*PSolveFn)(void *P_data, N_Vector r, N_Vector z,
                        realtype tol, int lr);

/*
 * -----------------------------------------------------------------
 * Function: ModifiedGS
 * -----------------------------------------------------------------
 * ModifiedGS performs a modified Gram-Schmidt orthogonalization
 * of the N_Vector v[k] against the p unit N_Vectors at
 * v[k-1], v[k-2], ..., v[k-p].
 *
 * v is an array of (k+1) N_Vectors v[i], i=0, 1, ..., k.
 * v[k-1], v[k-2], ..., v[k-p] are assumed to have L2-norm
 * equal to 1.
 *
 * h is the output k by k Hessenberg matrix of inner products.
 * This matrix must be allocated row-wise so that the (i,j)th
 * entry is h[i][j]. The inner products (v[i],v[k]),
 * i=i0, i0+1, ..., k-1, are stored at h[i][k-1]. Here
 * i0=SUNMAX(0,k-p).
 *
 * k is the index of the vector in the v array that needs to be
 * orthogonalized against previous vectors in the v array.
 *
 * p is the number of previous vectors in the v array against
 * which v[k] is to be orthogonalized.
 *
 * new_vk_norm is a pointer to memory allocated by the caller to
 * hold the Euclidean norm of the orthogonalized vector v[k].
 *
 * If (k-p) < 0, then ModifiedGS uses p=k. The orthogonalized
 * v[k] is NOT normalized and is stored over the old v[k]. Once
 * the orthogonalization has been performed, the Euclidean norm
 * of v[k] is stored in (*new_vk_norm).
 *
 * ModifiedGS returns 0 to indicate success. It cannot fail.
 * -----------------------------------------------------------------
 */

 int ModifiedGS(N_Vector* v, realtype **h, int k, int p,
                               realtype *new_vk_norm);

/*
 * -----------------------------------------------------------------
 * Function: ClassicalGS
 * -----------------------------------------------------------------
 * ClassicalGS performs a classical Gram-Schmidt
 * orthogonalization of the N_Vector v[k] against the p unit
 * N_Vectors at v[k-1], v[k-2], ..., v[k-p]. The parameters v, h,
 * k, p, and new_vk_norm are as described in the documentation
 * for ModifiedGS.
 *
 * stemp is a length k+1 array of realtype which can be used as
 * workspace by the ClassicalGS routine.
 *
 * vtemp is an N_Vector array of k+1 vectors which can be used as
 * workspace by the ClassicalGS routine.
 *
 * ClassicalGS returns 0 to indicate success.
 * -----------------------------------------------------------------
 */

 int ClassicalGS(N_Vector* v, realtype **h, int k, int p,
                                realtype *new_vk_norm, realtype *stemp,
                                N_Vector* vtemp);

/*
 * -----------------------------------------------------------------
 * Function: QRfact
 * -----------------------------------------------------------------
 * QRfact performs a QR factorization of the Hessenberg matrix H.
 *
 * n is the problem size; the matrix H is (n+1) by n.
 *
 * h is the (n+1) by n Hessenberg matrix H to be factored. It is
 * stored row-wise.
 *
 * q is an array of length 2*n containing the Givens rotations
 * computed by this function. A Givens rotation has the form:
 * | c  -s |
 * | s   c |.
 * The components of the Givens rotations are stored in q as
 * (c, s, c, s, ..., c, s).
 *
 * job is a control flag. If job==0, then a new QR factorization
 * is performed. If job!=0, then it is assumed that the first
 * n-1 columns of h have already been factored and only the last
 * column needs to be updated.
 *
 * QRfact returns 0 if successful. If a zero is encountered on
 * the diagonal of the triangular factor R, then QRfact returns
 * the equation number of the zero entry, where the equations are
 * numbered from 1, not 0. If QRsol is subsequently called in
 * this situation, it will return an error because it could not
 * divide by the zero diagonal entry.
 * -----------------------------------------------------------------
 */

 int QRfact(int n, realtype **h, realtype *q, int job);

/*
 * -----------------------------------------------------------------
 * Function: QRsol
 * -----------------------------------------------------------------
 * QRsol solves the linear least squares problem
 *
 * min (b - H*x, b - H*x), x in R^n,
 *
 * where H is a Hessenberg matrix, and b is in R^(n+1).
 * It uses the QR factors of H computed by QRfact.
 *
 * n is the problem size; the matrix H is (n+1) by n.
 *
 * h is a matrix (computed by QRfact) containing the upper
 * triangular factor R of the original Hessenberg matrix H.
 *
 * q is an array of length 2*n (computed by QRfact) containing
 * the Givens rotations used to factor H.
 *
 * b is the (n+1)-vector appearing in the least squares problem
 * above.
 *
 * On return, b contains the solution x of the least squares
 * problem, if QRsol was successful.
 *
 * QRsol returns a 0 if successful.  Otherwise, a zero was
 * encountered on the diagonal of the triangular factor R.
 * In this case, QRsol returns the equation number (numbered
 * from 1, not 0) of the zero entry.
 * -----------------------------------------------------------------
 */

 int QRsol(int n, realtype **h, realtype *q, realtype *b);


}



%endoffile
%includefile "/home/balos1/Workspace/SUNDIALS/repos/feature/python-kinsol/instdir/include/sundials/sundials_linearsolver.h" %beginfile
/* -----------------------------------------------------------------
 * Programmer(s): Daniel Reynolds @ SMU
 *                David Gardner, Carol Woodward,
 *                Slaven Peles, Cody Balos @ LLNL
 * -----------------------------------------------------------------
 * SUNDIALS Copyright Start
 * Copyright (c) 2002-2021, Lawrence Livermore National Security
 * and Southern Methodist University.
 * All rights reserved.
 *
 * See the top-level LICENSE and NOTICE files for details.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 * SUNDIALS Copyright End
 * -----------------------------------------------------------------
 * This is the header file for a generic linear solver package.
 * It defines the SUNLinearSolver structure (_generic_SUNLinearSolver)
 * which contains the following fields:
 *   - an implementation-dependent 'content' field which contains
 *     any internal data required by the solver
 *   - an 'ops' filed which contains a structure listing operations
 *     acting on/by such solvers
 *
 * We consider both direct linear solvers and iterative linear solvers
 * as available implementations of this package.  Furthermore, iterative
 * linear solvers can either use a matrix or be matrix-free.  As a
 * result of these different solver characteristics, some of the
 * routines are applicable only to some types of linear solver.
 * -----------------------------------------------------------------
 * This header file contains:
 *   - enumeration constants for all SUNDIALS-defined linear solver
 *     types, as well as a generic type for user-supplied linear
 *     solver types,
 *   - type declarations for the _generic_SUNLinearSolver and
 *     _generic_SUNLinearSolver_Ops structures, as well as references
 *     to pointers to such structures (SUNLinearSolver),
 *   - prototypes for the linear solver functions which operate
 *     on/by SUNLinearSolver objects, and
 *   - return codes for SUNLinearSolver objects.
 * -----------------------------------------------------------------
 * At a minimum, a particular implementation of a SUNLinearSolver must
 * do the following:
 *   - specify the 'content' field of SUNLinearSolver,
 *   - implement the operations on/by those SUNLinearSolver objects,
 *   - provide a constructor routine for new SUNLinearSolver objects
 *
 * Additionally, a SUNLinearSolver implementation may provide the
 * following:
 *   - "Set" routines to control solver-specific parameters/options
 *   - "Get" routines to access solver-specific performance metrics
 * -----------------------------------------------------------------*/










extern "C" {



/* -----------------------------------------------------------------
 * Implemented SUNLinearSolver types and IDs:
 * ----------------------------------------------------------------- */

typedef enum {
  SUNLINEARSOLVER_DIRECT,
  SUNLINEARSOLVER_ITERATIVE,
  SUNLINEARSOLVER_MATRIX_ITERATIVE,
  SUNLINEARSOLVER_MATRIX_EMBEDDED
} SUNLinearSolver_Type;

typedef enum {
  SUNLINEARSOLVER_BAND,
  SUNLINEARSOLVER_DENSE,
  SUNLINEARSOLVER_KLU,
  SUNLINEARSOLVER_LAPACKBAND,
  SUNLINEARSOLVER_LAPACKDENSE,
  SUNLINEARSOLVER_PCG,
  SUNLINEARSOLVER_SPBCGS,
  SUNLINEARSOLVER_SPFGMR,
  SUNLINEARSOLVER_SPGMR,
  SUNLINEARSOLVER_SPTFQMR,
  SUNLINEARSOLVER_SUPERLUDIST,
  SUNLINEARSOLVER_SUPERLUMT,
  SUNLINEARSOLVER_CUSOLVERSP_BATCHQR,
  SUNLINEARSOLVER_MAGMADENSE,
  SUNLINEARSOLVER_ONEMKLDENSE,
  SUNLINEARSOLVER_CUSTOM
} SUNLinearSolver_ID;


/* -----------------------------------------------------------------
 * Generic definition of SUNLinearSolver
 * ----------------------------------------------------------------- */

/* Forward reference for pointer to SUNLinearSolver_Ops object */
typedef  _generic_SUNLinearSolver_Ops *SUNLinearSolver_Ops;

/* Forward reference for pointer to SUNLinearSolver object */
typedef  _generic_SUNLinearSolver *SUNLinearSolver;

/* Structure containing function pointers to linear solver operations */
struct _generic_SUNLinearSolver_Ops {
  SUNLinearSolver_Type (*gettype)(SUNLinearSolver);
  SUNLinearSolver_ID   (*getid)(SUNLinearSolver);
  int                  (*setatimes)(SUNLinearSolver, void*, ATimesFn);
  int                  (*setpreconditioner)(SUNLinearSolver, void*,
                                            PSetupFn, PSolveFn);
  int                  (*setscalingvectors)(SUNLinearSolver,
                                            N_Vector, N_Vector);
  int                  (*setzeroguess)(SUNLinearSolver, int);
  int                  (*initialize)(SUNLinearSolver);
  int                  (*setup)(SUNLinearSolver, SUNMatrix);
  int                  (*solve)(SUNLinearSolver, SUNMatrix, N_Vector,
                                N_Vector, realtype);
  int                  (*numiters)(SUNLinearSolver);
  realtype             (*resnorm)(SUNLinearSolver);
  sunindextype         (*lastflag)(SUNLinearSolver);
  int                  (*space)(SUNLinearSolver, long int*, long int*);
  N_Vector             (*resid)(SUNLinearSolver);
  int                  (*free)(SUNLinearSolver);
};

/* A linear solver is a structure with an implementation-dependent
   'content' field, and a pointer to a structure of linear solver
   operations corresponding to that implementation. */
struct _generic_SUNLinearSolver {
  void *content;
  SUNLinearSolver_Ops ops;
};


/* -----------------------------------------------------------------
 * Functions exported by SUNLinearSolver module
 * ----------------------------------------------------------------- */

 SUNLinearSolver SUNLinSolNewEmpty();

 void SUNLinSolFreeEmpty(SUNLinearSolver S);

 SUNLinearSolver_Type SUNLinSolGetType(SUNLinearSolver S);

 SUNLinearSolver_ID SUNLinSolGetID(SUNLinearSolver S);

 int SUNLinSolSetATimes(SUNLinearSolver S, void* A_data,
                                       ATimesFn ATimes);

 int SUNLinSolSetPreconditioner(SUNLinearSolver S, void* P_data,
                                               PSetupFn Pset, PSolveFn Psol);

 int SUNLinSolSetScalingVectors(SUNLinearSolver S, N_Vector s1,
                                               N_Vector s2);

 int SUNLinSolSetZeroGuess(SUNLinearSolver S, int onoff);

 int SUNLinSolInitialize(SUNLinearSolver S);

 int SUNLinSolSetup(SUNLinearSolver S, SUNMatrix A);

 int SUNLinSolSolve(SUNLinearSolver S, SUNMatrix A, N_Vector x,
                                   N_Vector b, realtype tol);

 int SUNLinSolNumIters(SUNLinearSolver S);

 realtype SUNLinSolResNorm(SUNLinearSolver S);

 N_Vector SUNLinSolResid(SUNLinearSolver S);

 sunindextype SUNLinSolLastFlag(SUNLinearSolver S);

 int SUNLinSolSpace(SUNLinearSolver S, long int *lenrwLS,
                                   long int *leniwLS);

 int SUNLinSolFree(SUNLinearSolver S);


/* -----------------------------------------------------------------
 * SUNLinearSolver return values
 * ----------------------------------------------------------------- */

%constant SUNLS_SUCCESS = 0; /* successful/converged          */

%constant SUNLS_MEM_NULL = -801; /* mem argument is NULL          */
%constant SUNLS_ILL_INPUT = -802; /* illegal function input        */
%constant SUNLS_MEM_FAIL = -803; /* failed memory access          */
%constant SUNLS_ATIMES_NULL = -804; /* atimes function is NULL       */
%constant SUNLS_ATIMES_FAIL_UNREC = -805; /* atimes unrecoverable failure  */
%constant SUNLS_PSET_FAIL_UNREC = -806; /* pset unrecoverable failure    */
%constant SUNLS_PSOLVE_NULL = -807; /* psolve function is NULL       */
%constant SUNLS_PSOLVE_FAIL_UNREC = -808; /* psolve unrecoverable failure  */
%constant SUNLS_PACKAGE_FAIL_UNREC = -809; /* external package unrec. fail  */
%constant SUNLS_GS_FAIL = -810; /* Gram-Schmidt failure          */
%constant SUNLS_QRSOL_FAIL = -811; /* QRsol found singular R        */
%constant SUNLS_VECTOROP_ERR = -812; /* vector operation error        */

%constant SUNLS_RES_REDUCED = 801; /* nonconv. solve, resid reduced */
%constant SUNLS_CONV_FAIL = 802; /* nonconvergent solve           */
%constant SUNLS_ATIMES_FAIL_REC = 803; /* atimes failed recoverably     */
%constant SUNLS_PSET_FAIL_REC = 804; /* pset failed recoverably       */
%constant SUNLS_PSOLVE_FAIL_REC = 805; /* psolve failed recoverably     */
%constant SUNLS_PACKAGE_FAIL_REC = 806; /* external package recov. fail  */
%constant SUNLS_QRFACT_FAIL = 807; /* QRfact found singular matrix  */
%constant SUNLS_LUFACT_FAIL = 808; /* LUfact found singular matrix  */

/* -----------------------------------------------------------------------------
 * SUNLinearSolver messages
 * ---------------------------------------------------------------------------*/




%constant SUNLS_MSG_RESIDUAL = "\t\tlin. iteration %ld, lin. residual: %g\n";





}


%endoffile
%includefile "/home/balos1/Workspace/SUNDIALS/repos/feature/python-kinsol/instdir/include/sundials/sundials_nonlinearsolver.h" %beginfile
/* -----------------------------------------------------------------------------
 * Programmer(s): David J. Gardner, and Cody J. Balos @ LLNL
 * -----------------------------------------------------------------------------
 * SUNDIALS Copyright Start
 * Copyright (c) 2002-2021, Lawrence Livermore National Security
 * and Southern Methodist University.
 * All rights reserved.
 *
 * See the top-level LICENSE and NOTICE files for details.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 * SUNDIALS Copyright End
 * -----------------------------------------------------------------------------
 * This is the header file for a generic nonlinear solver package. It defines
 * the SUNNonlinearSolver structure (_generic_SUNNonlinearSolver) which contains
 * the following fields:
 *   - an implementation-dependent 'content' field which contains any internal
 *     data required by the solver
 *   - an 'ops' filed which contains a structure listing operations acting on/by
 *     such solvers
 *
 * We consider iterative nonlinear solvers for systems in both root finding
 * (F(y) = 0) or fixed-point (G(y) = y) form. As a result, some of the routines
 * are applicable only to one type of nonlinear solver.
 * -----------------------------------------------------------------------------
 * This header file contains:
 *   - function types supplied to a SUNNonlinearSolver,
 *   - enumeration constants for SUNDIALS-defined nonlinear solver types,
 *   - type declarations for the _generic_SUNNonlinearSolver and
 *     _generic_SUNNonlinearSolver_Ops structures, as well as references to
 *     pointers to such structures (SUNNonlinearSolver),
 *   - prototypes for the nonlinear solver functions which operate
 *     on/by SUNNonlinearSolver objects, and
 *   - return codes for SUNLinearSolver objects.
 * -----------------------------------------------------------------------------
 * At a minimum, a particular implementation of a SUNNonlinearSolver must do the
 * following:
 *   - specify the 'content' field of a SUNNonlinearSolver,
 *   - implement the operations on/by the SUNNonlinearSovler objects,
 *   - provide a constructor routine for new SUNNonlinearSolver objects
 *
 * Additionally, a SUNNonlinearSolver implementation may provide the following:
 *   - "Set" routines to control solver-specific parameters/options
 *   - "Get" routines to access solver-specific performance metrics
 * ---------------------------------------------------------------------------*/








extern "C" {



/* -----------------------------------------------------------------------------
 *  Forward references for SUNNonlinearSolver types defined below
 * ---------------------------------------------------------------------------*/

/* Forward reference for pointer to SUNNonlinearSolver_Ops object */
typedef  _generic_SUNNonlinearSolver_Ops *SUNNonlinearSolver_Ops;

/* Forward reference for pointer to SUNNonlinearSolver object */
typedef  _generic_SUNNonlinearSolver *SUNNonlinearSolver;


/* -----------------------------------------------------------------------------
 * Integrator supplied function types
 * ---------------------------------------------------------------------------*/

typedef int (*SUNNonlinSolSysFn)(N_Vector y, N_Vector F, void* mem);

typedef int (*SUNNonlinSolLSetupFn)(int jbad, int* jcur,
                                    void* mem);

typedef int (*SUNNonlinSolLSolveFn)(N_Vector b, void* mem);

typedef int (*SUNNonlinSolConvTestFn)(SUNNonlinearSolver NLS, N_Vector y,
                                      N_Vector del, realtype tol, N_Vector ewt,
                                      void* mem);


/* -----------------------------------------------------------------------------
 * SUNNonlinearSolver types
 * ---------------------------------------------------------------------------*/

typedef enum {
  SUNNONLINEARSOLVER_ROOTFIND,
  SUNNONLINEARSOLVER_FIXEDPOINT
} SUNNonlinearSolver_Type;


/* -----------------------------------------------------------------------------
 * Generic definition of SUNNonlinearSolver
 * ---------------------------------------------------------------------------*/

/* Structure containing function pointers to nonlinear solver operations */
struct _generic_SUNNonlinearSolver_Ops {
  SUNNonlinearSolver_Type (*gettype)(SUNNonlinearSolver);
  int (*initialize)(SUNNonlinearSolver);
  int (*setup)(SUNNonlinearSolver, N_Vector, void*);
  int (*solve)(SUNNonlinearSolver, N_Vector, N_Vector, N_Vector, realtype,
               int, void*);
  int (*free)(SUNNonlinearSolver);
  int (*setsysfn)(SUNNonlinearSolver, SUNNonlinSolSysFn);
  int (*setlsetupfn)(SUNNonlinearSolver, SUNNonlinSolLSetupFn);
  int (*setlsolvefn)(SUNNonlinearSolver, SUNNonlinSolLSolveFn);
  int (*setctestfn)(SUNNonlinearSolver, SUNNonlinSolConvTestFn, void*);
  int (*setmaxiters)(SUNNonlinearSolver, int);
  int (*getnumiters)(SUNNonlinearSolver, long int*);
  int (*getcuriter)(SUNNonlinearSolver, int*);
  int (*getnumconvfails)(SUNNonlinearSolver, long int*);
};

/* A nonlinear solver is a structure with an implementation-dependent 'content'
   field, and a pointer to a structure of solver nonlinear solver operations
   corresponding to that implementation. */
struct _generic_SUNNonlinearSolver {
  void *content;
  SUNNonlinearSolver_Ops ops;
};


/* -----------------------------------------------------------------------------
 * Functions exported by SUNNonlinearSolver module
 * ---------------------------------------------------------------------------*/

/* empty constructor/destructor */
 SUNNonlinearSolver SUNNonlinSolNewEmpty();
 void SUNNonlinSolFreeEmpty(SUNNonlinearSolver NLS);

/* core functions */
 SUNNonlinearSolver_Type SUNNonlinSolGetType(SUNNonlinearSolver NLS);

 int SUNNonlinSolInitialize(SUNNonlinearSolver NLS);

 int SUNNonlinSolSetup(SUNNonlinearSolver NLS,
                                      N_Vector y, void* mem);

 int SUNNonlinSolSolve(SUNNonlinearSolver NLS,
                                      N_Vector y0, N_Vector y,
                                      N_Vector w, realtype tol,
                                      int callLSetup, void *mem);

 int SUNNonlinSolFree(SUNNonlinearSolver NLS);

/* set functions */
 int SUNNonlinSolSetSysFn(SUNNonlinearSolver NLS,
                                         SUNNonlinSolSysFn SysFn);

 int SUNNonlinSolSetLSetupFn(SUNNonlinearSolver NLS,
                                            SUNNonlinSolLSetupFn SetupFn);

 int SUNNonlinSolSetLSolveFn(SUNNonlinearSolver NLS,
                                            SUNNonlinSolLSolveFn SolveFn);

 int SUNNonlinSolSetConvTestFn(SUNNonlinearSolver NLS,
                                              SUNNonlinSolConvTestFn CTestFn,
                                              void* ctest_data);

 int SUNNonlinSolSetMaxIters(SUNNonlinearSolver NLS,
                                            int maxiters);
/* get functions */
 int SUNNonlinSolGetNumIters(SUNNonlinearSolver NLS,
                                            long int *niters);

 int SUNNonlinSolGetCurIter(SUNNonlinearSolver NLS,
                                           int *iter);

 int SUNNonlinSolGetNumConvFails(SUNNonlinearSolver NLS,
                                                long int *nconvfails);


/* -----------------------------------------------------------------------------
 * SUNNonlinearSolver return values
 * ---------------------------------------------------------------------------*/

%constant SUN_NLS_SUCCESS = 0; /* successful / converged */

/* Recoverable */
%constant SUN_NLS_CONTINUE = +901; /* not converged, keep iterating      */
%constant SUN_NLS_CONV_RECVR = +902; /* convergece failure, try to recover */

/* Unrecoverable */
%constant SUN_NLS_MEM_NULL = -901; /* memory argument is NULL            */
%constant SUN_NLS_MEM_FAIL = -902; /* failed memory access / allocation  */
%constant SUN_NLS_ILL_INPUT = -903; /* illegal function input             */
%constant SUN_NLS_VECTOROP_ERR = -904; /* failed NVector operation           */
%constant SUN_NLS_EXT_FAIL = -905; /* failed in external library call    */


/* -----------------------------------------------------------------------------
 * SUNNonlinearSolver messages
 * ---------------------------------------------------------------------------*/




%constant SUN_NLS_MSG_RESIDUAL = "\tnonlin. iteration %ld, nonlin. residual: %g\n";





}



%endoffile
%includefile "nvector_pyhelp.h" %beginfile


void N_VGetData(N_Vector v, sunindextype *length, realtype **data);
%endoffile

// Include implementations of generics
%includefile "../nvector/nvector.i" %beginfile
// ---------------------------------------------------------------
// Programmer: Cody J. Balos @ LLNL
// ---------------------------------------------------------------
// SUNDIALS Copyright Start
// Copyright (c) 2002-2019, Lawrence Livermore National Security
// and Southern Methodist University.
// All rights reserved.
//
// See the top-level LICENSE and NOTICE files for details.
//
// SPDX-License-Identifier: BSD-3-Clause
// SUNDIALS Copyright End
// ---------------------------------------------------------------
// Swig interface file
// ---------------------------------------------------------------


// Macro for creating an interface to an N_Vector



%endoffile
%includefile "../nvector/nvector_serial.i" %beginfile
// ---------------------------------------------------------------
// Programmer: Cody J. Balos @ LLNL
// ---------------------------------------------------------------
// SUNDIALS Copyright Start
// Copyright (c) 2002-2019, Lawrence Livermore National Security
// and Southern Methodist University.
// All rights reserved.
//
// See the top-level LICENSE and NOTICE files for details.
//
// SPDX-License-Identifier: BSD-3-Clause
// SUNDIALS Copyright End
// ---------------------------------------------------------------
// Swig interface file
// ---------------------------------------------------------------

/*@SWIG:../nvector/nvector.i,19,%nvector_impl@*/
  %rename($ignore) _N_VectorContent_Serial;
/*@SWIG@*/

// include the header file in the swig wrapper
%{
#include "nvector/nvector_serial.h"
%}

// Process and wrap functions in the following files
%includefile "/home/balos1/Workspace/SUNDIALS/repos/feature/python-kinsol/instdir/include/nvector/nvector_serial.h" %beginfile
/* -----------------------------------------------------------------
 * Programmer(s): Scott D. Cohen, Alan C. Hindmarsh, Radu Serban,
 *                and Aaron Collier @ LLNL
 * -----------------------------------------------------------------
 * SUNDIALS Copyright Start
 * Copyright (c) 2002-2021, Lawrence Livermore National Security
 * and Southern Methodist University.
 * All rights reserved.
 *
 * See the top-level LICENSE and NOTICE files for details.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 * SUNDIALS Copyright End
 * -----------------------------------------------------------------
 * This is the header file for the serial implementation of the
 * NVECTOR module.
 *
 * Notes:
 *
 *   - The definition of the generic N_Vector structure can be found
 *     in the header file sundials_nvector.h.
 *
 *   - The definition of the type 'realtype' can be found in the
 *     header file sundials_types.h, and it may be changed (at the
 *     configuration stage) according to the user's needs.
 *     The sundials_types.h file also contains the definition
 *     for the type 'booleantype'.
 *
 *   - N_Vector arguments to arithmetic vector operations need not
 *     be distinct. For example, the following call:
 *
 *       N_VLinearSum_Serial(a,x,b,y,y);
 *
 *     (which stores the result of the operation a*x+b*y in y)
 *     is legal.
 * -----------------------------------------------------------------*/








extern "C" {


/*
 * -----------------------------------------------------------------
 * SERIAL implementation of N_Vector
 * -----------------------------------------------------------------
 */

struct _N_VectorContent_Serial {
  sunindextype length;   /* vector length       */
  int own_data;  /* data ownership flag */
  realtype *data;        /* data array          */
};

typedef struct _N_VectorContent_Serial *N_VectorContent_Serial;

/*
 * -----------------------------------------------------------------
 * Macros NV_CONTENT_S, NV_DATA_S, NV_OWN_DATA_S,
 *        NV_LENGTH_S, and NV_Ith_S
 * -----------------------------------------------------------------
 */











/*
 * -----------------------------------------------------------------
 * Functions exported by nvector_serial
 * -----------------------------------------------------------------
 */

 N_Vector N_VNew_Serial(sunindextype vec_length);

 N_Vector N_VNewEmpty_Serial(sunindextype vec_length);

 N_Vector N_VMake_Serial(sunindextype vec_length, realtype *v_data);

 N_Vector* N_VCloneVectorArray_Serial(int count, N_Vector w);

 N_Vector* N_VCloneVectorArrayEmpty_Serial(int count, N_Vector w);

 void N_VDestroyVectorArray_Serial(N_Vector* vs, int count);

 sunindextype N_VGetLength_Serial(N_Vector v);

 void N_VPrint_Serial(N_Vector v);

 void N_VPrintFile_Serial(N_Vector v, FILE *outfile);

 N_Vector_ID N_VGetVectorID_Serial(N_Vector v);
 N_Vector N_VCloneEmpty_Serial(N_Vector w);
 N_Vector N_VClone_Serial(N_Vector w);
 void N_VDestroy_Serial(N_Vector v);
 void N_VSpace_Serial(N_Vector v, sunindextype *lrw, sunindextype *liw);
 realtype *N_VGetArrayPointer_Serial(N_Vector v);
 void N_VSetArrayPointer_Serial(realtype *v_data, N_Vector v);

/* standard vector operations */
 void N_VLinearSum_Serial(realtype a, N_Vector x, realtype b, N_Vector y, N_Vector z);
 void N_VConst_Serial(realtype c, N_Vector z);
 void N_VProd_Serial(N_Vector x, N_Vector y, N_Vector z);
 void N_VDiv_Serial(N_Vector x, N_Vector y, N_Vector z);
 void N_VScale_Serial(realtype c, N_Vector x, N_Vector z);
 void N_VAbs_Serial(N_Vector x, N_Vector z);
 void N_VInv_Serial(N_Vector x, N_Vector z);
 void N_VAddConst_Serial(N_Vector x, realtype b, N_Vector z);
 realtype N_VDotProd_Serial(N_Vector x, N_Vector y);
 realtype N_VMaxNorm_Serial(N_Vector x);
 realtype N_VWrmsNorm_Serial(N_Vector x, N_Vector w);
 realtype N_VWrmsNormMask_Serial(N_Vector x, N_Vector w, N_Vector id);
 realtype N_VMin_Serial(N_Vector x);
 realtype N_VWL2Norm_Serial(N_Vector x, N_Vector w);
 realtype N_VL1Norm_Serial(N_Vector x);
 void N_VCompare_Serial(realtype c, N_Vector x, N_Vector z);
 int N_VInvTest_Serial(N_Vector x, N_Vector z);
 int N_VConstrMask_Serial(N_Vector c, N_Vector x, N_Vector m);
 realtype N_VMinQuotient_Serial(N_Vector num, N_Vector denom);

/* fused vector operations */
 int N_VLinearCombination_Serial(int nvec, realtype* c, N_Vector* V,
                                                N_Vector z);
 int N_VScaleAddMulti_Serial(int nvec, realtype* a, N_Vector x,
                                            N_Vector* Y, N_Vector* Z);
 int N_VDotProdMulti_Serial(int nvec, N_Vector x,
                                           N_Vector* Y, realtype* dotprods);

/* vector array operations */
 int N_VLinearSumVectorArray_Serial(int nvec,
                                                   realtype a, N_Vector* X,
                                                   realtype b, N_Vector* Y,
                                                   N_Vector* Z);
 int N_VScaleVectorArray_Serial(int nvec, realtype* c,
                                               N_Vector* X, N_Vector* Z);
 int N_VConstVectorArray_Serial(int nvecs, realtype c,
                                               N_Vector* Z);
 int N_VWrmsNormVectorArray_Serial(int nvecs, N_Vector* X,
                                                  N_Vector* W, realtype* nrm);
 int N_VWrmsNormMaskVectorArray_Serial(int nvecs, N_Vector* X,
                                                      N_Vector* W, N_Vector id,
                                                      realtype* nrm);
 int N_VScaleAddMultiVectorArray_Serial(int nvec, int nsum,
                                                       realtype* a,
                                                       N_Vector* X,
                                                       N_Vector** Y,
                                                       N_Vector** Z);
 int N_VLinearCombinationVectorArray_Serial(int nvec, int nsum,
                                                           realtype* c,
                                                           N_Vector** X,
                                                           N_Vector* Z);

/* OPTIONAL local reduction kernels (no parallel communication) */
 realtype N_VWSqrSumLocal_Serial(N_Vector x, N_Vector w);
 realtype N_VWSqrSumMaskLocal_Serial(N_Vector x, N_Vector w, N_Vector id);

/* OPTIONAL XBraid interface operations */
 int N_VBufSize_Serial(N_Vector x, sunindextype *size);
 int N_VBufPack_Serial(N_Vector x, void *buf);
 int N_VBufUnpack_Serial(N_Vector x, void *buf);

/*
 * -----------------------------------------------------------------
 * Enable / disable fused vector operations
 * -----------------------------------------------------------------
 */

 int N_VEnableFusedOps_Serial(N_Vector v, int tf);

 int N_VEnableLinearCombination_Serial(N_Vector v, int tf);
 int N_VEnableScaleAddMulti_Serial(N_Vector v, int tf);
 int N_VEnableDotProdMulti_Serial(N_Vector v, int tf);

 int N_VEnableLinearSumVectorArray_Serial(N_Vector v, int tf);
 int N_VEnableScaleVectorArray_Serial(N_Vector v, int tf);
 int N_VEnableConstVectorArray_Serial(N_Vector v, int tf);
 int N_VEnableWrmsNormVectorArray_Serial(N_Vector v, int tf);
 int N_VEnableWrmsNormMaskVectorArray_Serial(N_Vector v, int tf);
 int N_VEnableScaleAddMultiVectorArray_Serial(N_Vector v, int tf);
 int N_VEnableLinearCombinationVectorArray_Serial(N_Vector v, int tf);


}



%endoffile
%endoffile

// Include helper to get vector data
%{
void N_VGetData(N_Vector v, sunindextype *length, realtype **data)
{
  *length = N_VGetLength(v);
  *data = N_VGetArrayPointer(v);
}
%}

// Insert SUNDIALS copyright into generated C files.
%insert(begin)
%{
/* ---------------------------------------------------------------
 * Programmer(s): Auto-generated by swig.
 * ---------------------------------------------------------------
 * SUNDIALS Copyright Start
 * Copyright (c) 2002-2019, Lawrence Livermore National Security
 * and Southern Methodist University.
 * All rights reserved.
 *
 * See the top-level LICENSE and NOTICE files for details.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 * SUNDIALS Copyright End
 * -------------------------------------------------------------*/
%}
%endoffile

// ---------------------
// KINSOL specific stuff
// ---------------------

// KINInit cannot be called from Python.
// Instead, users should call KINInitPy.
// %ignore KINInit;

// We hijack KINSetUserData to pass out director class
// objects. So, hide the function from users.
// %ignore KINSetUserData;

%{
#include "kinsol/kinsol.h"
#include "kinsol/kinsol_bbdpre.h"
#include "kinsol/kinsol_ls.h"
%}

// Apply typemap for Get functions that use an argout variable
%typemap(in, numinputs=0) realtype* (realtype temp) {
  $1 = &temp;
}
%typemap(argout) realtype* {
  $result = SWIG_Python_AppendOutput($result, PyFloat_FromDouble(*$1));
}
%typemap(in, numinputs=0) long* (long temp) {
  $1 = &temp;
}
%typemap(argout) long* {
  $result = SWIG_Python_AppendOutput($result, PyLong_FromLong(*$1));
}

// a typemap for the callback, it expects the argument to be an integer
// whose value is the address of an appropriate callback function
%typemap(in) KINPySysFn {
  $1 = (KINPySysFn)PyLong_AsVoidPtr($input);
}
%typemap(in) KINPyCallbackFn {
  $1 = (KINPyCallbackFn)PyLong_AsVoidPtr($input);
}


// Process definitions from these files
%includefile "/home/balos1/Workspace/SUNDIALS/repos/feature/python-kinsol/instdir/include/kinsol/kinsol.h" %beginfile
/* -----------------------------------------------------------------
 * Programmer(s): Allan Taylor, Alan Hindmarsh, Radu Serban, and
 *                Aaron Collier @ LLNL
 * -----------------------------------------------------------------
 * SUNDIALS Copyright Start
 * Copyright (c) 2002-2021, Lawrence Livermore National Security
 * and Southern Methodist University.
 * All rights reserved.
 *
 * See the top-level LICENSE and NOTICE files for details.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 * SUNDIALS Copyright End
 * -----------------------------------------------------------------
 * This is the header file for the main KINSOL solver.
 * -----------------------------------------------------------------*/









extern "C" {


/* -----------------
 * KINSOL Constants
 * ----------------- */

/*  return values */

%constant KIN_SUCCESS = 0;
%constant KIN_INITIAL_GUESS_OK = 1;
%constant KIN_STEP_LT_STPTOL = 2;

%constant KIN_WARNING = 99;

%constant KIN_MEM_NULL = -1;
%constant KIN_ILL_INPUT = -2;
%constant KIN_NO_MALLOC = -3;
%constant KIN_MEM_FAIL = -4;
%constant KIN_LINESEARCH_NONCONV = -5;
%constant KIN_MAXITER_REACHED = -6;
%constant KIN_MXNEWT_5X_EXCEEDED = -7;
%constant KIN_LINESEARCH_BCFAIL = -8;
%constant KIN_LINSOLV_NO_RECOVERY = -9;
%constant KIN_LINIT_FAIL = -10;
%constant KIN_LSETUP_FAIL = -11;
%constant KIN_LSOLVE_FAIL = -12;

%constant KIN_SYSFUNC_FAIL = -13;
%constant KIN_FIRST_SYSFUNC_ERR = -14;
%constant KIN_REPTD_SYSFUNC_ERR = -15;

%constant KIN_VECTOROP_ERR = -16;

/* Enumeration for eta choice */
%constant KIN_ETACHOICE1 = 1;
%constant KIN_ETACHOICE2 = 2;
%constant KIN_ETACONSTANT = 3;

/* Enumeration for global strategy */
%constant KIN_NONE = 0;
%constant KIN_LINESEARCH = 1;
%constant KIN_PICARD = 2;
%constant KIN_FP = 3;

/* ------------------------------
 * User-Supplied Function Types
 * ------------------------------ */

typedef void* KINPyCallbackFn;
 KINPyCallbackFn KINPyRegisterFn(KINPyCallbackFn f, const char* name);







typedef int (*KINSysFn)(N_Vector uu, N_Vector fval, void *user_data);
typedef int (*KINPySysFn)(double* uu, int uu_len, double* fval, int fval_len);
    int KINPySysFnDirector(N_Vector uu,N_Vector fval,void *user_data);    static inline KINSysFn KINPyRegisterKINSysFn(KINPySysFn f) {      return ((KINSysFn) KINPyRegisterFn((void*) f, "KINPySysFn"));    }

typedef void (*KINErrHandlerFn)(int error_code,
                                const char *module, const char *function,
                                char *msg, void *user_data);

typedef void (*KINInfoHandlerFn)(const char *module, const char *function,
                                 char *msg, void *user_data);

/* -------------------
 * Exported Functions
 * ------------------- */


/* Creation function */
 void *KINCreate(void);

/* Initialization function */
 int KINInit(void *kinmem, KINSysFn func, N_Vector tmpl);

/* Solver function */
 int KINSol(void *kinmem, N_Vector uu, int strategy,
                           N_Vector u_scale, N_Vector f_scale);

/* Optional input functions */
 int KINSetErrHandlerFn(void *kinmem, KINErrHandlerFn ehfun,
                                       void *eh_data);
 int KINSetErrFile(void *kinmem, FILE *errfp);
 int KINSetErrFilename(void *kinmem, const char* filename);
 int KINSetInfoHandlerFn(void *kinmem, KINInfoHandlerFn ihfun,
                                        void *ih_data);
 int KINSetInfoFile(void *kinmem, FILE *infofp);
 int KINSetUserData(void *kinmem, void *user_data);
 int KINSetPrintLevel(void *kinmem, int printfl);
 int KINSetDamping(void *kinmem, realtype beta);
 int KINSetMAA(void *kinmem, long int maa);
 int KINSetDelayAA(void *kinmem, long int delay);
 int KINSetDampingAA(void *kinmem, realtype beta);
 int KINSetReturnNewest(void *kinmem, int ret_newest);
 int KINSetNumMaxIters(void *kinmem, long int mxiter);
 int KINSetNoInitSetup(void *kinmem, int noInitSetup);
 int KINSetNoResMon(void *kinmem, int noNNIResMon);
 int KINSetMaxSetupCalls(void *kinmem, long int msbset);
 int KINSetMaxSubSetupCalls(void *kinmem, long int msbsetsub);
 int KINSetEtaForm(void *kinmem, int etachoice);
 int KINSetEtaConstValue(void *kinmem, realtype eta);
 int KINSetEtaParams(void *kinmem, realtype egamma,
                                    realtype ealpha);
 int KINSetResMonParams(void *kinmem, realtype omegamin,
                                       realtype omegamax);
 int KINSetResMonConstValue(void *kinmem, realtype omegaconst);
 int KINSetNoMinEps(void *kinmem, int noMinEps);
 int KINSetMaxNewtonStep(void *kinmem, realtype mxnewtstep);
 int KINSetMaxBetaFails(void *kinmem, long int mxnbcf);
 int KINSetRelErrFunc(void *kinmem, realtype relfunc);
 int KINSetFuncNormTol(void *kinmem, realtype fnormtol);
 int KINSetScaledStepTol(void *kinmem, realtype scsteptol);
 int KINSetConstraints(void *kinmem, N_Vector constraints);
 int KINSetSysFunc(void *kinmem, KINSysFn func);


/* Optional output functions */
 int KINGetWorkSpace(void *kinmem, long int *lenrw,
                                    long int *leniw);
 int KINGetNumNonlinSolvIters(void *kinmem, long int *nniters);
 int KINGetNumFuncEvals(void *kinmem, long int *nfevals);
 int KINGetNumBetaCondFails(void *kinmem, long int *nbcfails);
 int KINGetNumBacktrackOps(void *kinmem, long int *nbacktr);
 int KINGetFuncNorm(void *kinmem, realtype *fnorm);
 int KINGetStepLength(void *kinmem, realtype *steplength);
 char *KINGetReturnFlagName(long int flag);

/* Free function */
 void KINFree(void **kinmem);

/* KINLS interface function that depends on KINSysFn */
 int KINSetJacTimesVecSysFn(void *kinmem, KINSysFn jtimesSysFn);


}



%endoffile
%includefile "/home/balos1/Workspace/SUNDIALS/repos/feature/python-kinsol/instdir/include/kinsol/kinsol_bbdpre.h" %beginfile
/* -----------------------------------------------------------------
 * Programmer(s): Daniel R. Reynolds @ SMU
 *                Alan Hindmarsh, Radu Serban, and
 *                Aaron Collier @ LLNL
 * -----------------------------------------------------------------
 * SUNDIALS Copyright Start
 * Copyright (c) 2002-2021, Lawrence Livermore National Security
 * and Southern Methodist University.
 * All rights reserved.
 *
 * See the top-level LICENSE and NOTICE files for details.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 * SUNDIALS Copyright End
 * -----------------------------------------------------------------
 * This is the header file for the KINBBDPRE module, for a
 * band-block-diagonal preconditioner, i.e. a block-diagonal
 * matrix with banded blocks.
 * -----------------------------------------------------------------*/







extern "C" {


/* KINBBDPRE return values */

%constant KINBBDPRE_SUCCESS = 0;
%constant KINBBDPRE_PDATA_NULL = -11;
%constant KINBBDPRE_FUNC_UNRECVR = -12;

/* User-supplied function Types */

typedef int (*KINBBDCommFn)(sunindextype Nlocal, N_Vector u,
                            void *user_data);

typedef int (*KINBBDLocalFn)(sunindextype Nlocal, N_Vector uu,
                             N_Vector gval, void *user_data);

/* Exported Functions */

 int KINBBDPrecInit(void *kinmem, sunindextype Nlocal,
                                   sunindextype mudq, sunindextype mldq,
                                   sunindextype mukeep, sunindextype mlkeep,
                                   realtype dq_rel_uu,
                                   KINBBDLocalFn gloc, KINBBDCommFn gcomm);

/* Optional output functions */

 int KINBBDPrecGetWorkSpace(void *kinmem,
                                           long int *lenrwBBDP,
                                           long int *leniwBBDP);

 int KINBBDPrecGetNumGfnEvals(void *kinmem,
                                             long int *ngevalsBBDP);



}



%endoffile
%includefile "/home/balos1/Workspace/SUNDIALS/repos/feature/python-kinsol/instdir/include/kinsol/kinsol_ls.h" %beginfile
/* ----------------------------------------------------------------
 * Programmer(s): Daniel R. Reynolds @ SMU
 *                Scott Cohen, Alan Hindmarsh, Radu Serban, and
 *                Aaron Collier @ LLNL
 * ----------------------------------------------------------------
 * SUNDIALS Copyright Start
 * Copyright (c) 2002-2021, Lawrence Livermore National Security
 * and Southern Methodist University.
 * All rights reserved.
 *
 * See the top-level LICENSE and NOTICE files for details.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 * SUNDIALS Copyright End
 * ----------------------------------------------------------------
 * This is the header file for KINSOL's linear solver interface.
 * ----------------------------------------------------------------*/











extern "C" {



/*==================================================================
  KINLS Constants
  ==================================================================*/

%constant KINLS_SUCCESS = 0;

%constant KINLS_MEM_NULL = -1;
%constant KINLS_LMEM_NULL = -2;
%constant KINLS_ILL_INPUT = -3;
%constant KINLS_MEM_FAIL = -4;
%constant KINLS_PMEM_NULL = -5;
%constant KINLS_JACFUNC_ERR = -6;
%constant KINLS_SUNMAT_FAIL = -7;
%constant KINLS_SUNLS_FAIL = -8;


/*===============================================================
  KINLS user-supplied function prototypes
  ===============================================================*/

typedef int (*KINLsJacFn)(N_Vector u, N_Vector fu, SUNMatrix J,
                          void *user_data, N_Vector tmp1, N_Vector tmp2);

typedef int (*KINLsPrecSetupFn)(N_Vector uu, N_Vector uscale,
                                N_Vector fval, N_Vector fscale,
                                void *user_data);

typedef int (*KINLsPrecSolveFn)(N_Vector uu, N_Vector uscale,
                                N_Vector fval, N_Vector fscale,
                                N_Vector vv, void *user_data);

typedef int (*KINLsJacTimesVecFn)(N_Vector v, N_Vector Jv, N_Vector uu,
                                  int *new_uu, void *J_data);


/*==================================================================
  KINLS Exported functions
  ==================================================================*/

 int KINSetLinearSolver(void *kinmem, SUNLinearSolver LS,
                                       SUNMatrix A);


/*-----------------------------------------------------------------
  Optional inputs to the KINLS linear solver interface
  -----------------------------------------------------------------*/

 int KINSetJacFn(void *kinmem, KINLsJacFn jac);
 int KINSetPreconditioner(void *kinmem,
                                         KINLsPrecSetupFn psetup,
                                         KINLsPrecSolveFn psolve);
 int KINSetJacTimesVecFn(void *kinmem,
                                        KINLsJacTimesVecFn jtv);

/*-----------------------------------------------------------------
  Optional outputs from the KINLS linear solver interface
  -----------------------------------------------------------------*/

 int KINGetLinWorkSpace(void *kinmem,
                                       long int *lenrwLS,
                                       long int *leniwLS);
 int KINGetNumJacEvals(void *kinmem,
                                      long int *njevals);
 int KINGetNumLinFuncEvals(void *kinmem,
                                          long int *nfevals);
 int KINGetNumPrecEvals(void *kinmem,
                                       long int *npevals);
 int KINGetNumPrecSolves(void *kinmem,
                                        long int *npsolves);
 int KINGetNumLinIters(void *kinmem,
                                      long int *nliters);
 int KINGetNumLinConvFails(void *kinmem,
                                          long int *nlcfails);
 int KINGetNumJtimesEvals(void *kinmem,
                                         long int *njvevals);
 int KINGetLastLinFlag(void *kinmem,
                                      long int *flag);
 char *KINGetLinReturnFlagName(long int flag);



}



%endoffile

%insert("python")
%{

import ctypes

# We provide the ctypes for all the callback functions in KINSol here as
# a convenience to our users. They could always define it themselves too.
class cfunctypes():
  KINSysFn = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.POINTER(ctypes.c_double), ctypes.c_int, ctypes.POINTER(ctypes.c_double), ctypes.c_int)

def RegisterFn(py_callback, py_callback_type):

  f_in = py_callback_type(py_callback)
  f_in_ptr = ctypes.cast(f_in, ctypes.c_void_p).value
  f_out_ptr = _kinsol.KINPyRegisterFn(f_in_ptr, "KINSysFn")
  return ctypes.cast(ctypes.c_void_p(int(f_out_ptr)), py_callback_type)

def RegisterFn2(py_callback, py_callback_type):

  f_in = py_callback_type(py_callback)
  f_in_ptr = ctypes.cast(f_in, ctypes.c_void_p).value

  if py_callback_type == cfunctypes.KINSysFn:
    return _kinsol.KINPyRegisterKINSysFn(f_in_ptr)

def RegisterNumbaFn(kmem, py_callback):

  f = py_callback.ctypes
  f_ptr = ctypes.cast(f, ctypes.c_void_p).value
  return _kinsol.KINPyRegisterFn(kmem, f_ptr, "KINSysFn")

%}
%endoffile
