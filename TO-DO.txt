1. Create SUNLAPACKDense, SUNLAPACKBand, and SUNPCG objects.  Create 
   testing routines similar to NVector test routines.

   Note about solver-specific counters:
   For iterative solvers these should be contained *inside* the 
   iterative linear solver.  However, for dense/band linear solvers 
   we have the counters: 
      nje: # of calls to the user Jacobian routine
      nfeDQ: # of calls to the user RHS for difference-quotient
        Jacobian approximation
      nstlj: time step at last call to Jacobian construction routine
   these all *should* be stored inside the integrator memory
   structure.  The first two of these are implemented by the DQ
   Jacobian construction routine, and the third is a
   time-step-specific *signal* on when to update the Jacobian.
   We should initialize/re-initialize these whenever the integrator is
   initialized/re-initialized. 


2. Convert existing use of dense, band and sparse matrices throughout
   SUNDIALS (solvers and examples) to instead use the SUNMatrix
   objects.  Fortran interfaces will work like now, where we extract
   the data portions to pass through function calls.


3. Construct ARKode interfaces to utilize linear solver and matrix
   objects.  Update all ARKode examples accordingly.


4. Repeat 4 for CVODE, CVODES, IDA, IDAS and KINSOL. 


5. Create common set of return values and error messages for all 
   SUNLinearSolver and SUNMatrix objects (put in
   sundials_linearsolver.h and sundials_matrix.h), and update all
   SUNLinearSolver and SUNMatrix implementations to use those.

