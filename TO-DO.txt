1. Create SUNPCG object and testing routine:

   Note about solver-specific counters:

   For iterative solvers these should be contained *inside* the
   iterative linear solver.  However, for dense/band linear solvers 
   we have the counters: 
      nje: # of calls to the user Jacobian routine
      nfeDQ: # of calls to the user RHS for difference-quotient
        Jacobian approximation
      nstlj: time step at last call to Jacobian construction routine
   these all *should* be stored inside the integrator memory
   structure.  The first two of these are implemented by the DQ
   Jacobian construction routine, and the third is a
   time-step-specific *signal* on when to update the Jacobian.
   We should initialize/re-initialize these whenever the integrator is
   initialized/re-initialized. 


2. Construct ARKode interfaces to utilize linear solver and matrix
   objects.  Update all ARKode examples accordingly.


3. Repeat 2 for CVODE, CVODES, IDA, IDAS and KINSOL. 


4. Create common set of return values and error messages for all 
   SUNLinearSolver and SUNMatrix objects (put in
   sundials_linearsolver.h and sundials_matrix.h), and update all
   SUNLinearSolver and SUNMatrix implementations to use those.


5. Update SUNMatrix 'copy' routine to swap order of arguments (second
   is a copy of the first) to match N_Vector and previous matrix
   operations. 


6. Add in checks to ARKode initialization (and other solvers) to
   ensure that when a sparse matrix is used, the Jacobian construction
   function is provided.


7. Revisit scaling vectors with PCG (without preconditioning) -- this
   seems to work improperly now.  Perhaps it is the testing code, or
   maybe the solver itself.
   
