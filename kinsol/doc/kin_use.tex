%===================================================================================
\chapter{Using KINSOL}\label{c:usage}
%===================================================================================

This chapter is concerned with the use of {\kinsol} for the solution
of nonlinear systems.  The following subsections treat the header
files, the layout of the user's main program, description of the
{\kinsol} user-callable routines, and user-supplied functions.  The
listings of the sample programs in the companion document
\cite{kinsol2.2.0_ex} may also be helpful.  Those codes may be used as
templates (with the removal of some lines involved in testing), and
are included in the {\kinsol} package.

{\kinsol} uses various constants for both input and output.  These are
defined as needed in this chapter, but for convenience are also listed
separately in Chapter \ref{c:constants}.

%%----------------------------------
\section{Data types}\label{s:types}
%%----------------------------------
\input{types}

%------------------------
\section{Header Files}\label{s:header_sol}
%------------------------

The calling program must include several header files so that various macros
and data types can be used. The header file that is always required is:
%
\begin{itemize}
\item  \Id{kinsol.h}, 
  the header file for {\kinsol}, which defines several
  types and various constants, and includes function prototypes.
\end{itemize}
%
\id{kinsol.h} also includes \Id{sundialstypes.h}, 
which defines the types \id{realtype} and \id{booleantype}
and constants \id{FALSE} and \id{TRUE}.

The calling program must also include an {\nvector} implementation header file
(see Chapter \ref{s:nvector} for details).
For the two {\nvector} implementations that are included in the {\kinsol} package,
the corresponding header files are:
%
\begin{itemize}
\item \Id{nvector\_serial.h}, 
  which defines the serial implementation, {\nvecs};
\item \Id{nvector\_parallel.h}, 
  which defines the parallel {\mpi} implementation, {\nvecp}.
\end{itemize}
%
Note that both of these files include in turn the header file \Id{nvector.h}, which 
defines the abstract \Id{N\_Vector} type. 

Finally, a linear solver module header file is required. 
\index{KINSOL@{\kinsol} linear solvers!header files}
At the present time, {\kinsol} offers only a Krylov linear solver, {\kinspgmr},
whose corresponding header file is \Id{kinspgmr.h}, 
This in turn includes a header file (\id{iterative.h})
which enumerates the kind of preconditioning and the choices for the
Gram-Schmidt process.

Other headers may be needed, according to the choice of
preconditioner, etc. For example, in the \id{kinwebs} example~\cite{kinsol2.2.0_ex}, 
preconditioning is done with a block-diagonal matrix. For this, the header
\id{smalldense.h} is included.

%-------------------------------------------------
\section{A Skeleton of the User's Main Program}\label{s:skeleton_sol}
%-------------------------------------------------

A high-level view of the combined user program and {\kinsol} package is
shown in Figure~\ref{f:sim_overview}.
%%
\begin{figure}
\centerline{\psfig{figure=kinsim.eps,width=\textwidth}}
\caption {Diagram of the user program and 
  KINSOL package for the solution of nonlinear systems}\label{f:sim_overview}
\end{figure}
%%
The following is a skeleton of the user's main program (or calling
program) for the solution of a nonlinear problem. 
Most steps are independent of the {\nvector} implementation used; 
where this is not the case, usage specifications are given for the two implementations 
provided with {\kinsol}: steps marked with {\p} correspond to 
{\nvecp}, while steps marked with {\s} correspond to {\nvecs}.
%
\index{User main program!KINSOL@{\kinsol} usage}
\begin{Steps}
  
\item 
  {\bf Initialize MPI}

  {\p} \id{MPI\_Init(\&argc, \&argv);} to initialize {\mpi} if used by
  the user's program, aside from the internal use in {\nvecp}.  
  Here \id{argc} and \id{argv} are the command line argument 
  counter and array received by \id{main}.
  
\item
  {\bf Set problem dimensions}

  {\s} Set \id{N}, the problem size $N$.

  {\p} Set \id{Nlocal}, the local vector length (the sub-vector
  length for this process); \id{N}, the global vector length (the
  problem size $N$, and the sum of all the values of \id{Nlocal});
  and the active set of processes.
  
\item
  {\bf Set vector with initial guess}
 
  To set the vector \id{u} of initial values, use functions defined by a
  particular {\nvector} implementation.  If a \id{realtype} array  \id{udata}
  already exists, containing the initial guess of $u_0$, make the call:

  {\s} \id{u = NV\_Make\_Serial(N, udata);}

  {\p} \id{u = NV\_Make\_Parallel(comm, Nlocal, N, udata);}

  Otherwise, make the call:

  {\s} \id{u = NV\_New\_Serial(N);}

  {\p} \id{u = NV\_New\_Parallel(comm, Nlocal, N);}

  and load initial values into the structure defined by:

  {\s} \id{NV\_DATA\_S(u)}

  {\p} \id{NV\_DATA\_P(u)}

  Here \id{comm} is the {\mpi} communicator, set in one of two ways: 
  If a proper subset of active processes is to be used, \id{comm} 
  must be set by suitable {\mpi} calls. Otherwise, to specify that all 
  processes are to be used, \id{comm} must be \id{MPI\_COMM\_WORLD}.
  
\item\label{i:kinsol_create} 
  {\bf Create {\kinsol} object}

  Call \id{kin\_mem = KINCreate();} 
  to create the {\kinsol} memory block.
  \id{KINCreate} returns a pointer to the {\kinsol} memory structure.

\item
  {\bf Set optional inputs}

  Call \id{KINSet*} routines to change any
  optional inputs that control the behavior of {\kinsol} from their default 
  values.

\item\label{i:kinsol_malloc} 
  {\bf Allocate internal memory}

  Call \id{KINMalloc(...);} 
  to specify the problem defining function $F$,
  allocate internal memory for {\kinsol}, 
  and initialize {\kinsol}.
  \id{KINMalloc} returns an error flag to indicate success or an illegal argument value
  (for details see \S\ref{ss:kinmalloc}).

\item\label{i:lin_solver} 
  {\bf Attach linear solver module}

  Initialize the linear solver module by calling \id{KINSpgmr(...);}
  to specify the maximum dimension of the Krylov subspace.

\item
  {\bf Set linear solver optional inputs}

  Call \id{KINSpgmrSet*} routines to change optional inputs  
  for the {\kinspgmr} linear solver.

\item
  {\bf Solve problem}

  Call \id{KINSol(...);} to solve the nonlinear problem for a given
  initial guess (see \S\ref{ss:kinsol} for details).

\item
  {\bf Get optional outputs}

  Call \id{KINGet*} functions to obtain optional output from {\kinsol},
  and call \id{KINSpgmrGet*} functions for optional outputs from {\kinspgmr}.
  See \S\ref{ss:optional_output}.

\item
  {\bf Deallocate memory for solution vector}

  Upon completion of the solution, deallocate memory for the vector \id{u}
  by calling the destructor function defined by the {\nvector} implementation:

  {\s} \id{NV\_Destroy\_Serial(u);}

  {\p} \id{NV\_Destroy\_Parallel(u);}
  
\item
  {\bf Free solver memory}

  Call \id{KINFree(kin\_mem);} to free the memory allocated for {\kinsol}.
  
\item 
  {\bf {\p} Finalize MPI}

  Call \id{MPI\_Finalize();} to terminate {\mpi}.
  
\end{Steps}

%%==============================================================================

\section{User-callable functions}\label{s:kinsol_fct_sol}

This section describes the {\kinsol} functions that are called by the
user to set up and solve a nonlinear problem. Some of these are required. However,
starting with \S\ref{ss:optional_input}, the functions listed involve
optional inputs/outputs or restarting, and those paragraphs can be
skipped for a casual use of {\kinsol}. In any case, refer to
\S\ref{s:skeleton_sol} for the correct order of these calls.

%%-------------------------------------------------------------------------------

\subsection{KINSOL initialization and deallocation functions}\label{ss:kinmalloc}

The following three functions must be called in the order listed. The last one
is to be called only after the problem solution is complete, as it frees the
{\kinsol} memory block created and allocated by the first two calls.
%%
\ucfunction{KINCreate}
{
  kin\_mem = KINCreate();
}
{
  The function \ID{KINCreate} instantiates a {\kinsol} solver object.
}
{
  This function has no arguments.
}
{
  If successful, \id{KINCreate} returns a pointer to the newly created 
  {\kinsol} memory block (of type \id{void *}).
  If an error occurred, \id{KINCreate} prints an error message to \id{stderr}
  and returns \id{NULL}.
}
{}
%%
%%
\ucfunction{KINMalloc}
{
flag = KINMalloc(kin\_mem, func, tmpl);
}
{
  The function \ID{KINMalloc} specifies the problem-defining
  function, allocates internal memory, and initializes {\kinsol}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block returned by \id{KINCreate}.
  \item[func] (\Id{KINSysFn})
    is the {\C} function which computes $F$ in the nonlinear problem. 
    This function has the form \id{func(u, fval, f\_data)} 
    (for full details see \S\ref{ss:sysFn}).
  \item[tmpl] (\id{N\_Vector})
    is an \id{N\_Vector} which is used as a template to create (by cloning)
    necessary vectors in \id{kin\_mem}.
  \end{args}
}
{
  The return flag \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The call to \id{KINMalloc} was successful.
  \item[\Id{KIN\_MEM\_NULL}] 
    The {kinsol} memory block was not initialized through a previous call
    to \id{KINCreate}.
  \item[\Id{KIN\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{KIN\_ILL\_INPUT}] 
    An input argument to \id{KINMalloc} has an illegal value.
  \end{args}
}
{
  If an error occurred, \id{KINMalloc} also prints an error message to the
  file specified by the optional input \id{errfp}.
}
%%
%%
\ucfunction{KINFree}
{
  KINFree(kin\_mem);
}
{
  The function \ID{KINFree} frees the pointer allocated by
  a previous call to \id{KINMalloc}.
}
{
  The argument is the pointer to the {\kinsol} memory block (of type \id{void *}).
}
{
  The function \id{KINFree} has no return value.
}
{}
%%

%%-------------------------------------------------------------------------------

\subsection{Linear solver specification function}\label{ss:lin_solv_init}

As previously explained, Newton iteration requires the solution of
linear systems of the form (\ref{e:Newton}).  At the present time
there is only one solver available for this task, {\kinspgmr}. 
This is an iterative solver that uses a scaled preconditioned
GMRES method.

\index{KINSOL{\kinsol} linear solvers!selecting|(} 
To attach the {\kinspgmr} linear solver, after the call to \id{KINCreate}
but before any call to \id{KINSol}, the user's program must call  \Id{KINSpgmr},
as documented below. The first argument passed to this function is the {\kinsol}
memory pointer returned by \id{KINCreate}.  The call to this
function links the linear solver to the main {\kinsol} memory block and
allows the user to specify parameters for {\kinspgmr}
%%

\index{KINSOL@{\kinsol} linear solvers!built on generic solvers} 
The {\kinspgmr} linear solver is actually built on top of a generic
linear system solver, which may be of interest in itself.  This generic
solver, {\spgmr}, is described separately in Chapter \ref{s:gen_linsolv}.

\index{KINSOL@{\kinsol} linear solvers!KINSPGMR@{\kinspgmr}}
\ucfunction{KINSpgmr}
{
  flag = KINSpgmr(kin\_mem, maxl);
}
{
  \index{KINSPGMR@{\kinspgmr} linear solver!selection of} 
  The function \ID{KINSpgmr} selects the {\kinspgmr} linear solver. 
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[maxl] (\id{int})
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{KINSPGMR\_MAXL}$=5$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPGMR\_ILL\_INPUT]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The {\kinspgmr} initialization was successful.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_ILL\_INPUT}]
    The {\nvector} module used does not implement a required operation.
  \item[\Id{KINSPGMR\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\kinspgmr} solver uses a scaled preconditioned GMRES\index{GMRES method}
  iterative method to solve the linear system (\ref{e:Newton}).

  Within {\kinsol}, only right preconditioning is available.
  For specification of the preconditioner,
  see \S\ref{ss:optional_input} and \S\ref{ss:user_fct_sol}.

  If preconditioning is done, user-supplied functions define the right 
  preconditioner matrices $P$, which approximate the Newton matrix
  from (\ref{e:Newton}).
}

%--------------------------------------------------------------------
\subsection{KINSOL solver function}\label{ss:kinsol}

\ucfunction{KINSol}
{
  flag = KINSol(kin\_mem, u, strategy, u\_scale, f\_scale);
}
{
  The function \ID{KINSol} computes an approximate solution of the nonlinear
  system.
}
{
  \begin{args}[strategy]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[u] (\id{N\_Vector})
    vector set to initial guess by user before calling \id{KINSol},
    but which upon return contains an approximate solution of
    the nonlinear system $F(u)=0$ the computed solution vector.
  \item[strategy]
    globalization strategy applied to the Newton method.
    It must be one of \ID{KIN\_INEXACT\_NEWTON} or \ID{KIN\_LINESEARCH}.
  \item[u\_scale]
    vector containing diagonal elements of scaling matrix $D_u$ for vector \id{u}
    chosen so that the components of $D_u \cdot$\id{u}
    (as a matrix multiplication) all have about the same magnitude when 
    \id{u} is close to a root of $F(u)$.
  \item[f\_scale]
    vector containing diagonal elements of scaling matrix $D_F$ for $F(u)$ chosen 
    so that the components of $D_F \cdot F($\id{u}$)$ 
    (as a matrix multiplication) all have roughly the same magnitude when 
    \id{u} is not too near a root of $F(u)$.
  \end{args}
}
{
  On return, \id{KINSol} returns the approximate solution in the vector \id{u}.
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[a]

  \item[\Id{KIN\_SUCCESS}]\rule{0pt}{0pt}

    \id{KINSol} succeeded; the scaled norm of $F(u)$ is less than \id{fnormtol}.

  \item[\Id{KIN\_INITIAL\_GUESS\_OK}]\rule{0pt}{0pt}

    The guess \id{u} $=u_0$ satisfied the system $F(u)=0$
    within the tolerances specified.

  \item[\Id{KIN\_STEP\_LT\_STPTOL}]\rule{0pt}{0pt}

    {\kinsol} stopped based on scaled step length.
    This means that the current iterate may be an approximate solution of the given
    nonlinear system, but it is also quite possible that the algorithm is ``stalled" 
    (making insufficient progress) near an invalid solution, or that the 
    scalar \id{scsteptol} is too large (see \id{KINSetScaledStepTol} in 
    \S\ref{ss:optional_input} to change \id{scsteptol} from its default value).

  \item[\Id{KIN\_MEM\_NULL}]\rule{0pt}{0pt}

    The {\kinsol} memory block pointer was \id{NULL}.
 
  \item[\Id{KIN\_ILL\_INPUT}]\rule{0pt}{0pt}

    An input parameter was invalid.

  \item[\Id{KIN\_NO\_MALLOC}]\rule{0pt}{0pt}

    The {\kinsol} memory was not allocated by a call to \id{KINMalloc}.

  \item[\Id{KIN\_LINESEARCH\_NONCONV}]\rule{0pt}{0pt}

    The line search algorithm was unable
    to find an iterate sufficiently distinct
    from the current iterate, or could not find an iterate satisfying
    the sufficient decrease condition.
    
    Failure to satisfy the sufficient decrease
    condition could mean the current iterate is
    ``close" to an approximate solution of the given
    nonlinear system, the finite difference
    approximation of the matrix-vector product
    $J(u) v$ is inaccurate, or the real scalar
    \id{scsteptol} is too large.
 
  \item[\Id{KIN\_MAXITER\_REACHED}] \rule{0pt}{0pt}

    The maximum number of nonlinear iterations
    has been reached.
 
  \item[\Id{KIN\_MXNEWT\_5X\_EXCEEDED}]\rule{0pt}{0pt}
    
    Five consecutive steps have been taken
    that satisfy the inequality
    $\|D_u p\|_{L2} > 0.99 \,$ \id{mxnewtstep},
    where $p$ denotes the current step and
    \id{mxnewtstep} is a scalar upper bound
    on the scaled step length.
    
    Such a failure may mean that $\|D_F F(u)\|_{L2}$
    asymptotes from above to a finite value, or
    the real scalar \id{mxnewtstep} is too small.
 
  \item[\Id{KIN\_LINESEARCH\_BCFAIL}]\rule{0pt}{0pt}

    The line search algorithm
    was unable to satisfy the
    ``beta-condition'' for \id{MXNBCF} $+ 1$ nonlinear
    iterations (not necessarily consecutive),
    which may indicate the algorithm is making
    poor progress.
 
  \item[\Id{KIN\_LINSOLV\_NO\_RECOVERY}]\rule{0pt}{0pt}

    The user-supplied routine \id{psolve}
    encountered a recoverable error, but
    the preconditioner is already current.
 
  \item[\Id{KIN\_LINIT\_FAIL}]\rule{0pt}{0pt}

    The linear solver initialization routine (\id{linit})
    encountered an error.
 
  \item[\Id{KIN\_LSETUP\_FAIL}]\rule{0pt}{0pt}

    The user-supplied routine \id{pset} (used to set up 
    the preconditioner data) encountered an unrecoverable
    error.
 
  \item[\Id{KIN\_LSOLVE\_FAIL}]\rule{0pt}{0pt}

    Either the user-supplied routine \id{psolve} (used to
    to solve the preconditioned linear system) encountered
    an unrecoverable error, or the linear solver routine
    (\id{lsolve}) encountered an error condition.
 
  \end{args}
}
{
  The components of vectors \id{u\_scale} and \id{f\_scale} should be strictly positive.
  
  \id{KIN\_SUCCESS} $=0$, \id{KIN\_INITIAL\_GUESS\_OK} $=1$, and 
  \id{KIN\_STEP\_LT\_STPTOL} $=2$.
  %%
  All remaining return values are negative and therefore a test \id{flag} $< 0$
  will trap all \id{KINSol} failures.
}


%%==============================================================================
\subsection{Optional input functions}\label{ss:optional_input}
%%==============================================================================

{\kinsol} provides an extensive list of functions that can be used to change
from their default values various optional input parameters that control the
behavior of the {\kinsol} solver. 
Table \ref{t:optional_input} lists all optional input functions in {\kinsol}, which 
are then described in detail in the remainder of this section.
For the most casual use of {\kinsol}, the reader can skip to \S\ref{ss:user_fct_sol}.

We note that, on error return, all of these functions also print an error message
to \id{stderr} (or to the file pointed to by \id{errfp} if already specified).
\index{error message}
We also note that all error return values are negative, so a test \id{flag} $<0$
will catch any error.

\begin{table}
\centering
\caption{Optional inputs for KINSOL and KINSPGMR}
\label{t:optional_input}
\medskip
\begin{tabular}{|l|l|l|}\hline
{\bf Optional input} & {\bf Function name} & {\bf Default} \\
\hline
\multicolumn{3}{|c|}{\bf KINSOL main solver} \\
\hline
Pointer to an error file & \id{KINSetErrFile} & \id{stderr}  \\
Pointer to an info file & \id{KINSetInfoFile} & \id{stdout} \\
Data for problem-defining function & \id{KINSetFdata} & \id{NULL} \\
Verbosity level of output & \id{KINSetPrintLevel} & 0 \\
Max. number of nonlinear iterations & \id{KINSetNumMaxIters} & 200 \\
No initial preconditioner setup & \id{KINSetNoPrecInit} & \id{FALSE} \\
Max. iterations without prec. setup & \id{KINSetMaxPrecCalls} & 10 \\
Form of $\eta$ coefficient & \id{KINSetEtaForm} &  \id{KIN\_ETACHOICE1}\\
Constant value of $\eta$ & \id{KINSetEtaConstValue} &  0.1 \\
Values of $\gamma$ and $\alpha$ & \id{KINSetEtaParams} & 0.9 and 2.0 \\
Lower bound on $\epsilon$ & \id{KINSetNoMinEps} & \id{FALSE} \\
Max. scaled length of Newton step & \id{KINSetMaxNewtonStep} & $1000 \| D_u u_0 \|_2$ \\
Rel. error for F.D. $Jv$ & \id{KINSetRelErrFunc} & $\sqrt{\text{uround}}$ \\
Function-norm stopping tolerance & \id{KINSetFuncNormTol} & $\sqrt[3]{\text{uround}}$ \\
Scaled-step stopping tolerance & \id{KINSetScaledSteptol} & $\text{uround}^{2/3}$ \\
Inequality constraints on solution & \id{KINSetConstraints} & \id{NULL} \\
Nonlinear system function & \id{KINSetSysFunc} & none \\
\hline
\multicolumn{3}{|c|}{\bf KINSPGMR linear solver} \\
\hline
Max. number of restarts & \id{KINSpgmrSetMaxRestarts} & 0 \\
Preconditioner functions and data & \id{KINSpgmrSetPreconditioner} & \id{NULL}, \id{NULL}, \id{NULL} \\
Jacobian-vector product function and data & \id{KINSpgmrSetJacTimesVecFn} & internal DQ, \id{NULL} \\
\hline
\end{tabular}
\end{table}

\subsubsection{Main solver optional input functions}
\index{optional input!solver|(}
The calls listed here can be executed in any order. However, if \id{KINSetErrFile} 
is to be called, that call should be first, in order to take effect for any later 
error message.
%%
%%
\index{error message}
\ucfunction{KINSetErrFile}
{
flag = KINSetErrFile(kin\_mem, errfp);
}
{
  The function \ID{KINSetErrFile} specifies the pointer to the file
  where all {\kinsol} error messages should be directed.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[errfp] (\id{FILE *})
    pointer to output file.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{errfp} is \id{stderr}.

  Passing a value \id{NULL} disables all future error message output
  (except for the case in which the {\kinsol} memory pointer is \id{NULL}).

  {\warn} If \id{KINSetErrFile} is to be called, it should be called before any
  other optional input functions, in order to take effect for any later error message.
}
%%
%%
\ucfunction{KINSetInfoFile}
{
flag = KINSetInfoFile(kin\_mem, infofp);
}
{
  The function \ID{KINSetInfoFile} specifies the pointer to the file
  where all informative messages should be directed.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[infofp] (\id{FILE *})
    pointer to output file.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{infofp} is \id{stderr}.
}
%%
%%
\ucfunction{KINSetPrintLevel}
{
flag = KINSetPrintLevel(kin\_mem, printfl);
}
{
  The function \ID{KINSetPrintLevel} specifies the level of verbosity
  of the output.
}
{
  \begin{args}[kin\_mem]

  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.

  \item[printfl] (\id{int})
    flag indicating the level of verbosity. Must be one of:
    
    \begin{itemize}
    \item[0]
      no information displayed.
      
    \item[1]
      for each nonlinear iteration display
      the following information: the scaled
      Euclidean $\ell_2$ norm of the system function
      evaluated at the current iterate, the
      scaled norm of the Newton step (only if
      using \id{KIN\_INEXACT\_NEWTON}), and the
      number of function evaluations performed
      so far.
      
    \item[2]
      display level 1 output and the
      following values for each iteration:
      
      $\|F(u)\|_{D_F}$
      (only for \id{KIN\_INEXACT\_NEWTON}).
      
      $\|F(u)\|_{D_F,\infty}$
      (for \id{KIN\_INEXACT\_NEWTON} and
      \id{KIN\_LINESEARCH}).
      
    \item[3]
      display level 2 output plus additional
      values used by the global strategy
      (only if using \id{KIN\_LINESEARCH}), and
      statistical information for the linear
      solver.
    \end{itemize}

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{printfl} had an illegal value.
  \end{args}
}
{
  The default value for \id{printfl} is $0$.
}
%%
\ucfunction{KINSetFdata}
{
flag = KINSetFdata(kin\_mem, f\_data);
}
{
  The function \ID{KINSetFdata} specifies the pointer to user-defined memory
  that is to be passed to the user-supplied function implementing the nonlinear
  system residual.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[f\_data] (\id{void *})
    pointer to the user-defined memory.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{f\_data} is \id{NULL}.
}
%%
%%
\ucfunction{KINSetNumMaxIters}
{
flag = KINSetNumMaxIters(kin\_mem, mxiter);
}
{
  The function \ID{KINSetNumMaxIters} specifies the maximum number of 
  nonlinear iterations allowed.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[mxiter] (\id{long int})
    maximum number of nonlinear iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The maximum number of iterations was non-positive.
  \end{args}
}
{
  The default value for \id{mxiter} is \id{MXITER\_DEFAULT} $=200$.
}
%%
%%
\ucfunction{KINSetNoPrecInit}
{
flag = KINSetNoPrecInit(kin\_mem, noPrecInit);
}
{
  The function \ID{KINSetNoPrecInit} specifies whether an initial call
  to the preconditioner setup function should be made or not.
}
{
  \begin{args}[noPrecInit]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[noPrecInit] (\id{booleantype})
    flag controlling whether or not an initial call 
    to the preconditioner setup function is made.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{noPrecInit} is \id{FALSE}, meaning that an initial call
  to the preconditioner setup function will be made.
}
%%
%%
\ucfunction{KINSetMaxPrecCalls}
{
flag = KINSetMaxPrecCalls(kin\_mem, msbpre);
}
{
  The function \ID{KINSetMaxPrecCalls} specifies the maximum number of 
  nonlinear iterations that can be performed between calls to the 
  preconditioner setup function.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[msbpre] (\id{long int})
    maximum number of nonlinear iterations without a call
    to the preconditioner setup function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{msbpre} was negative.
  \end{args}
}
{
  The default value for \id{msbpre} is \id{MSBPRE} $=10$.
}
%%
%%
\ucfunction{KINSetEtaForm}
{
flag = KINSetEtaForm(kin\_mem, etachoice);
}
{
  The function \ID{KINSetEtaForm} specifies the method for computing
  the value of the $\eta$ coefficient used in the calculation of the
  linear solver convergence tolerance.
}
{
  \begin{args}[etachoice]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[etachoice] (\id{int})
    flag indicating the method for computing $\eta$. \id{etachoice} must be one
    of \Id{KIN\_ETACHOICE1}, \Id{KIN\_ETACHOICE2}, or \Id{KIN\_ETACONSTANT}
    (see Chapter \ref{s:math} for details).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{etachoice} had an illegal value.
  \end{args}
}
{
  The default value for \id{etachoice} is \id{KIN\_ETACHOICE1}.
}
%%
%%
\ucfunction{KINSetEtaConstValue}
{
flag = KINSetEtaConstValue(kin\_mem, eta);
}
{
  The function \ID{KINSetEtaConstValue} specifies the constant value
  for $\eta$ in the case \id{etachoice = KIN\_ETACONSTANT}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[eta] (\id{realtype})
    constant value for $\eta$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{eta} had an illegal value
  \end{args}
}
{
  The default value for \id{eta} is $0.1$.
  The valid values are $0.0 <$ \id{eta} $\le 1.0$.
}
%%
%%
\ucfunction{KINSetEtaParams}
{
flag = KINSetEtaParams(kin\_mem, egamma, ealpha);
}
{
  The function \ID{KINSetEtaParams} specifies the parameters $\gamma$ and
  $\alpha$ in the formula for $\eta$, in the case \id{etachoice = KIN\_ETACHOICE2}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[egamma] (\id{realtype})
    value of the $\gamma$ parameter.
  \item[ealpha] (\id{realtype})
    value of the $\alpha$ parameter.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional values have been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    One of the arguments \id{egamma} or \id{ealpha} had an illegal value.
  \end{args}
}
{
  The default values for \id{egamma} and \id{ealpha} are $0.9$ and $2.0$, respectively.

  The valid values for \id{ealpha} are $1.0<$ \id{ealpha} $\le 2.0$. 
  If \id{ealpha} $= 0.0$, then its value is set to $2.0$.

  The valid values for \id{egamma} are $0.0 <$ \id{egamma} $\le1.0$.
  If \id{egamma} $= 0.0$, then its value is set to $0.9$.
}
%%
%%
\ucfunction{KINSetNoMinEps}
{
flag = KINSetNoMinEps(kin\_mem, noMinEps);
}
{
  The function \ID{KINSetNoMinEps} specifies a flag that controls whether or not
  the value of $\epsilon$, the scaled linear residual tolerance, is
  bounded from below.
}
{
  \begin{args}[noMinEps]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[noMinEps] (\id{booleantype})
    flag controlling the bound on $\epsilon$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{noMinEps} is \id{FALSE}.
}
%%
%%
\ucfunction{KINSetMaxNewtonStep}
{
flag = KINSetMaxNewtonStep(kin\_mem, mxnewtstep);
}
{
  The function \ID{KINSetMaxNewtonStep} specifies the maximum allowable scaled
  length of the Newton step.
}
{
  \begin{args}[mxnewtstep]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[mxnewtstep] (\id{realtype})
    maximum scaled step length.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The maximum step was non-positive.
  \end{args}
}
{
  The default value of \id{mxnewtstep} is $1000\, \| u_0 \|_{D_u}$,
  where $u_0$ is the initial guess.
}
%%
%%
\ucfunction{KINSetRelErrFunc}
{
flag = KINSetRelErrFunc(kin\_mem, relfunc);
}
{
  The function \ID{KINSetRelErrFunc} specifies the relative error in 
  computing $F(u)$, which is used in the difference quotient approximation of the
  Jacobian-vector product.
}
{
  \begin{args}[relfunc]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[relfunc] (\id{realtype})
    relative error in $F(u)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The relative error was non-positive.
  \end{args}
}
{
  The default value for \id{relfunc} is $\sqrt{\text{unit roundoff}}$.
}
%%
%%
\ucfunction{KINSetFuncNormTol}
{
flag = KINSetFuncNormTol(kin\_mem, fnormtol);
}
{
  The function \ID{KINSetFuncNormTol} specifies the scalar used as a stopping
  tolerance on the scaled maximum norm of the system function $F(u)$.
}
{
  \begin{args}[fnormtol]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[fnormtol] (\id{realtype})
    tolerance for stopping based on scaled function norm.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The tolerance was non-positive.
  \end{args}
}
{
  The default value for \id{fnormtol} is $\sqrt[3]{\text{unit roundoff}}$.
}
%%
%%
\ucfunction{KINSetScaledStepTol}
{
flag = KINSetScaledStepTol(kin\_mem, scsteptol);
}
{
  The function \ID{KINSetScaledStepTol} specifies the scalar used
  as a stopping tolerance on the minimum scaled step length.
}
{
  \begin{args}[scsteptol]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[scsteptol] (\id{realtype})
    tolerance for stopping based on scaled step length.. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The tolerance was non-positive.
  \end{args}
}
{
  The default value for \id{scsteptol} is $(\text{unit roundoff})^{2/3}$.
}
%%
%%
\ucfunction{KINSetConstraints}
{
flag = KINSetConstraints(kin\_mem, constraints);
}
{
  The function \ID{KINSetConstraints} specifies a vector that defines
  inequality constraints for each component of the solution vector $u$.
}
{
  \begin{args}[constraints]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[constraints] (\id{N\_Vector})
    vector of constraint flags. If \id{constraints[i]} is
    \begin{itemize}    
    \item[$0.0$] then no constraint is imposed on $u_i$. 
    \item[$1.0$] then $u_i$ will be constrained to be $u_i > 0.0$.
    \item[$-1.0$] then $u_i$ will be constrained to be $u_i < 0.0$.
    \item[$2.0$] then $u_i$ will be constrained to be $u_i \ge 0.0$.
    \item[$-2.0$] then $u_i$ will be constrained to be $u_i \le 0.0$.
    \end{itemize}
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The constraint vector contains illegal values.
  \end{args}
}
{
  The presence of a non-\id{NULL} constraints vector that is not $0.0$ in
  all components will cause constraint checking to be performed.

  The function creates a private copy of the constraints vector. Consequently,
  the user-supplied vector can be freed after the function call, and
  the constraints can only be changed by calling this function.
}
%%
%%
\ucfunction{KINSetSysFunc}
{
flag = KINSetSysFunc(kin\_mem, func);
}
{
  The function \ID{KINSetSysFunc} specifies the user-provided function
  that evaluates the nonlinear system function $F(u)$.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[func] (\id{KINSysFn})
    user-supplied function that evaluates $F(u)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{func} was \id{NULL}.
  \end{args}
}
{
  The nonlinear system function is initially specified through \id{KINMalloc}.
  The option of changing the system function is provided for a user who wishes 
  to solve several problems of the same size but with different functions.
}
%%


%%===================================================================================
%%
\subsubsection{Linear solver optional input functions}
%%
The {\kinspgmr} linear solver module allows for various optional 
inputs, which are described here.
\index{optional input!iterative linear solver|(}
\index{KINSPGMR@{\kinspgmr} linear solver!optional input|(}
\index{preconditioning!user-supplied|(}
The call to \id{KINSpgmr} is used to communicate the maximum dimension of the
Krylov subspace to be used (\id{maxl}). 

If preconditioning is to be done within the {\spgmr} method,
then the user must supply a preconditioner solve function \id{psolve}
and specify it through a call to \id{KINSpgmrSetPrecSolveFn}.
\index{KINSPGMR@{\kinspgmr} linear solver!preconditioner solve function}
%%
The evaluation and preprocessing of any Jacobian-related data needed
by the user's preconditioner solve function is done in the optional
user-supplied function \id{psetup}. Both of these functions are
fully specified in \S\ref{ss:user_fct_sol}.
If used, the \id{psetup} function should be specified through a call to
\id{KINSpgmrSetPrecSetupFn}.
\index{KINSPGMR@{\kinspgmr} linear solver!preconditioner setup function}
%%
Optionally, the {\kinspgmr} solver passes the pointer it receives through 
\id{KINSpgmrSetPrecData} to the preconditioner setup and solve functions.  
This allows the user to create an arbitrary structure with relevant problem data 
and access it during the execution of the user-supplied preconditioner functions
without using global data in the program.  
The pointer \id{prec\_data} may be identical to \id{f\_data}, if the latter was 
specified through \id{KINSetFdata}.

The \index{KINSPGMR@{\kinspgmr} linear solver!Jacobian approximation used by}
{\kinspgmr} solver requires a function to compute an approximation to the
product between the Jacobian matrix $J(u)$ and a vector $v$.
The user can supply his/her own Jacobian-vector product approximation function, 
or use the difference quotient function \Id{KINSpgmrDQJtimes} 
\index{Jacobian-vector product approximation!difference quotient}
that comes with the {\kinspgmr} solver.
A user-defined Jacobian-vector function must be of type \id{KINSpgmrJtimesFn} and 
can be specified through a call to \id{KINSpgmrSetJacTimesVecFn} 
(see \S\ref{ss:user_fct_sol} for specification details).
%%
As with the preconditioner user data structure \id{prec\_data}, 
the user can specify, through a call to \id{KINSpgmrSetJacData}, a pointer to a 
user-defined data structure, \id{jac\_data}, which
the {\kinspgmr} solver passes to the Jacobian-vector product function \id{jtimes} each
time it is called.  
The pointer \id{jac\_data} may be identical to \id{prec\_data} and/or \id{f\_data}.
%%
%%
\ucfunction{KINSpgmrSetMaxRestarts}
{
  flag = KINSpgmrSetMaxRestarts(kin\_mem, maxrs);
}
{
  The function \ID{KINSpgmrSetMaxRestarts} specifies the maximum
  number of times the {\spgmr} linear solver can be restarted.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[maxrs] (\id{int})
    maximum number of restarts.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPGMR\_ILL\_INPUT]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KINSPGMR\_ILL\_INPUT}]
    The maximum number of restarts specified is negative.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpgmrSetPreconditioner}
{
  flag = KINSpgmrSetPreconditioner(kin\_mem, psetup, psolve, prec\_data);
}
{
  The function \ID{KINSpgmrSetPreconditioner} specifies the preconditioner
  setup and solve function and the pointer to user data.
}
{
  \begin{args}[prec\_data]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[psetup] (\id{KINSpgmrPrecSetupFn})
    user-defined preconditioner setup function.
  \item[psolve] (\id{KINSpgmrPrecSolveFn})
    user-defined preconditioner solve function.
  \item[prec\_data] (\id{void *})
     pointer to the user-defined data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{
   The function type \id{KINSpgmrPrecSetupFn} is described in \S\ref{ss:precondFn}.
   The function type \id{KINSpgmrPrecSolveFn} is described in \S\ref{ss:psolveFn}.
}
%%
%%
\index{preconditioning!user-supplied|)}
%%
\index{Jacobian-vector product approximation!user-supplied}
\ucfunction{KINSpgmrSetJacTimesVecFn}
{
  flag = KINSpgmrSetJacTimesVecFn(kin\_mem, jtimes, jac\_data);
}
{
  The function \ID{KINSpgmrSetJacTimesVecFn} specifies the Jacobian-vector 
  product function to be used and the pointer to user data.
}
{
  \begin{args}[jac\_data]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[jtimes] (\id{KINSpgmrJacTimesVecFn})
    user-defined Jacobian-vector product function.
  \item[jac\_data] (\id{void *})
     pointer to the user-defined data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{
  By default, {\kinspgmr} uses the difference quotient function \id{KINSpgmrDQJtimes}.
  If \id{NULL} is passed to \id{jtimes}, this default function is used.

  The function type \id{KINSpgmrJacTimesVecFn} is described in \S\ref{ss:jtimesFn}.
}
%%


%%==============================================================================
\subsection{Optional output functions}\label{ss:optional_output}
%%==============================================================================

{\kinsol} provides an extensive list of functions that can be used to obtain
solver performance information.
Table \ref{t:optional_output} lists all optional output functions in {\kinsol},
which are then described in detail in the remainder of this section.

\begin{table}
\centering
\caption{Optional outputs from KINSOL and KINSPGMR}
\label{t:optional_output}
\medskip
\begin{tabular}{|l|l|}\hline
{\bf Optional output} & {\bf Function name} \\
\hline
\multicolumn{2}{|c|}{\bf KINSOL main solver} \\
\hline
Size of {\kinsol} real and integer workspaces & \id{KINGetWorkSpace} \\
Number of function evaluations  & \id{KINGetNumFuncEvals} \\
Number of nonlinear iterations & \id{KINGetNumNolinSolvIters} \\
Number of $\beta$-condition failures & \id{KINGetNumBetaCondFails} \\
Number of backtrack operations & \id{KINGetNumBacktrackOps} \\
Scaled norm of $F$ & \id{KINGetFuncNorm} \\
Scaled norm of the step & \id{KINGetStepLength} \\
\hline
\multicolumn{2}{|c|}{\bf KINSPGMR linear solver} \\
\hline
Size of {\kinspgmr} real and integer workspaces & \id{KINSpgmrGetWorkSpace} \\
No. of linear iterations & \id{KINSpgmrGetNumLinIters} \\
No. of linear convergence failures & \id{KINSpgmrGetNumConvFails} \\
No. of preconditioner evaluations & \id{KINSpgmrGetNumPrecEvals} \\
No. of preconditioner solves & \id{KINSpgmrGetNumPrecSolves} \\
No. of Jacobian-vector product evaluations & \id{KINSpgmrGetNumJtimesEvals} \\
No. of fct. calls for finite diff. Jacobian-vector evals. & \id{KINSpgmrGetNumFuncEvals} \\ 
Last return from a {\kinspgmr} function & \id{KINSpgmrGetLastFlag} \\ 
\hline
\end{tabular}
\end{table}


%%==============================================================================
\subsubsection{Main solver optional output functions}
%%==============================================================================
\index{optional output!solver|(}
%%
{\kinsol} provides several user-callable functions that can be used to obtain
different quantities that may be of interest to the user, such as solver workspace
requirements and solver performance statistics.
These optional output functions are described next.
%%
\index{memory requirements!KINSOL@{\kinsol} solver}
%%
\ucfunction{KINGetWorkSpace}
{
  flag = KINGetWorkSpace(kin\_mem, \&lenrw, \&leniw);
}
{
  The function \ID{KINGetWorkSpace} returns the
  {\kinsol} integer and real workspace sizes.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lenrw] (\id{long int})
    the number of \id{realtype} values in the {\kinsol} workspace.
  \item[leniw] (\id{long int})
    the number of integer values in the {\kinsol} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output values have been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  In terms of the problem size $N$, the actual size of the real workspace 
  is $5 N$ \id{realtype} words.
}
%%
%%
\ucfunction{KINGetNumFuncEvals}
{
  flag = KINGetNumFuncEvals(kin\_mem, \&nfevals);
}
{
  The function \ID{KINGetNumFuncEvals} returns the number of evaluations
  of the system function.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nfevals] (\id{long int})
    number of calls to the user-supplied function that evaluates $F(u)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetNumNonlinSolvIters}
{
  flag = KINGetNumNonlinSolvIters(kin\_mem, \&nniters);
}
{
  The function \ID{KINGetNumNonlinSolvIters} returns the number
  of nonlinear iterations.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nniters] (\id{long int})
    number of nonlinear iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetNumBetaCondFails}
{
  flag = KINGetNumBetaCondFails(kin\_mem, \&nbcfails);
}
{
  The function \ID{KINGetNumBetaCondFails} returns the number
  of $\beta$-condition failures.
}
{
  \begin{args}[nbcfails]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nbcfails] (\id{long int})
    number of $\beta$-condition failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetNumBacktrackOps}
{
  flag = KINGetNumBacktrackOps(kin\_mem, \&nbacktr);
}
{
  The function \ID{KINGetNumBacktrackOps} returns the number of
  backtrack operations (step length adjustments) performed by the
  line search algorithm.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nbacktr] (\id{long int})
    number of backtrack operations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetFuncNorm}
{
  flag = KINGetFuncNorm(kin\_mem, \&fnorm);
}
{
  The function \ID{KINGetFuncNorm} returns the scaled Euclidean $\ell_2$ norm of the 
  nonlinear system function $F(u)$ evaluated at the current iterate.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[fnorm] (\id{realtype})
    current scaled norm of $F(u)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetStepLength}
{
  flag = KINGetStepLength(kin\_mem, \&steplength);
}
{
  The function \ID{KINGetStepLength} returns the scaled Euclidean $\ell_2$ norm of
  the step used during the previous iteration.
}
{
  \begin{args}[steplength]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[steplength] (\id{realtype})
    scaled norm of the Newton step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
%%==============================================================================
\subsubsection{Linear solver optional output functions}\label{sss:linsolv_io}
%%==============================================================================
The functions available to access various optional outputs that describe the 
performance of the {\kinspgmr} module are described below.

%\noindent{\bf SPGMR Linear solver.}
\index{optional output!iterative linear solver|(}
\index{KINSPGMR@{\kinspgmr} linear solver!optional output|(} 
%%
\index{KINSPGMR@{\kinspgmr} linear solver!memory requirements|(} 
\index{memory requirements!KINSPGMR@{\kinspgmr} linear solver|(}
%%
\ucfunction{KINSpgmrGetWorkSpace}
{
  flag = KINSpgmrGetWorkSpace(kin\_mem, \&lenrwSG, \&leniwSG);
}
{
  The function \ID{KINSpgmrGetWorkSpace} returns the
  real and integer workspace sizes used by {\kinspgmr}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lenrwSG] (\id{long int})
    the number of \id{realtype} values in the {\kinspgmr} workspace.
  \item[leniwSG] (\id{long int})
    the number of integer values in the {\kinspgmr} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output values have been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{
  In terms of the problem size $N$ and maximum subspace size \id{maxl}, 
  the actual size of the real workspace is
  (\id{maxl}$+ 5)*N +$ \id{maxl} $*($ \id{maxl}$ + 4) + 1$ \id{realtype}
  words.  (In a parallel setting, this value is global - summed over
  all processes.)
}
%%
\index{KINSPGMR@{\kinspgmr} linear solver!memory requirements|)} 
\index{memory requirements!KINSPGMR@{\kinspgmr} linear solver|)}
%%
%%
\ucfunction{KINSpgmrGetNumLinIters}
{
  flag = KINSpgmrGetNumLinIters(kin\_mem, \&nliters);
}
{
  The function \ID{KINSpgmrGetNumLinIters} returns the
  cumulative number of linear iterations.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nliters] (\id{long int})
    the current number of linear iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpgmrGetNumConvFails}
{
  flag = KINSpgmrGetNumConvFails(kin\_mem, \&nlcfails);
}
{
  The function \ID{KINSpgmrGetNumConvFails} returns the
  cumulative number of linear convergence failures.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nlcfails] (\id{long int})
    the current number of linear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpgmrGetNumPrecEvals}
{
  flag = KINSpgmrGetNumPrecEvals(kin\_mem, \&npevals);
}
{
  The function \ID{KINSpgmrGetNumPrecEvals} returns the
  number of preconditioner evaluations, i.e., the number of 
  calls made to \id{psetup}.
%  calls made to \id{psetup} with \id{jok=FALSE}. 
%% D.R.R. -- there's no 'jok' in psetup anymore
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[npevals] (\id{long int})
    the current number of calls to \id{psetup}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpgmrGetNumPrecSolves}
{
  flag = KINSpgmrGetNumPrecSolves(kin\_mem, \&npsolves);
}
{
  The function \ID{KINSpgmrGetNumPrecSolves} returns the
  cumulative number of calls made to the preconditioner 
  solve function, \id{psolve}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[npsolves] (\id{long int})
    the current number of calls to \id{psolve}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpgmrGetNumJtimesEvals}
{
  flag = KINSpgmrGetNumJtimesEvals(kin\_mem, \&njvevals);
}
{
  The function \ID{KINSpgmrGetNumJtimesEvals} returns the
  cumulative number made to the Jacobian-vector product function,
  \id{jtimes}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[njvevals] (\id{long int})
    the current number of calls to \id{jtimes}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpgmrGetNumRhsEvals}
{
  flag = KINSpgmrGetNumRhsEvals(kin\_mem, \&nfevalsSG);
}
{
  The function \ID{KINSpgmrGetNumRhsEvals} returns the
  number of calls to the user right-hand side function for
  finite difference Jacobian-vector product approximations.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nfevalsSG] (\id{long int})
    the number of calls to the user right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{
  The value \id{nfevalsSG} is incremented only if the default 
  \id{KINSpgmrDQJtimes} difference quotient function is used.
}
%%
%%
\ucfunction{KINSpgmrGetLastFlag}
{
  flag = KINSpgmrGetLastFlag(kin\_mem, \&flag);
}
{
  The function \ID{KINSpgmrGetLastFlag} returns the
  last return value from a {\kinspgmr} routine. 
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[flag] (\id{int})
    the value of the last return flag from a {\kinspgmr} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{
  If the {\kinspgmr} setup function failed (\id{KINSOL} returned
  \id{KIN\_LSETUP\_FAIL}), \id{flag} contains the return value of the
  preconditioner setup function \id{psetup}.

  If the {\kinspgmr} solve function failed (\id{KINSOL} returned
  \id{KIN\_LSOLVE\_FAIL}), \id{flag} contains the error return flag from
  \id{SpgmrSolve} and will be one of:
 \id{SPGMR\_CONV\_FAIL}, indicating a failure to converge;
 \id{SPGMR\_QRFACT\_FAIL}, indicating a singular matrix found during the QR
  factorization;
 \id{SPGMR\_PSOLVE\_FAIL\_REC}, indicating that the preconditioner solve function
 \id{psolve} failed recoverably;
  \id{SPGMR\_MEM\_NULL}, indicating that the {\spgmr} memory is \id{NULL};
  \id{SPGMR\_ATIMES\_FAIL}, indicating a failure in the Jacobian-vector product
  function;
  \id{SPGMR\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
  function \id{psolve} failed unrecoverably;
  \id{SPGMR\_GS\_FAIL}, indicating a failure in the Gram-Schmidt procedure; 
  or \id{SPGMR\_QRSOL\_FAIL}, indicating that the matrix $R$ was found to be
  singular during the QR solve phase.
}
%%
%%
\index{KINSPGMR@{\kinspgmr} linear solver!optional output|)} 
\index{optional output!iterative linear solver|)}

%%==============================================================================
\section{User-supplied functions}\label{ss:user_fct_sol}
%%==============================================================================

The user-supplied functions consist of one function defining the nonlinear system, 
(optionally) a function that provides Jacobian-related information for the linear
solver, and (optionally) one or two functions that define the preconditioner for 
use in the {\spgmr} algorithm. 

%%==============================================================================
\subsection{Problem-defining function} \label{ss:sysFn}
%%==============================================================================
\index{problem-defining function}

The user must provide a function of type \ID{KINSysFn} defined as follows:
\usfunction{KINSysFn}
{
  typedef void (*KINSysFn)(N\_Vector u, N\_Vector fval, void *f\_data );
}
{
  This function computes $F(u)$ for a given value of the vector $u$.
}
{
  \begin{args}[f\_data]
  \item[u]
    is the current value of the variable vector, $u$.
  \item[fval]
    is the output vector $F(u)$.
  \item[f\_data]
    is a pointer to user data, same as the pointer \Id{f\_data}      
    passed to \id{KINSetFdata}.   
  \end{args}
}
{
  A \id{KINSysFn} function type does not have a return value.
}
{
Allocation of memory for \id{fval} is handled within {\kinsol}.
}



%%==============================================================================
\subsection{Jacobian information (SPGMR matrix-vector product)}
\label{ss:jtimesFn}
%%==============================================================================
\index{Jacobian-vector product approximation!user-supplied}
The user may provide a function of type \ID{KINSpgmrJacTimesVecFn} to evaluate
Jacobian-vector products for the {\kinspgmr} linear solver module.
This function has the following form:
\usfunction{KINSpgmrJacTimesVecFn}
{
typedef int (*KINSpgmrJacTimesVecFn)(&N\_Vector v, N\_Vector Jv, \\
                                     &N\_Vector u, booleantype *new\_u, \\
                                     &void *jac\_data);
}
{
  This function computes the product $J v = (\partial F / \partial u) v$ 
  (or an approximation to it).
}
{
  \begin{args}[jac\_data]
  \item[v]
    is the vector by which the Jacobian must be multiplied to the right.
  \item[Jv]
      is the output vector computed.
  \item[u] 
    is the current (unscaled) value of the iterate.
  \item[new\_u]
    is a flag (reset by user) indicating if the iterate \id{u}
    has been updated in the interim. The Jacobian-vector product 
    needs to be updated/reevaluated, if appropriate, unless
    \id{new\_u = FALSE}.
  \item[jac\_data]
    is a pointer to user data, the same as the \id{jac\_data}      
    parameter passed to \id{KINSpgmrSetJacData}.   
  \end{args}
}
{  
  The value to be returned by the Jacobian-vector product function should be
  $0$ if successful. Any other return value will result in an unrecoverable
  error of the {\spgmr} generic solver, in which case the solution process
  is halted.
}
{
  If a user-defined routine is not given, then an internal
  {\kinspgmr} function, using difference quotient approximations,
  is used.

  If the user-provided \id{KINSpgmrJacTimesVec} function needs the unit roundoff,
  this can be accessed as \id{UNIT\_ROUNDOFF} defined in \id{sundialstypes.h}.

  {\warn} The user is responsible for resetting the value of \id{new\_u} to \id{FALSE}.
}
%%

%%==============================================================================
\subsection{Preconditioning (SPGMR linear system solution)} \label{ss:psolveFn}
%%==============================================================================
\index{preconditioning!user-supplied}
\index{KINSPGMR@{\kinspgmr} linear solver!preconditioner solve function}

If preconditioning is used, then the user must provide a {\C} function to
solve the linear system $Pz = r$ where $P$ is the preconditioner matrix.
This function must be of type \ID{KINSpgmrPrecSolveFn}, defined as follows:
%%
%%
\usfunction{KINSpgmrPrecSolveFn}
{
typedef int (*KINSpgmrPrecSolveFn)(&N\_Vector u, N\_Vector uscale,  \\
                                   &N\_Vector fval, N\_Vector fscale,  \\
                                   &N\_Vector v, void *prec\_data, \\
                                   &N\_Vector tmp);
}
{
  This function solves the preconditioning system $Pz = r$.
}
{  
  \begin{args}[prec\_data]
  \item[u] 
    is the current (unscaled) value of the iterate.
  \item[uscale]
    is a vector containing diagonal elements
    of the scaling matrix for \id{u}.
  \item[fval]
    is the vector $F(u)$ evaluated at \id{u}.
  \item[fscale]
    is a vector containing diagonal elements
    of the scaling matrix for \id{fval}.
  \item[v]
    on input, \id{v} is set to the right-hand side vector of the linear 
    system, \id{r}. On output, \id{v} must contain the solution \id{z} of
    the linear system $Pz=r$.
  \item[prec\_data]
    is a pointer to user data - the same as the \id{prec\_data}      
    parameter passed to the function \id{KINSpgmrSetPrecData}.
  \item[tmp]
    is a pointer to memory allocated for a variable of type \id{N\_Vector}
    which can be used for work space.
  \end{args}
}
{
  The value to be returned by the preconditioner solve function is a flag
  indicating whether it was successful.  This value should be $0$ if successful, 
  positive for a recoverable error, and negative for an unrecoverable error.
}
{}

%%==============================================================================
\subsection{Preconditioning (SPGMR Jacobian data)}\label{ss:precondFn}
%%==============================================================================
\index{preconditioning!user-supplied}
\index{KINSPGMR@{\kinspgmr} linear solver!preconditioner setup function}

If the user's preconditioner requires that any Jacobian-related data
be evaluated or preprocessed, then this needs to be done in a
user-supplied {\C} function of type \ID{KINSpgmrPrecSetupFn}, defined as follows:
\usfunction{KINSpgmrPrecSetupFn}
{
typedef int (*KINSpgmrPrecSetupFn)(&N\_Vector u, N\_Vector uscale, \\
                                   &N\_Vector fval, N\_Vector fscale,\\
                                   &void *prec\_data, N\_Vector tmp1,\\
                                   &N\_Vector tmp2);
}
{
  This function evaluates and/or preprocesses Jacobian-related data needed
  by the preconditioner.
}
{
  The arguments of a \id{KINSpgmrPrecSetupFn} are as follows:
  \begin{args}[prec\_data]
  \item[u] 
    is the current (unscaled) value of the iterate.
  \item[uscale]
    is a vector containing diagonal elements
    of the scaling matrix for \id{u}.
  \item[fval]
    is the vector $F(u)$ evaluated at \id{u}.
  \item[fscale]
    is a vector containing diagonal elements
    of the scaling matrix for \id{fval}.
  \item[prec\_data]
    is a pointer to user data - the same as the \id{prec\_data}      
    parameter passed to the function \id{KINSpgmrSetPrecData}.
  \item[tmp1]
  \item[tmp2]
    are pointers to memory allocated for variables of type \id{N\_Vector}
    which can be used by \id{KINSpgmrPrecSetupFn} as temporary storage or 
    work space.    
  \end{args}
}
{
  The value to be returned by the preconditioner setup function is a flag
  indicating whether it was successful.  This value should be $0$ if successful, 
  positive for a recoverable error, and negative for an unrecoverable error.
}
{
  The user-supplied preconditioner setup subroutine should
  compute the right preconditioner matrix $P$ (stored in the memory
  block referenced by the \id{prec\_data} pointer) used to form the
  scaled preconditioned linear system
 
   $$(D_F J(u) P^{-1} D_u^{-1}) \cdot (D_u P x) = - D_F F(u) \, ,$$
 
  where $D_u$ and $D_F$ denote the diagonal scaling matrices whose
  diagonal elements are stored in the vectors \id{uscale} and
  \id{fscale}, respectively.
 
  The preconditioner setup routine will not be called prior
  to every call made to the preconditioner solve function, but will instead be
  called only as often as necessary to achieve convergence of the
  Newton iteration.
 
  If the preconditioner solve routine requires no preparation, then a
  preconditioner setup function need not be given.
}

%%==============================================================================
\section{A parallel band-block-diagonal preconditioner module}
\label{sss:kinbbdpre}
%%==============================================================================
The efficiency of Krylov iterative methods for the solution of linear systems 
can be greatly enhanced through preconditioning. For problems in which the 
user cannot define a more effective, problem-specific preconditioner,
{\kinsol} provides a band-block-diagonal preconditioner module {\kinbbdpre}, 
to be used with the parallel \id{N\_Vector} module described in \S\ref{ss:nvec_par}.

This module provides a preconditioner matrix for {\kinsol} that
is block-diagonal with banded blocks. The blocking corresponds
to the distribution of the dependent variable vector $u$ amongst
the processes. Each preconditioner block is generated from
the Jacobian of the local part (associated with the current
process) of a given function $G(u)$ approximating $F(u)$
($G = F$ is allowed). The blocks are generated by each process via a
difference quotient scheme, utilizing a specified banded structure.
This structure is given by upper and lower half-bandwidths, \id{mu}
and \id{ml}, defined as the number of non-zero diagonals above and
below the main diagonal, respectively.

This pair of parameters need not be the true half-bandwidths of the Jacobian
of the local block of $G$, if smaller values provide a more efficient
preconditioner.  Such an efficiency gain may occur if the couplings
in the system outside a certain bandwidth are considerably weaker than
those within the band.  Reducing \id{mu} and \id{ml} lumps the outer
Jacobian elements into the computed elements within the narrower band.
This loss of accuracy in the Jacobian may (or may not) be offset by
the lower cost of the narrower band matrices, so users should experiment
with the values of \id{mu} and \id{ml}.

\index{KINBBDPRE@{\kinbbdpre} preconditioner!user-supplied functions|(}
The {\kinbbdpre} module calls two user-provided functions to construct $P$: 
a required function \id{Gloc} (of type \id{KINLocalFn}) which
approximates the nonlinear system function function $G(u) \approx F(u)$ and which 
is computed locally, and an optional function \id{Gcomm} (of type \id{KINCommFn}) 
which performs all interprocess communication necessary to evaluate 
the approximate function $G$.  
These are in addition to the user-supplied nonlinear system function that 
evaluates $F(u)$.
Both functions take as input the same pointer \id{f\_data} as that passed
by the user to \id{KINSetFdata} and passed to the user's function \id{func},
and neither function has a return value. The user is responsible for
providing space (presumably within \id{f\_data}) for components of \id{u}
that are communicated by \id{Gcomm} from the other processes, and that are
then used by \id{Gloc}, which is not expected to do any communication.
%%
%%
\usfunction{KINLocalFn}
{
  typedef void (*KINLocalFn)(&long int Nlocal, N\_Vector u, \\
                             &N\_Vector gval, void *f\_data);
}
{
  This function computes $G($\id{u}$)$, and outputs the resulting
  vector as \id{gval}.
}
{
  \begin{args}[Nlocal]
  \item[Nlocal] 
    is the local vector length.
  \item[u]
    is the current value of the iterate.
  \item[gval]
    is the output vector.
  \item[f\_data]
    is a pointer to user data - the same as the \Id{f\_data}      
    parameter passed to \id{KINSetFdata}.  
  \end{args}
}
{
  A \id{KINLocalFn} function type does not have a return value.
}
{
  This function assumes that all interprocess communication of data needed to 
  calculate \id{gval} has already been done, and this data is accessible within
  \id{f\_data}.

   Memory for \id{u} and \id{gval} is handled within the preconditioner module.

  The case where $G$ is mathematically identical to $F$ is allowed.
}
%%
%%
\usfunction{KINCommFn}
{
  typedef void (*KINCommFn)(long int Nlocal, N\_Vector u, void *f\_data);
}
{
  This function performs all interprocess communications necessary 
  for the execution of the \id{gloc} function above, using the input vector \id{u}.
}
{
  \begin{args}[Nlocal]
  \item[Nlocal] 
    is the local vector length.
  \item[u]
    is the current value of the iterate.
  \item[f\_data]
    is a pointer to user data - the same as the \Id{f\_data}      
    parameter passed to \id{KINSetFdata}.  
  \end{args}
}
{
  A \id{KINCommFn} function type does not have a return value.
}
{
  The \id{Gcomm} function is expected to save communicated data in space defined
  within the structure \id{f\_data}. 

  Each call to the \id{Gcomm} function is preceded by a call to the system function
  \id{func} with the same \id{u} argument.  Thus \id{Gcomm} can omit 
  any communications done by \id{func} if relevant to the evaluation of \id{Gloc}.
  If all necessary communication was done in \id{func}, then \id{Gcomm = NULL}
  can be passed in the call to \id{KINBBDPrecAlloc} (see below).
}
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!user-supplied functions|)}

%%
%% ----------------------------------------
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!usage|(}
%%
Besides the header files required for the solution of a nonlinear problem
(see \S\ref{s:header_sol}),  to use the {\kinbbdpre} module, the main program 
must include the header file \id{kinbbdpre.h} which declares the needed
function prototypes.\index{header files}

The following is a summary of the usage of this module and describes the sequence
of calls in the user main program. Steps that are unchanged from the user main
program presented in \S\ref{s:skeleton_sol} are grayed out.
%%
%%
\index{User main program!KINBBDPRE@{\kinbbdpre} usage}
\begin{Steps}
\item 
  \textcolor{gray}{\bf Initialize MPI}

\item
  \textcolor{gray}{\bf Set problem dimensions}

\item
  \textcolor{gray}{\bf Set vector with initial guess}
 
\item
  \textcolor{gray}{\bf Create {\kinsol} object}

\item
  \textcolor{gray}{\bf Set optional inputs}

\item
  \textcolor{gray}{\bf Allocate internal memory}

\item \label{i:bbdpre_init}
  {\bf Initialize the {\kinbbdpre} preconditioner module}

  Specify the upper and lower half-bandwidths \id{mu}, \id{ml} and call

   \id{
     \begin{tabular}[t]{@{}r@{}l@{}}
       bbd\_data = KINBBDPrecAlloc(&kin\_mem, Nlocal, mu, ml, \\
                                   &dq\_rel\_u, Gloc, Gcomm);
     \end{tabular}
   }

  to allocate memory for and initialize a data structure \id{bbd\_data} to be 
  passed to the {\kinspgmr} linear solver. The last two arguments of
  \id{KINBBDPrecAlloc} are the two user-supplied functions described above.

\item \label{i:bbdpre_attach}
  {\bf Attach the {\kinspgmr} linear solver}

  \id{flag = KINBBDSpgmr(kin\_mem, maxl, bbd\_data);}

  The function \Id{KINBBDSpgmr} is a wrapper around the {\kinspgmr} specification
  function \id{KINSpgmr} and performs the following actions:
  \begin{itemize}
    \item Attaches the {\kinspgmr} linear solver to the main {\cvode} solver memory;
    \item Sets the preconditioner data structure for {\kinbbdpre};
    \item Sets the preconditioner setup function for {\kinbbdpre};
    \item Sets the preconditioner solve function for {\kinbbdpre};
  \end{itemize}
  The argument \id{maxl} is described below.
  The last argument of \id{KINBBDSpgmr} is the pointer to the {\kinbbdpre} data
  returned by \id{KINBBDPrecAlloc}.

\item
  \textcolor{gray}{\bf Set linear solver optional inputs}

  Note that the user should not overwrite the preconditioner data, setup function,
  or solve function through calls to {\kinspgmr} optional input functions.

\item
  \textcolor{gray}{\bf Solve problem}

\item
  \textcolor{gray}{\bf Get optional output}

\item
  \textcolor{gray}{\bf Deallocate memory for solution vector}

\item \label{i:bbdpre_free}
  {\bf Free the {\kinbbdpre} data structure}

  \id{KINBBDPrecFree(bbd\_data);}

\item
  \textcolor{gray}{\bf Free solver memory}
  
\item 
  \textcolor{gray}{\bf Finalize MPI}

\end{Steps}
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!usage|)}

%%
%% ----------------------------------------
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!user-callable functions|(}
%%
The three user-callable functions that initialize, attach, and deallocate
the {\kinbbdpre} preconditioner module (steps \ref{i:bbdpre_init},
\ref{i:bbdpre_attach}, and \ref{i:bbdpre_free} above) are described
next.
%%
\index{half-bandwidths}
\ucfunction{KINBBDPrecAlloc}
{
   \begin{tabular}[t]{@{}r@{}l@{}}
     bbd\_data = KINBBDPrecAlloc(&kin\_mem, Nlocal, mu, ml, \\
                                 &dq\_rel\_u, Gloc, Gcomm);
   \end{tabular}
}
{
  The function \ID{KINBBDPrecAlloc} initializes and allocates
  memory for the {\kinbbdpre} preconditioner.
}
{
  \begin{args}[dq\_rel\_u]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[Nlocal] (\id{long int})
    local vector length.
  \item[mu] (\id{long int})
    upper half-bandwidth to be used in the difference quotient Jacobian approximation.
  \item[ml] (\id{long int})
    lower half-bandwidth to be used in the difference quotient Jacobian approximation.
  \item[dq\_rel\_u] (\id{realtype})
    the relative increment in components of \id{u} used in the difference quotient
    approximations.  The default is \id{dq\_rel\_u}$ = \sqrt{\text{unit roundoff}}$,
    which can be specified by passing \id{dq\_rel\_u}$ = 0.0$.
  \item[Gloc] (\id{KINLocalFn})
    the {\C} function which computes the approximation $G(u) \approx F(u)$. 
  \item[Gcomm] (\id{KINCommFn})
    the optional {\C} function which performs all interprocess communication required for
    the computation of $G(u)$.
  \end{args}
}
{
  If successful, \id{KINBBDPrecAlloc} returns a pointer to the newly created 
  {\kinbbdpre} memory block (of type \id{void *}).
  If an error occurred, \id{KINBBDPrecAlloc} returns \id{NULL}.
}
{
  The half-bandwidths \id{mu} and \id{ml} need not be the true 
  half-bandwidths of the Jacobian of the local block of $G$,    
  when smaller values may provide a greater efficiency.       

  Moreover, the half-bandwidth values need not be the same for every process.
}
%%
%%
\ucfunction{KINBBDSpgmr}
{
  flag = KINBBDSpgmr(kin\_mem, maxl, bbd\_data);
}
{
  The function \ID{KINBBDSpgmr} links the {\kinbbdpre} data to the
  {\kinspgmr} linear solver and attaches the latter to the {\kinsol}
  memory block.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[maxl] (\id{int})
    \index{maxl@\texttt{maxl}}
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{KINSPGMR\_MAXL}$=5$.
  \item[bbd\_data] (\id{void *})
    pointer to the {\kinbbdpre} data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPGMR\_ILL\_INPUT]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The {\kinspgmr} initialization was successful.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_ILL\_INPUT}]
    The {\nvector} module used does not implement a required operation.
  \item[\Id{KINSPGMR\_MEM\_FAIL}]
    A memory allocation request failed.
  \item[\Id{KIN\_PDATA\_NULL}]
    The {\kinbbdpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
\ucfunction{KINBBDPrecFree}
{
  KINBBDPrecFree(bbd\_data);
}
{
  The function \ID{KINBBDPrecFree} frees the pointer allocated by
  \id{KINBBDPrecAlloc}.
}
{
  The only argument of \id{KINBBDPrecFree} is the pointer to the {\kinbbdpre} 
  data structure (of type \id{void *}).
}
{
  The function \id{KINBBDPrecFree} has no return value.
}
{}
%%
%%-------------
%%
\index{optional output!band-block-diagonal preconditioner|(}
\index{KINBBDPRE@{\kinbbdpre} preconditioner!optional output|(}
The following two optional output functions are available for use with
the {\kinbbdpre} module:
%%
\index{memory requirements!KINBBDPRE@{\kinbbdpre} preconditioner}
\ucfunction{KINBBDPrecGetWorkSpace}
{
  flag = KINBBDPrecGetWorkSpace(bbd\_data, \&lenrwBBDP, \&leniwBBDP);
}
{
  The function \ID{KINBBDPrecGetWorkSpace} returns the local
  {\kinbbdpre} real and integer workspace sizes.
}
{
  \begin{args}[lenrwBBDP]
  \item[bbd\_data] (\id{void *})
    pointer to the {\kinbbdpre} data structure.
  \item[lenrwBBDP] (\id{long int})
    local number of \id{realtype} values in the {\kinbbdpre} workspace.
  \item[leniwBBDP] (\id{long int})
    local number of integer values in the {\kinbbdpre} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_PDATA\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output values have been successfully set.
  \item[\Id{KIN\_PDATA\_NULL}]
    The {\kinbbdpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINBBDPrecGetNumGfnEvals}
{
  flag = KINBBDPrecGetNumGfnEvals(bbd\_data, \&ngevalsBBDP);
}
{
  The function \ID{KINBBDPrecGetNumGfnEvals} returns the
  number of calls to the user \id{Gloc} function due to the 
  finite difference approximation of the Jacobian blocks used within
  {\kinbbdpre}'s preconditioner setup function.
}
{
  \begin{args}[ngevalsBBDP]
  \item[bbd\_data] (\id{void *})
    pointer to the {\kinbbdpre} data structure.
  \item[ngevalsBBDP] (\id{long int})
    the number of calls to the user \id{Gloc} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_PDATA\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_PDATA\_NULL}]
    The {\kinbbdpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!optional output|)}
\index{optional output!band-block-diagonal preconditioner|)}


%%==============================================================================
\section{FKINSOL, a {\F}-{\C} interface module}\label{ss:fcmix}
%%==============================================================================

The {\fkinsol} interface module is a package of {\C} functions which support
the use of the {\kinsol} solver, for the solution nonlinear systems
$F(u)=0$, in a mixed {\F}/{\C} setting.  While {\kinsol} is written
in {\C}, it is assumed here that the user's calling program and
user-supplied problem-defining routines are written in {\F}.
This package provides the necessary interface to {\kinsol} for both the
serial and the parallel {\nvector} implementations, and may also be
used with user-supplied mixed {\F}/{\C} {\nvector} implementations.

%%==============================================================================
\subsection{FKINSOL routines}
%%==============================================================================

\index{FKINSOL@{\fkinsol} interface module!user-callable functions|(}
The user-callable functions, with the corresponding {\kinsol} functions,
are as follows:
\begin{itemize}

\item Interface to the {\nvector} modules

  \begin{itemize}
  \item \id{FNVINITS} (defined by {\nvecs}) 
    interfaces to \id{NV\_New\_Serial}.
  \item \id{FNVINITP} (defined by {\nvecp}) 
    interfaces to \id{NV\_New\_Parallel}.
  \item \id{FNVFREES} (defined by {\nvecs})
    interface to \id{NV\_Destroy\_Serial}.
  \item \id{FNVFREEP}  (defined by {\nvecp})
    interfaces to \id{NV\_Destroy\_Parallel}.
  \end{itemize}

\item Interface to the main {\kinsol} module

  \begin{itemize}
  \item \id{FKINMALLOC}
    interfaces to \id{KINCreate}, \id{KINSet*} functions, and \id{KINMalloc}.
  \item \id{FKINSOL}
    interfaces to \id{KINSol}, \id{KINGet*} functions, and to the optional
    output functions for the {\kinspgmr} linear solver module.
  \item \id{FKINFREE}    
    interfaces to \id{KINFree}.
  \end{itemize}  

\item Interface to the {\kinspgmr} solver module

  \begin{itemize}
  \item \id{FKINSPGMR}
    interfaces to \id{KINSpgmr} and {\spgmr} optional input functions.
  \item \id{FKINSPGMRSETJAC}
   interfaces to \id{KINSpgmrSetJacTimesVecFn}.
 \item \id{FKINSPGMRSETPREC}
   interfaces to \id{KINSpgmrSetPrecSetupFn} and \id{KINSpgmrSetPrecSolveFn}.
 \end{itemize}

\end{itemize}
\index{FKINSOL@{\fkinsol} interface module!user-callable functions|)}

\index{FKINSOL@{\fkinsol} interface module!user-supplied functions}
The user-supplied functions, each listed with the corresponding interface
function which calls it (and its type within {\kinsol}), are as follows:
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\fkinsol} routine ({\F})  &  {\kinsol} function ({\C}) & {\kinsol} function type \\\hline
\id{FKFUN}    & \id{FKINfunc}     & \id{KINSysFn} \\
\id{FKPSOL}   & \id{FKINPSol}     & \id{KINSpgmrPrecSolveFn} \\
\id{FKPSET}   & \id{FKINPSet}     & \id{KINSpgmrPrecSetupFn} \\
\id{FKJTIMES} & \id{FKINJtimes}   & \id{KINSpgmrJacTimesVecFn} \\\hline
\end{tabular}
\end{center}
In contrast to the case of direct use of {\kinsol}, the names of all 
user-supplied routines here are fixed, in order to maximize portability 
for the resulting mixed-language program.


%%==============================================================================
\subsubsection{Important note on portability}
%%==============================================================================
\index{portability!{\F}}

In this package, the names of the interface functions, and the names of
the {\F} user routines called by them, appear as dummy names
which are mapped to actual values by a series of definitions in the
header files \id{fkinsol.h} and \id{fkinbbd.h}.
By default, those mapping definitions depend in turn on the {\C} macro
\id{F77\_FUNC} defined in the header file \id{config.h} by \id{configure}. However,
the set of flags - \Id{SUNDIALS\_CASE\_UPPER}, \Id{SUNDIALS\_CASE\_LOWER},
\Id{SUNDIALS\_UNDERSCORE\_NONE}, \Id{SUNDIALS\_UNDERSCORE\_ONE}, and
\Id{SUNDIALS\_UNDERSCORE\_TWO} can be explicitly defined in \id{config.h} when
configuring {\sundials} via the \id{--with-f77underscore} and
\id{--with-f77case} options to override the default behavior if necessary
(see Chapter \ref{s:install}). Either way, the names into which the dummy names
are mapped are in upper or lower case and have up to two underscores appended.

The user must also ensure that variables in the user {\F} code are
declared in a manner consistent with their counterparts in {\kinsol}.
All real variables must be declared as \id{REAL}, \id{DOUBLE PRECISION},
or perhaps as \id{REAL*}{\em n}, where {\em n} denotes the number of bytes,
depending on whether {\kinsol} was built in single, double or extended precision 
(see Chapter \ref{s:install}). Moreover, some of the {\F} integer variables
must be declared as \id{INTEGER*4} or \id{INTEGER*8} according to the 
{\C} type \id{long int}. These integer variables include: the array
of integer optional inputs and outputs (\id{IOPT}), problem dimensions (\id{NEQ},
\id{NLOCAL}, \id{NGLOBAL}), and Jacobian half-bandwidths (\id{MU} and \id{ML}).
This is particularly important when using
{\kinsol} and the {\fkinsol} package on 64-bit architectures.



%%==============================================================================
\subsection{FKINSOL optional input and output}
%%==============================================================================
\index{FKINSOL@{\fkinsol} interface module!optional input and output}
\index{optional input!FKINSOL@{\fkinsol}}
\index{optional output!FKINSOL@{\fkinsol}}
In order to keep the number of user-callable {\fkinsol} interface routines to
a minimum, optional inputs and outputs to the {\kinsol} solver and to related 
modules are not accessed through individual functions, but rather through a
pair of arrays, \Id{IOPT} of integer type and \Id{ROPT} of real type.
Table \ref{t:fkinsol_io} lists the entries in these two arrays and specifies the
{\fkinsol} user-callable routine which sets/accesses the corresponding optional
variable, as well as the {\kinsol} optional function which is actually called.
For more details on the optional inputs and outputs, see \S\ref{ss:optional_input}
and \S\ref{ss:optional_output}.

\begin{table}
\centering
\caption{Description of the FKINSOL optional input-output arrays \Id{IOPT} and \Id{ROPT}}
\label{t:fkinsol_io}
\medskip
\begin{tabular}{|r|c|c|l|}
\multicolumn{4}{c}{Integer input-output array \id{IOPT}}\\
\hline
{\bf Index} & {\bf Optional input} & {\bf Optional output} & {\kinsol} {\bf function} \\ 
\hline
\multicolumn{4}{|c|}{{\kinsol} main solver}\\
\hline
%
1  & \id{PRINTFL}           &             & \id{KINSetPrintLevel} \\
%
2  & \id{MXITER}            &             & \id{KINSetNumMaxIters} \\
%
3  & \id{PRECOND\_NO\_INIT} &             & \id{KINSetNoPrecInit} \\
%
4  &                        & \id{NNI}    & \id{KINGetNumNonlinSolvIters} \\
%                                                                
5  &                        & \id{NFE}    & \id{KINGetNumFuncEvals} \\
%
6  &                        & \id{NBCF}   & \id{KINGetNumBetaCondFails} \\
%
7  &                        & \id{NBKTRK} & \id{KINGetNumBacktrackOps} \\
%
8  & \id{ETACHOICE}         &             & \id{KINSetEtaForm} \\
%
9  & \id{NO\_MIN\_EPS}      &             & \id{KINSetNoMinEps} \\
%
\hline
\multicolumn{4}{|c|}{{\kinspgmr} linear solver}\\
\hline
11 &  & \id{NLI}       & \id{KINSpgmrGetNumLinIters} \\ 
12 &  & \id{NPE}       & \id{KINSpgmrGetNumPrecEvals} \\ 
13 &  & \id{NPS}       & \id{KINSpgmrGetNumPrecSolves} \\ 
14 &  & \id{NCFL}      & \id{KINSpgmrGetNumConvFails} \\
15 &  & \id{LS\_FLAG}  & \id{KINSpgmrGetLastFlag} \\ 
\hline
\multicolumn{4}{c}{}\\
\multicolumn{4}{c}{Real input-output array \id{ROPT}}\\\hline
{\bf Index} & {\bf Optional input} & {\bf Optional output} & {\kinsol} {\bf function} \\ 
\hline
%
1  & \id{MXNEWTSTEP} &             & \id{KINSetMaxNewtonStep} \\
%
2  & \id{RELFUNC}    &             & \id{KINSetRelErrFunc} \\
%
3  &                 & \id{FNORM}  & \id{KINGetFuncNorm} \\
%
4  &                 & \id{STEPL}  & \id{KINGetStepLength} \\
%
5  & \id{ETACONST}   &             & \id{KINSetEtaConstValue} \\
%
6  & \id{ETAGAMMA}   &             & \id{KINSetEtaParams} \\
%
7  & \id{ETAALPHA}   &             & \id{KINSetEtaParams} \\
%
\hline
%
\end{tabular}
\end{table}                                                                  


%%==============================================================================
\subsection{Usage of the FKINSOL interface module}\label{ss:fkinsol_usage}
%%==============================================================================

The usage of {\fkinsol} requires calls to several interface
functions, depending on the method options selected, and one or more
user-supplied routines which define the problem to be solved.  These
function calls and user routines are summarized separately below.
Some details are omitted, and the user is referred to the description
of the corresponding {\kinsol} functions for information on the arguments 
of any given user-callable interface routine, or of a given user-supplied 
function called by an interface function.
The usage of {\fkinsol} with the band-block-diagonal preconditioner module
{\kinbbdpre} is described in the next subsection.

Steps marked with {\s} in the instructions below apply to the serial
{\nvector} implementation ({\nvecs}) only, while those marked with {\p}
apply to {\nvecp}.

\index{User main program!FKINSOL@{\fkinsol} usage}
\begin{Steps}
  
\item {\bf Nonlinear system function specification}
  
  The user must in all cases supply the following {\F} routine
  \index{FKFUN@\texttt{FKFUN}}
\begin{verbatim}
      SUBROUTINE FKFUN(U, FVAL)
      DIMENSION U(*), FVAL(*)
\end{verbatim}
  It must set the \id{FVAL} array to $F(u)$, the system function, as a
  function of the array \id{U}. Here \id{U} and \id{FVAL} are arrays representing
  vectors, which are distributed vectors in the parallel case.

\item  {\bf {\nvector} module initialization}

  {\s} To initialize the serial {\nvector} module, the user must make the
  following call:
  \index{FNVINITS@\texttt{FNVINITS}}
\begin{verbatim}
      CALL FNVINITS(NEQ, IER)
\end{verbatim}
  where \id{NEQ} is the size of vectors and
  \id{IER} is a return completion flag which is set to $0$ on success and $-1$ 
  if a failure occurred.
  
  {\p} To initialize the parallel vector module, the user must make the
  following call:
  \index{FNVINITP@\texttt{FNVINITP}}
\begin{verbatim}
      CALL FNVINITP(NLOCAL, NGLOBAL, IER)
\end{verbatim}
  in which the arguments are: \id{NLOCAL} the local size of vectors for this
  process, \id{NGLOBAL} the system size (and the global size of vectors, that
  is the sum of all values of NLOCAL). The return completion flag \id{IER} is
  set to $0$ upon successful return and to $-1$ otherwise.
  Note that if {\mpi} was initialized by the user, the communicator must be
  set to \id{MPI\_COMM\_WORLD}.  If not, this routine initializes {\mpi} and sets
  the communicator equal to \id{MPI\_COMM\_WORLD}.

\item {\bf Problem specification}

  To set various problem and solution parameters and allocate
  internal memory, make the following call:
  \index{FKINMALLOC@\texttt{FKINMALLOC}}
  \ucfunction{FKINMALLOC}
  {
    \begin{tabular}[t]{@{}r@{}l@{}l@{}}
      &CALL FKINMALLOC(&MSBPRE, FNORMTOL, SCSTEPTOL, CONSTRAINTS, \\
    {\&}&                &OPTIN, IOPT, ROPT, IER)
    \end{tabular}
  }
  {
    This function provides required problem and solution specifications, 
    specifies optional inputs,
    allocates internal memory, and initializes {\kinsol}.
  }
  {
    \begin{args}[CONSTRAINTS\,]
    \item[MSBPRE] is the maximum number of preconditioning solve calls
      without calling the preconditioning setup routine.
      A value of $0$ indicates the default.
    \item[FNORMTOL] is the tolerance on the scaled maximum norm of
      $F(u)$ to accept convergence. 
    \item[SCSTEPTOL] is the tolerance on minimum scaled step size.
    \item[CONSTRAINTS] is an array of constraint values on the components of the
      solution $u$.
    \item[OPTIN] is an integer flag indicating whether
      input values in \Id{IOPT} and/or \Id{ROPT} are to be used for input. A value of
      $0$ means {\em no} and a value of $1$ indicates {\em yes}.
    \item[IOPT] is an array of integer optional inputs and outputs
      (must be declared as \id{INTEGER*4} or \id{INTEGER*8} according to the
      {\C} type long int).
    \item[ROPT] is an array of real optional inputs and outputs.
    \end{args}
  }
  {
    ~~\id{IER} is the return completion flag. Its possible values are $0$ 
    indicating success or $-1$ indicating failure.
  }
  {
    The optional inputs and outputs associated with the main {\kinsol} integrator
    are listed in Table~\ref{t:fkinsol_io}.
    If any of the optional inputs are used, the others must be set
    to zero to indicate default values.

    Since {\kinsol} maintains a private copy of the constraints vector, the
    \id{CONSTRAINTS} array passed as an argument to \Id{FKINMALLOC} can be reused
    after the function call.

    {\warn} If \id{OPTIN} is set to $1$, then \id{FKINSOL} will set the applicable
    optional outputs before returning, so the \Id{IOPT} and \Id{ROPT} arrays should
    not be reused.
  }
  
\item\label{i:fkinsol_lin_solv_spec}{\bf Linear solver specification} 
  
  The solution method in {\kinsol} involves the solution of linear systems 
  related to the Jacobian of the nonlinear system.
  
  For the Scaled Preconditioned GMRES solution of the linear systems,
  the user must make the call:
  \index{FKINSPGMR@\texttt{FKINSPGMR}}
\begin{verbatim}
      CALL FKINSPGMR(MAXL, MAXLRST, IER)
\end{verbatim}
  The arguments are as follows.
  \id{MAXL} is the maximum Krylov subspace dimension ($0$ indicates default).
  \id{MAXLRST} is the maximum number of linear system restarts ($0$ indicates
  default).
  \id{IER} is the return completion flag (possible values are $0$: success and
  $-1$: failure).
    
  \index{Jacobian-vector product approximation!use in {\fkinsol}}
  As an option when using the {\spgmr} linear solver, the user may supply a 
  routine that computes the product of the system Jacobian 
  $J = \partial F / \partial u$ 
  and a given vector $v$.  If supplied, it must have the following form:
  \index{FKJTIMES@\texttt{FKJTIMES}}
\begin{verbatim}
      SUBROUTINE FKJTIMES(V, Z, NEWU, U, IER)
      DIMENSION V(*), Z(*), U(*)
\end{verbatim}
  This must set the array \id{Z} to the product $Jv$, where $J$ is the Jacobian
  matrix $J = \partial F/ \partial u$, and \id{V} is a given array. 
  Here \id{U} is an array containing
  the current value of the unknown vector $u$. \id{NEWU} is an input integer 
  indicating whether \id{U} has changed since \id{FKJTIMES} was last called 
  (1 = yes, 0 = no). If \id{FKJTIMES} computes and saves Jacobian data, then 
  no such computation is necessary when \id{NEWU} $= 0$. 
  The arguments \id{V}, \id{Z}, and \id{U} are 
  arrays of length \id{NEQ}, the problem size, or the local length of all 
  distributed vectors in the parallel case. \id{FKJTIMES} should return 
  \id{IER} $= 0$ if successful, or a nonzero \id{IER} otherwise.
  
  If the user program includes the \id{FKJTIMES} routine for the evaluation
  of the Jacobian vector product, the following call must be made:
  \index{FKINSPGMRSETPSOL@\texttt{FKINSPGMRSETPSOL}}
\begin{verbatim}
      CALL FKINSPGMRSETJAC(FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied Jacobian times
  vector approximation.
  The argument \id{IER} is an error return flag which can be $0$ 
  for success or nonzero if an error occurred.
  
  If preconditioning is to be done, then, following the
  call to \id{FKINSPGMR}, the user must call
  \index{FKINSPGMRSETPREC@\texttt{FKINSPGMRSETPREC}}
\begin{verbatim}
      CALL FKINSPGMRSETPREC(FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$, and the user program must include the following routine
  for solution of the preconditioner linear system:
  \index{FKPSOL@\texttt{FKPSOL}}
\begin{verbatim}
      SUBROUTINE FKPSOL (U, USCALE, FVAL, FSCALE, VTEM, FTEM, IER)
      DIMENSION U(*), USCALE(*), FVAL(*), FSCALE(*), VTEM(*), FTEM(*)
\end{verbatim}
  Typically this routine will use only \id{U}, \id{FVAL}, \id{VTEM} and \id{FTEM}.
  It must solve the preconditioned linear system $Pz = r$, where
  $r = $ \id{VTEM} is input, and store the solution $z$ in \id{VTEM} as well. 
  Here $P$ is the right preconditioner. If scaling is being used, the
  routine supplied must also account for scaling on either coordinate
  or function value, as given in the arrays \id{USCALE} and
  \id{FSCALE}, respectively.
  
  If the user's preconditioner requires that any Jacobian-related data be evaluated
  or preprocessed, then the following routine can be used for the evaluation and
  preprocessing of the preconditioner:
  \index{FKPSET@\texttt{FKPSET}}
\begin{verbatim}
      SUBROUTINE FKPSET (U, USCALE, FVAL, FSCALE, VTEMP1, VTEMP2, IER)
      DIMENSION U(*), USCALE(*), FVAL(*), FSCALE(*), VTEMP1(*), VTEMP2(*)
\end{verbatim}
  It must perform any evaluation of Jacobian-related data and
  preprocessing needed for the solution of the preconditioned linear
  systems by \id{FKPSOL}. The variables \id{U} through \id{FSCALE} are for use in the
  preconditioning setup process. Typically, the system function \id{FKFUN} is
  called before any calls to \id{FKPSET}, so that \id{FVAL} will have
  been updated. \id{U} is the current solution
  iterate. The arrays \id{VTEMP1} and \id{VTEMP2} are available for work space. 
  If scaling is being used, \id{USCALE} and \id{FSCALE} are available for those operations
  requiring scaling. \id{NEQ} is the problem size.
  
  On return, set \id{IER} $= 0$ if \id{FKPSET} was successful or set \id{IER} $= 1$
  if an error occurred.
  
  {\warn} If the user calls \id{FKINSPGMRSETPREC}, the routine \id{FKINPSET} must
  be provided, even if it's empty.

\item {\bf Problem solution}
  Solving the nonlinear system is accomplished by making the following call:
  \index{FKINSOL@\texttt{FKINSOL}}
\begin{verbatim}
      CALL FKINSOL(U, GLOBALSTRAT, USCALE, FSCALE, IER)
\end{verbatim}
  The arguments are as follows.
  \id{U} is an array containing the initial guess on input, and the
  solution on return.
  \id{GLOBALSTRAT} is an integer (type \id{INTEGER}) defining the global strategy 
  choice ($1$ specifies Inexact Newton, while $2$ indicates line search).
  \id{USCALE} is an array of scaling factors for the \id{U} vector.
  \id{FSCALE} is an array of scaling factors for the \id{FVAL} vector.
  \id{IER} is an integer completion flag and will have one of the following values:
  $0$ to indicate success,
  $1$ to indicate that the initial guess satisfies $F(u) = 0$ within tolerances,
  $2$ to indicate apparent stalling (small step), or a negative value to indicate
  an error or failure.  The possible negative return values and the
  corresponding \id{KINSol} return values (see \S\ref{ss:kinsol}) are:
  -1: \id{KIN\_MEM\_NULL}, -2: \id{KIN\_ILL\_INPUT}, -3: \id{KIN\_NO\_MALLOC},
  -4: \id{KIN\_MEM\_FAIL}, -5: \id{KIN\_LINESEARCH\_NONCONV},
  -6: \id{KIN\_MAXITER\_REACHED}, -7: \id{KIN\_MXNEWT\_5X\_EXCEEDED},
  -8: \id{KIN\_LINESEARCH\_BCFAIL}, -9: \id{KIN\_LINSOLV\_NO\_RECOVERY},
  -10: \id{KIN\_LINIT\_FAIL}, -11: \id{KIN\_LSETUP\_FAIL},
  -12: \id{KIN\_LSOLVE\_FAIL}, and -13: \id{KIN\_PDATA\_NULL}.
  
  The current values of the optional outputs are available in \id{IOPT} and
  \id{ROPT} (see Table~\ref{t:fkinsol_io}).
  
\item {\bf Memory deallocation}
  To free the internal memory created by the call to \id{FKINMALLOC},
  make the call
  \index{FKINFREE@\texttt{FKINFREE}}
\begin{verbatim}
      CALL FKINFREE
\end{verbatim}
  and then, depending on the {\nvector} version (serial or parallel), either
  \index{FNVFREES@\texttt{FNVFREES}}
\begin{verbatim}
      CALL FNVFREES
\end{verbatim}
  or
  \index{FNVFREEP@\texttt{FNVFREEP}}
\begin{verbatim}
      CALL FNVFREEP  
\end{verbatim}
  respectively.
  
\end{Steps}
\index{FKINSOL@{\fkinsol} interface module!usage|)}


%%==============================================================================
\subsection{Usage of the FKINBBD interface to KINBBDPRE}
%%==============================================================================
\index{FKINBBD@{\fkinbbd} interface module!usage}

The {\fkinbbd} interface sub-module is a package of {\C} functions which,
as part of the {\fkinsol} interface module, support the use of the
{\kinsol} solver with the parallel {\nvecp} module and the {\kinbbdpre} 
preconditioner module (see \S\ref{sss:kinbbdpre}), for the solution of 
nonlinear problems in a mixed {\F}/{\C} setting.  

The user-callable functions in this package, with the corresponding
{\kinsol} and {\kinbbdpre} functions, are as follows: 
\begin{itemize}
\item \id{FKINBBDINIT}
  interfaces to \id{KINBBDPrecAlloc}.
\item \id{FKINBBDSPGMR}
  interfaces to \id{KINBBDSpgmr} and {\spgmr} optional input functions.
\item \id{FKINBBDOPT}
  interfaces to {\kinbbdpre} optional output functions.
\item \id{FKINBBDFREE}
  interfaces to \id{KINBBDPrecFree}.
\end{itemize}

In addition to the {\F} right-hand side function \id{FKFUN}, the
user-supplied functions used by this package, are listed below,
each with the corresponding interface function which calls it (and its
type within {\kinbbdpre} or {\kinsol}):
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\fkinbbd} routine ({\F})  &  {\kinsol} function ({\C}) & {\kinsol} function type \\\hline
\id{FKLOCFN}  & \id{FKINgloc}     & \id{KINLocalFn} \\
\id{FKCOMMF}  & \id{FKINgcomm}      & \id{KINCommFn} \\
\id{FKJTIMES} & \id{FKINJtimes}   & \id{KINSpgmrJacTimesVecFn} \\ \hline
\end{tabular}
\end{center}
As with the rest of the {\fkinsol} routines, the names of the user-supplied routines
are mapped to actual values through a series of definitions in the header file
\id{fkinbbd.h} (see \S\ref{ss:fcmix}).

The following is a summary of the usage of this module. Steps that are unchanged
from the main program described in \S\ref{ss:fkinsol_usage} are grayed out.


\index{User main program!FCVBBD@{\fcvbbd} usage}
\begin{Steps}
  
\item \textcolor{gray}{\bf Nonlinear system function specification}

\item \textcolor{gray}{\bf {\nvector} module initialization}

\item \textcolor{gray}{\bf Problem specification}

\item {\bf Linear solver specification}

  To initialize the {\kinbbdpre} preconditioner, make the following call:
  \index{FKINBBDINIT@\texttt{FKINBBDINIT}}
\begin{verbatim}
      CALL FKINBBDINIT(NLOCAL, MU, ML, IER)
\end{verbatim}
  The arguments are as follows.
  \id{NLOCAL} is the local size of vectors for this process.
  \id{MU} and \id{ML} are the upper and lower half-bandwidths to be used in 
  the computation of the local Jacobian blocks by difference quotients.
  These may be smaller than the true half-bandwidths of the
  Jacobian of the local block of $G$, when smaller values may
  provide greater efficiency.
  \id{IER} is a return completion flag.  A value of $0$ indicates success, while
  a value of $-1$ indicates that a memory failure occurred or that an input had
  an illegal value.
  
  To specify the {\spgmr} linear system solver and use the {\kinbbdpre}
  preconditioner, make the following call:
  \index{FKINBBDSPGMR@\texttt{FKINBBDSPGMR}}
\begin{verbatim}
      CALL FKINBBDSPGMR(MAXL, MAXLRST, IER)
\end{verbatim}
  Its arguments are the same as those of \id{FKINSPGMR}
  (see step \ref{i:fkinsol_lin_solv_spec} in \S\ref{ss:fkinsol_usage}).
  
  Optionally, to specify that {\spgmr} should use the supplied \id{FKJTIMES}, 
  make the call
  \index{FKINSPGMRSETJAC@\texttt{FKINSPGMRSETJAC}}
\begin{verbatim}
      CALL FKINSPGMRSETJAC(FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$.
  
\item \textcolor{gray}{\bf Problem solution}
  
\item {\bf {\kinbbdpre} Optional outputs}
  
  To obtain the optional outputs associated with the {\kinbbdpre} module, make
  the following call:
  \index{FKINBBDOPT@\texttt{FKINBBDOPT}}
  \index{optional output!FKINBBD@{\fkinbbd}}
  \index{FKINBBD@{\fkinbbd} interface module!optional output}
\begin{verbatim}
      CALL FKINBBDOPT(LENRPW, LENIPW, NGE)
\end{verbatim}
  The arguments returned are as follows.
  \id{LENRPW} is the length of real preconditioner work space, in \id{realtype}
  words.  This size is local to the current process.
  \id{LENIPW} is the length of integer preconditioner work space, in integer
  words.  This size is local to the current process.
  \id{NGE} is the cumulative number of $G(u)$ evaluations (calls to \id{FKLOCFN}).
  
\item {\bf Memory deallocation}

  To free the internal memory created by the call to \id{FKINBBDINIT}, before
  calling \id{FKINFREE} and \id{FNVFREEP}, the user must call
  \index{FKINBBDFREE@\texttt{FKINBBDFREE}}
\begin{verbatim}
      CALL FKINBBDFREE
\end{verbatim}
\index{FKINSOL@{\fkinsol} interface module!interface to the {\kinbbdpre} module|)}

\end{Steps}
