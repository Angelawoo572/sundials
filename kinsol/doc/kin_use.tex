%===================================================================================
\chapter{Using {\kinsol}}\label{c:usage}
%===================================================================================

This section is concerned with the use of {\kinsol} for the solution of nonlinear systems.
The following subsections treat the header files, the layout of the user's main
program, description of the {\kinsol} user-callable routines, and user-supplied functions.
The listings of the sample programs in the companion document \cite{kin2.2.0_ex} may also 
be helpful. Those codes are intended to serve as templates and are included in the 
{\kinsol} package.

%------------------------
\section{Header Files}\label{s:headers_sol}
%------------------------

The calling program must include several header files so that various macros
and data types can be used. The header file that is always required is:
%
\begin{itemize}
\item  \Id{kinsol.h}, 
  the header file for {\kinsol}, which defines the several
  types and various constants, and includes function prototypes.
\end{itemize}
%
Note that \id{kinsol.h} also includes \Id{sundialstypes.h}, 
which defines the types \id{realtype}, and \id{ booleantype}
and constants \id{FALSE} and \id{TRUE}.

The calling program must also include an {\nvector} implementation header file
(see \S\ref{s:nvector} for details).
For the two {\nvector} implementations that are included in the {\kinsol} package,
the corresponding header files are:
%
\begin{itemize}
\item \Id{nvector\_serial.h}, 
  which defines the serial implementation {\nvecs};
\item \Id{nvector\_parallel.h}, 
  which defines the parallel MPI implementation, {\nvecp}.
\end{itemize}
%
Note that both these files include in turn the header file \Id{nvector.h} which 
defines the abstract \Id{N\_Vector} type. 

Finally, a linear solver module header file is required. 
\index{KINSOL@{\kinsol} linear solvers!header files}
At the present time, {\kinsol} offers only a Krylov linear solver, {\kinspgmr},
whose corrsponding header file is \Id{kinspgmr.h}, 
This in turn includes a header file (\id{iterative.h})
which enumerates the kind of preconditioning and the choices for the
Gram-Schmidt process.

Other headers may be needed, according as to the choice of
preconditioner, etc. In the \id{kinwebs} example~\cite{kin2.20_ex}, 
preconditioning is done with a block-diagonal matrix. For this, the header
\id{smalldense.h} is included.

%-------------------------------------------------
\section{A Skeleton of the User's Main Program}\label{s:skeleton_sol}
%-------------------------------------------------

A high-level view of the combined user program and {\kinsol} package is
shown in Figure~\ref{f:sim_overview}.
%%
\begin{figure}
\centerline{\psfig{figure=kinsim.eps,width=\textwidth}}
\caption {Diagram of the user program and 
  {\kinsol} package for the solution of nonlinear systems}\label{f:sim_overview}
\end{figure}
%%
The following is a skeleton of the user's main program (or calling
program) for the solution of a nonlinear problem. 
Most steps are independent of the {\nvector} implementation used; 
where this is not the case, usage specifications are given for the two implementations 
provided with {\kinsol}: steps marked with {\p} correspond to 
{\nvecp}, while steps marked with {\s} correspond to {\nvecs}.
%
\begin{Steps}
  
\item 
  {\bf Initialize MPI}

  {\p} \id{MPI\_Init(\&argc, \&argv);} to initialize MPI if used by
  the user's program, aside from the internal use in {\nvecp}.  
  Here \id{argc} and \id{argv} are the command line argument 
  counter and array received by \id{main}.
  
\item
  {\bf Set problem dimensions}

  {\s} Set \id{N}, the problem size $N$.

  {\p} Set \id{Nlocal}, the local vector length (the sub-vector
  length for this processor); \id{N}, the global vector length (the
  problem size $N$, and the sum of all the values of \id{Nlocal});
  and the active set of processors.
  
\item
  {\bf Set vector with intial guess}
 
  To set the vector \id{y} of initial values, use functions defined by a
  particular {\nvector} implementation.  If a \id{realtype} array  \id{ydata}
  already exists, containing the initial guess of $y$, make the call:

  {\s} \id{y = NV\_Make\_Serial(N, ydata);}

  {\p} \id{y = NV\_Make\_Parallel(comm, Nlocal, N, ydata);}

  Otherwise, make the call:

  {\s} \id{y = NV\_New\_Serial(N);}

  {\p} \id{y = NV\_New\_Parallel(comm, Nlocal, N);}

  and load initial values into the structure defined by:

  {\s} \id{NV\_DATA\_S(y)}

  {\p} \id{NV\_DATA\_P(y)}

  Here \id{comm} is the MPI communicator, set in one of two ways: 
  If a proper subset of active processors is to be used, \id{comm} 
  must be set by suitable MPI calls. Otherwise, to specify that all 
  processors are to be used, \id{comm} must be \id{MPI\_COMM\_WORLD}.
  
\item\label{i:kinsol_create} 
  {\bf Create {\kinsol} object}

  Call \id{kin\_mem = KINCreate();} 
  to create the {\kinsol} memory bloc.
  \id{KINCreate} returns a pointer to the {\kinsol} memory structure.

\item
  {\bf Set optional inputs}

  Call \id{KINSet*} routines to change from their default values any
  optional inputs that control the behavior of {\kinsol}.

\item\label{i:kinsol_malloc} 
  {\bf Allocate internal memory}

  Call \id{KINMalloc(...);} 
  to specify the problem defining function $F$,
  allocate internal memory for {\kinsol}, 
  and initialize {\kinsol}.
  \id{KINMalloc} returns an error flag to indicate success or an illegal argument value
  (for details see \S\ref{ss:kinmalloc}).

\item\label{i:lin_solver} 
  {\bf Attach linear solver module}

  Initialize the linear solver module by calling \id{KINSpgmr(...);}
  to spcify the maximum dimensino of the Krylov subspace.

\item
  {\bf Set linear solver optional inputs}

  Call \id{KINSpgmrSet*} routines to change optional inputs  
  for the {\kinspgmr} linear solver.

\item
  {\bf Solve problem}

  Call \id{KINSol(...);} to solve the nonlinear problem for a given
  initial guess (see \S\ref{sss:kinsol} for details).

\item
  {\bf Get optional outputs}

  Call \id{KINGet*} functions to obtain optional output from {\kinsol}
  and \id{KINSpgmrGet*} functinos for optional outputs from {\kinspgmr}.
  See \S\ref{ss:optional_output}.

\item
  {\bf Deallocate memory for solution vector}

  Upon completion of the solution, deallocate memory for the vector \id{y}
  by calling the destructor function defined by the {\nvector} implementation:

  {\s} \id{NV\_Destroy\_Serial(y);}

  {\p} \id{NV\_Destroy\_Parallel(y);}
  
\item
  {\bf Free solver memory}

  Call \id{KINFree(kin\_mem);} to free the memory allocated for {\kinsol}.
  
\item 
  {\bf {\p} Finalize MPI}

  Call \id{MPI\_Finalize();} to terminate MPI.
  
\end{Steps}

%%==============================================================================

\section{User-callable functions}\label{s:kinsol_fct_sol}

This section describes the {\kinsol} functions that are called by the
user to set up and solve a nonl;inear problem. Some of these are required. However,
starting with \S\ref{ss:optional_input}, the functions listed involve
optional inputs/outputs or restarting, and those paragraphs can be
skipped for a casual use of {\kinsol}. In any case, refer to
\S\ref{s:skeleton_sol} for the correct order of these calls.

%%-------------------------------------------------------------------------------

\subsection{{\kinsol} initialization and deallocation functions}\label{ss:kinmalloc}

The following three functions must be called in the order listed. The last one
is to be called only after the problem solution complete, as it frees the
{\kinsol} memory block created and allocated by the first two calls.
%%
\ucfunction{KINCreate}
{
  kin\_mem = KINCreate();
}
{
  The function \ID{KINCreate} instantiates a {\kinsol} solver object.
}
{
  This function has no arguments.
}
{
  If successful, \id{KINCreate} returns a pointer to the newly created 
  {\kinsol} memory block (of type \id{void *}).
  If an error occurred, \id{KINCreate} prints an error message to \id{stderr}
  and returns \id{NULL}.
}
{}
%%
%%
\ucfunction{KINMalloc}
{
flag = KINMalloc(kin\_mem, f, tmpl);
}
{
  The function \ID{KINMalloc} specifies the problem-defining
  funciton, allocates internal memory, and initializes {\kinsol}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block returned by \id{KINCreate}.
  \item[f] (\Id{KINSysFn})
    is the {\C} function which computes $F$ in the nonlinear problem. 
    This function has the form \id{f(y, fval, f\_data)} 
    (for full details see \S\ref{ss:sysFn}).
  \item[tmpl] (\id{N\_Vector})
    is an \id{N\_Vector} which is used as a template to create (by cloning)
    necessary vectors in \id{kin\_mem}.
  \end{args}
}
{
  The return flag \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The call to \id{KINMalloc} was successful.
  \item[\Id{KIN\_MEM\_NULL}] 
    The {kinsol} memory block was not initialized through a previous call
    to \id{KINCreate}.
  \item[\Id{KIN\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{KIN\_ILL\_INPUT}] 
    An input argument to \id{KINMalloc} has an illegal value.
  \end{args}
}
{
  If an error occurred, \id{KINMalloc} also prints an error message to the
  file specified by the optional input \id{errfp}.
}
%%
%%
\ucfunction{KINFree}
{
  KINFree(kin\_mem);
}
{
  The function \ID{KINFree} frees the pointer allocated by
  a previous call to \id{KINMalloc}.
}
{
  The argument is the pointer to the {\kinsol} memory block (of type \id{void *}).
}
{
  The function \id{KINFree} has no return value.
}
{}
%%

%%-------------------------------------------------------------------------------

\subsection{Linear solver specification function}\label{ss:lin_solv_init}

As previously explained, Newton iteration requires the solution of
linear systems of the form (\ref{e:Newton}).  At the present time
there is only one solver available for this task, {\kinspgmr}. 
This is an iterative solver that uses a scaled preconditioned
GMRES method.

\index{KINSOL{\kinsol} linear solvers!selecting|(} 
To attch the {\kinspgmr} linear solver, after the call to \id{KINCreate}
but before any call to \id{KINSol}, the user's program must call  \Id{KINSpgmr},
as documented below. The first argument passed to this function is the {\kinsol}
memory pointer returned by \id{KINCreate}.  The call to this
function links the linear solver to the main {\kinsol} memory block and
allows the user to specify parameters for {\kinspgmr}
%%

\index{KINSOL@{\kinsol} linear solvers!built on generic solvers} 
The {\kinspgmr} linear solver is actually built on top of a generic
linear system solver, which may be of interest in itself.  This
generic solver, {\spgmr}, is described separately in \S\ref{s:gen_linsolv}.

\index{KINSOL@{\kinsol} linear solvers!KINSPGMR@{\kinspgmr}}
\ucfunction{KINSpgmr}
{
  flag = KINSpgmr(kin\_mem, maxl);
}
{
  \index{KINSPGMR@{\kinspgmr} linear solver!selection of} 
  The function \ID{KINSpgmr} selects the {\kinspgmr} linear solver. 
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[maxl] (\id{int})
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{KINSPGMR\_MAXL}$=5$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_ILL\_INPUT]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The {\kinspgmr} initialization was successful.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_ILL\_INPUT}]
    The {\nvector} module used does not implement a required operation.
  \item[\Id{KINSPGMR\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\kinspgmr} solver uses a scaled preconditioned GMRES\index{GMRES method}
  iterative method to solve the linear system (\ref{e:Newton}).

  Within {\kinsol}, preconditioning can be done on the right only.
  For specification of preconditioner,
  see \S\ref{ss:optional_input} and \S\ref{ss:user_fct_sim}.

  If preconditioning is done, user-supplied functions define the right 
  preconditioner matrices $P$ which approximates the Newton matrix
  of (\ref{e:Newton}).
}

%--------------------------------------------------------------------
\subsection{{\kinsol} solver function}\label{ss:kinsol}

\ucfunction{KINSol}
{
  flag = KINSol(kin\_mem, y, strategy, y\_scale, f\_scale);
}
{
  The function \ID{KINSol} computes an approximate solution of the nonlinear
  system.
}
{
  \begin{args}[strategy]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[y] (\id{N\_Vector})
    vector set to initial guess by user before calling \id{KINSol},
    but which upon return contains an approximate solution of
    the nonlinear system $F(y) = 0$ the computed solution vector.
  \item[strategy]
    global strategy applied to Newton step if unsatisfactory.
    It must be one of \ID{KIN\_INEXACT\_NEWTON} or \ID{KIN\_LINESEARCH}.
  \item[y\_scale]
    vector containing diagonal elements of scaling matrix for vector \id{y}
    chosen so that the components of \id{y\_scale}$\cdot$\id{y}
    (as a matrix multiplication) all have about the same magnitude when 
    \id{y} is close to a root of $F(y)$.
  \item[f\_scale]
    vector containing diagonal elements of scaling matrix for $F(y)$ chosen 
    so that the components of \id{f\_scale}$\cdot F($\id{y}$)$ 
    (as a matrix multiplication) all have roughly the same magnitude when 
    \id{y} is not too near a root of $F(y)$.
  \end{args}
}
{
  On return, \id{KINSol} returns the approximate solution in the vector \id{y}.
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[a]

  \item[\Id{KIN\_SUCCESS}]\rule{0pt}{0pt}

    \id{KINSol} succeeded.

  \item[\Id{KIN\_INITIAL\_GUESS\_OK}]\rule{0pt}{0pt}

    The guess \id{y} satisfied the system $F(y)=0$
    within the tolerances specified.

  \item[\Id{KIN\_STEP\_LT\_STPTOL}]\rule{0pt}{0pt}

    {\kinsol} stopped based on scaled step length.
    This means that the current iterate may be an approximate solution of the given
    nonlinear system, but it is also quite possible that the algorithm is "stalled" 
    (making insufficient progress) near an invalid solution, or that the 
    scalar \id{scsteptol} is too large (see \id{KINSetScaledStepTol} in 
    \S\ref{ss:optional_input} to change \id{scsteptol} from its default value).

  \item[\Id{KIN\_MEM\_NULL}]\rule{0pt}{0pt}

    The {\kinsol} memory block pointer was \id{NULL}.
 
  \item[\Id{KIN\_ILL\_INPUT}]\rule{0pt}{0pt}

    An input parameter was invalid.

  \item[\Id{KIN\_NO\_MALLOC}]\rule{0pt}{0pt}

    The {\kinsol} memory was not allocated by a call to \id{KINMalloc}.

  \item[\Id{KIN\_LINESEARCH\_NONCONV}]\rule{0pt}{0pt}

    The line search algorithm was unable
    to find an iterate sufficiently distinct
    from the current iterate
    
    Failure to satisfy the sufficient decrease
    condition could mean the current iterate is
    "close" to an approximate solution of the given
    nonlinear system, the finite-difference
    approximation of the matrix-vector product
    $J(u) v$ is inaccurate, or the real scalar
    \id{scsteptol} is too large.
 
  \item[\Id{KIN\_MAXITER\_REACHED}] \rule{0pt}{0pt}

    The maximum number of nonlinear iterations
    has been reached.
 
  \item[\Id{KIN\_MXNEWT\_5X\_EXCEEDED}]\rule{0pt}{0pt}
    
    Five consecutive steps have been taken
    that satisfy the inequality
    $\|u_{scale} p\|_{L2} > 0.99 mxnewtstep$,
    where $p$ denotes the current step and
    $mxnewtstep$ is a scalar upper bound
    on the scaled step length.
    
    Such a failure may mean that $\|f_{scale} F(y)\|_{L2}$
    asymptotes from above to a finite value, or
    the real scalar \id{mxnewtstep} is too small.
 
  \item[\Id{KIN\_LINESEARCH\_BCFAIL}]\rule{0pt}{0pt}

    The line search algorithm
    was unable to satisfy the
    ``beta-condition'' for \id{MXNBCF} $+ 1$ nonlinear
    iterations (not necessarily consecutive),
    which may indicate the algorithm is making
    poor progress.
 
  \item[\Id{KIN\_LINSOLV\_NO\_RECOVERY}]\rule{0pt}{0pt}

    The user-supplied routine \id{psolve}
    encountered a recoverable error, but
    the preconditioner is already current.
 
  \item[\Id{KIN\_LINIT\_FAIL}]\rule{0pt}{0pt}

    The linear solver initialization routine (\id{linit})
    encountered an error.
 
  \item[\Id{KIN\_LSETUP\_FAIL}]\rule{0pt}{0pt}

    The user-supplied routine \id{pset} (used to compute
    the preconditioner) encountered an unrecoverable
    error.
 
  \item[\Id{KIN\_LSOLVE\_FAIL}]\rule{0pt}{0pt}

    Tither the user-supplied routine \id{psolve} (used to
    to solve the preconditioned linear system) encountered
    an unrecoverable error, or the linear solver routine
    (\id{lsolve}) encountered an error condition.
 
  \end{args}
}
{
  The components of vectors \id{y\_scale} and \id{f\_scale} should be positive.
  
  \id{KIN\_SUCCESS} $=0$, \id{KIN\_INITIAL\_GUESS\_OK} $=1$, and 
  \id{KIN\_STEP\_LT\_STPTOL} $=2$.
  %%
  All remaining return values are negative and therefore a test \id{flag}$< 0$
  will trap all \id{KINSol} failures.
}


%%==============================================================================
\subsection{Optional input functions}\label{ss:optional_input}
%%==============================================================================

{\kinsol} provides an extensive list of functions that can be used to change
from their default values various optional input parameters that control the
behavior of the {\kinsol} solver. 
Table \ref{t:optional_input} lists all optional input functions in {\kinsol} which 
are then described in detail in the remainder of this section.
For the most casual use of {\kinsol}, the reader can skip to \S\ref{ss:user_fct_sol}.

We note that, on error return, all these functions also print an error message
to \id{stderr} (or to the file pointed to by \id{errfp} if already specified).
\index{error message}
We also note that all error return values are negative, so a test \id{flag}$<0$
will catch any error.

\begin{table}
\centering
\caption{Optional inputs for {\kinsol} and {\kinspgmr}}
\label{t:optional_input}
\medskip
\begin{tabular}{|l|l|l|}\hline
{\bf Optional input} & {\bf Function name} & {\bf Default} \\
\hline
\multicolumn{3}{|c|}{\bf KINSOL main solver} \\
\hline
Pointer to an error file & \id{KINSetErrFile} & \id{stderr}  \\
Pointer to an info file & \id{KINSetInfofile} & \id{stdout} \\
Data for problem-defining function & \id{KINSetFdata} & NULL \\
Verbosity level of output & \id{KINSetPrintLevel} & 0 \\
Max. number of nonlinear iterations & \id{KINSetNumMaxIters} & 200 \\
No initial preconditioner setup & \id{KINSetNoPrecInit} & \id{FALSE} \\
Max. iterations without prec. setup & \id{KINSetMaxprecCalls} & 10 \\
Form of $\eta$ coefficient & \id{KINSetEtaform} &  \id{KIN\_ETACHOICE1}\\
Constant value of $\eta$ & \id{KINSetEtaconstValue} &  0.1 \\
Values of $\gamma$ and $\alpha$ & \id{KINSetEtaParams} & 0.9 and 2.0 \\
Lower bound on $\epsilon$ & \id{KINSetNoMinEps} & \id{FALSE} \\
Max. scaled length of Newton step & \id{KINSetMaxNewtonStep} & $1000 \| u_{scale} y_0 \|_{L_2}$ \\
Rel. error for F.D. $Jv$ & \id{KINSetRelerrFunc} & $\sqrt{\text{uround}}$ \\
Function-norm stopping tolerance & \id{KINSetFuncNormTol} & $\sqrt[3]{\text{uround}}$ \\
Scaled-step stopping tolerance & \id{KINSetScaledSteptol} & $\sqrt[3]{\text{uround}^2}$ \\
Inequality constraints on solution & \id{KINSetConstraints} & \id{NULL} \\
\hline
\multicolumn{3}{|c|}{\bf KINSPGMR linear solver} \\
\hline
Max. number of restarts & \id{KINSpgmrSetMaxRestarts} & 0 \\
Preconditioner solve function & \id{KINSpgmrSetPrecSolveFn} & NULL \\
Preconditioner setup function & \id{KINSpgmrSetPrecSetupFn} & NULL \\
Data for preconditioner functions & \id{KINSpgmrSetPrecData} & NULL \\
Jacobian times vector function & \id{KINSpgmrSetJacTimesVecFn} & internal DQ \\
Data for Jacobian times vector function &\id{KINSpgmrSetJacData} & NULL \\ 
\hline
\end{tabular}
\end{table}

\subsubsection{Main solver optional input functions}
\index{optional input!solver|(}
The calls listed here can be executed in any order. However, if \id{KINSetErrFile} 
is to be called, that call should be first, in order to take effect for any later 
error message.
%%
%%
\index{error message}
\ucfunction{KINSetErrFile}
{
flag = KINSetErrFile(kin\_mem, errfp);
}
{
  The function \ID{KINSetErrFile} specifies the pointer to the file
  where all {\kinsol} messages should be directed.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[errfp] (\id{FILE *})
    pointer to output file.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{errfp} is \id{stderr}.

  Passing a value \id{NULL} disables all future error message output
  (except for the case in which the {\kinsol} memory pointer is \id{NULL}).
}
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSet}
{
flag = KINSet(kin\_mem, );
}
{
  The function \ID{KINSet}
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%


%%===================================================================================
%%
\subsubsection{Linear solver optional input functions}
%%
The {\kinspgmr} linear solver module allows for various optional 
inputs, which are described here.
\index{optional input!iterative linear solver|(}
\index{KINSPGMR@{\kinspgmr} linear solver!optional input|(}
\index{preconditioning!user-supplied|(}
The call to \id{KINSpgmr} is used to communicate the maximum dimension of the
Krylov subspace to be used (\id{maxl}). 

If preconditioning is to be done within the {\spgmr} method,
then the user must supply a preconditioner solve function \id{psolve}
and specify it through a call to \id{KINSpgmrSetPrecSolveFn}.
\index{KINSPGMR@{\kinspgmr} linear solver!preconditioner solve function}
%%
The evaluation and preprocessing of any Jacobian-related data needed
by the user's preconditioner solve function is done in the optional
user-supplied function \id{psetup}. Both of these functions are
fully specified in \S\ref{ss:user_fct_sim}.
If used, the \id{psetup} function should be specified through a call to
\id{KINSpgmrSetPrecSetupFn}.
\index{KINSPGMR@{\kinspgmr} linear solver!preconditioner setup function}
%%
Optionally, the {\kinspgmr} solver passes the pointer it receives through 
\id{KINSpgmrSetPrecData} to the preconditioner setup and solve functions.  
This allows the user to create an arbitrary structure with relevant problem data 
and access it during the execution of the user-supplied preconditioner functions
without using global data in the program.  
The pointer \id{prec\_data} may be identical to \id{f\_data}, if the latter was 
specified through \id{KINSetFdata}.

The \index{KINSPGMR@{\kinspgmr} linear solver!Jacobian approximation used by}
{\kinspgmr} solver requires a function to compute an approximation to the
product between the Jacobian matrix $J(t,y)$ and a vector $v$.
The user can supply his/her own Jacobian times vector approximation function, 
or use the difference quotient function \Id{KINSpgmrDQJtimes} 
\index{Jacobian approximation function!Jacobian times vector!difference quotient}
that comes with the {\kinspgmr} solver.
A user-defined Jacobian-vector function must be of type \id{KINSpgmrJtimesFn} and 
can be specified through a call to \id{KINSpgmrSetJacTimesVecFn} 
(see \S\ref{ss:user_fct_sim} for specification details).
%%
As with the preconditioner user data structure \id{prec\_data}, 
the user can specify, through a call to \id{KINSpgmrSetJacData}, a pointer to a 
user-defined data structure, \id{jac\_data}, which
the {\kinspgmr} solver passes to the Jacobian times vector function \id{jtimes} each
time it is called.  
The pointer \id{jac\_data} may be identical to \id{prec\_data} and/or \id{f\_data}.
%%
%%
\ucfunction{KINSpgmrSetMaxRestarts}
{
  flag = KINSpgmrSetMaxRestarts(kin\_mem, maxrs);
}
{
  The function \ID{KINSpgmrSetMaxRestarts} specifies the maximum
  number of times the {\spgmr} linear solver can be restarted.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[maxrs] (\id{int})
    maximum number of restarts
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_ILL\_INPUT]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional value has been successfuly set.
  \item[\Id{KINSPGMR\_ILL\_INPUT}]
    The maximum number of restarts specified is negative.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpgmrSetPrecSolveFn}
{
  flag = KINSpgmrSetPrecSolveFn(kin\_mem, psolve);
}
{
  The function \ID{KINSpgmrSet} specifies the preconditioner
  solve function.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[psolve] (\id{KINSpgmrPrecSolveFn})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional value has been successfuly set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{
   The function type \id{KINSpgmrPrecSolveFn} is described in \S\ref{ss:psolveFn}.
}
%%
%%
\ucfunction{KINSpgmrSetPrecSetupFn}
{
  flag = KINSpgmrSetPrecSetupFn(kin\_mem, psetup);
}
{
  The function \ID{KINSpgmrSetPrecSetupFn} specifies the preconditioner
  preprocessing function.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[psetup] (\id{KINSpgmrPrecSetupFn})
    user-defined preconditioner setup function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional value has been successfuly set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{
   The function type \id{KINSpgmrPrecSetupFn} is described in \S\ref{ss:precondFn}.
}
%%
%%
\ucfunction{KINSpgmrSetPrecData}
{
  flag = KINSpgmrSetPrecData(kin\_mem, prec\_data);
}
{
  The function \ID{KINSpgmrSetPrecData} specifies the data structure
  to be passed to the user supplied preconditioner setup and solve
  functions each time they are called.
}
{
  \begin{args}[prec\_data]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[prec\_data] (\id{void *})
     pointer to the user-defined data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional value has been successfuly set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%
\index{preconditioning!user-supplied|)}
%%
\index{Jacobian approximation function!Jacobian times vector!user-supplied}
\ucfunction{KINSpgmrSetJacTimesVecFn}
{
  flag = KINSpgmrSetJacTimesVecFn(kin\_mem, jtimes);
}
{
  The function \ID{KINSpgmrSetJacTimesFn} specifies the Jacobian-vector 
  function to be used.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[jtimes] (\id{KINSpgmrJacTimesVecFn})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional value has been successfuly set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{
  By default, {\kinspgmr} uses the difference quotient function \id{KINSpgmrDQJtimes}.
  If \id{NULL} is passed to \id{jtimes}, this default function is used.

  The function type \id{KINSpgmrJacTimesVecFn} is described in \S\ref{ss:jtimesFn}.
}
%%
%%
\ucfunction{KINSpgmrSetJacData}
{
  flag = KINSpgmrSetJacData(kin\_mem, jac\_data);
}
{
  The function \ID{KINSpgmrSetJacData} specifies the data structure
  to be passed to the user supplied Jacobian-vector
  function each time it is called.
}
{
  \begin{args}[jac\_data]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[jac\_data] (\id{void *})
     pointer to the user-defined data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional value has been successfuly set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%


%%==============================================================================
\subsection{Optional output functions}\label{ss:optional_output}
%%==============================================================================

{\kinsol} provides an extensive list of functions that can be used to obtain
solver performance information.
Table \ref{t:optional_output} lists all optional output functions in {\kinsol},
which are then described in detail in the remainder of this section.

\begin{table}
\centering
\caption{Optional outputs from {\kinsol} and {\kinspgmr}}
\label{t:optional_output}
\medskip
\begin{tabular}{|l|l|}\hline
{\bf Optional output} & {\bf Function name} \\
\hline
\multicolumn{2}{|c|}{\bf KINSOL main solver} \\
\hline
Size of {\kinsol} real and integer workspaces & \id{KINGetWorkSpace} \\
Niumber of function evaluations  & \id{KINGetNumFuncEvals} \\
Number of nonlinar iterations & \id{KINGetNumnolinSolvIters} \\
Number of $\beta$-condition failures & \id{KINGetNumBetacondFails} \\
Number of backtrack operations & \id{KINGetNumBacktrackOps} \\
Scaled norm of $F$ & \id{KINGetFuncNorm} \\
Scaled norm of the step & \id{KINGetStepLength} \\
\hline
\multicolumn{2}{|c|}{\bf KINSPGMR linear solver} \\
\hline
Size of {\kinspgmr} real and integer workspaces & \id{KINSpgmrGetWorkSpace} \\
No. of linear iterations & \id{KINSpgmrGetNumLinIters} \\
No. of linear convergence failures & \id{KINSpgmrGetNumConvFails} \\
No. of preconditioner evaluations & \id{KINSpgmrGetNumPrecEvals} \\
No. of preconditioner solves & \id{KINSpgmrGetNumPrecSolves} \\
No. of Jacobian-vector product evaluations & \id{KINSpgmrGetNumJtimesEvals} \\
No. of fct. calls for finite diff. Jacobian-vector evals. & \id{KINSpgmrGetNumRhsEvals} \\ 
Last return from a {\kinspgmr} function & \id{KINSpgmrGetLastFlag} \\ 
\hline
\end{tabular}
\end{table}


%%==============================================================================
\subsubsection{Main solver optional output functions}
%%==============================================================================
\index{optional output!solver|(}
%%
{\kinsol} provides several user-callable functions that can be used to obtain
different quantities that may be of interest to the user, such as solver workspace
requirements and solver performance statistics.
These optional output functions are described next.
%%
\index{memory requirements!KINSOL@{\kinsol} solver}
%%
\ucfunction{KINGetWorkSpace}
{
  flag = KINGetWorkSpace(kin\_mem, \&lenrw, \&leniw);
}
{
  The function \ID{KINGetWorkSpace} returns the
  {\kinsol} integer and real workspace sizes.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lenrw] (\id{long int})
    the number of \id{realtype} values in the {\kinsol} workspace.
  \item[leniw] (\id{long int})
    the number of integer values in the {\kinsol} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  In terms of the problem size $N$ the actual size of the real workspace 
  is $5 N$ \id{realtype} words.
}
%%
%%
\ucfunction{KINGet}
{
  flag = KINGet(kin\_mem, \&);
}
{
  The function \ID{KINGetWorkSpace} returns the
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGet}
{
  flag = KINGet(kin\_mem, \&);
}
{
  The function \ID{KINGetWorkSpace} returns the
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGet}
{
  flag = KINGet(kin\_mem, \&);
}
{
  The function \ID{KINGetWorkSpace} returns the
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGet}
{
  flag = KINGet(kin\_mem, \&);
}
{
  The function \ID{KINGetWorkSpace} returns the
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGet}
{
  flag = KINGet(kin\_mem, \&);
}
{
  The function \ID{KINGetWorkSpace} returns the
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGet}
{
  flag = KINGet(kin\_mem, \&);
}
{
  The function \ID{KINGetWorkSpace} returns the
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[] (\id{})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
%%==============================================================================
\subsubsection{Linear solver optional output functions}\label{sss:linsolv_io}
%%==============================================================================
The functions available to access various optional outputs that describe the 
performance of the {\kinspgmr} module are described below.

\noindent{\bf SPGMR Linear solver.}
\index{optional output!iterative linear solver|(}
\index{KINSPGMR@{\kinspgmr} linear solver!optional output|(} 
%%
\index{KINSPGMR@{\kinspgmr} linear solver!memory requirements|(} 
\index{memory requirements!KINSPGMR@{\kinspgmr} linear solver|(}
%%
\ucfunction{KINSpgmrGetWorkSpace}
{
  flag = KINSpgmrGetWorkSpace(kin\_mem, \&lenrwSG, \&leniwSG);
}
{
  The function \ID{KINSpgmrGetWorkSpace} returns the
  {\kinspgmr} real and integer workspace sizes.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lenrwSG] (\id{long int})
    the number of \id{realtype} values in the {\kinspgmr} workspace.
  \item[leniwSG] (\id{long int})
    the number of integer values in the {\kinspgmr} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{
  In terms of the problem size $N$ and maximum subspace size \id{maxl}, 
  the actual size of the real workspace is
  (\id{maxl}$+ 5)*N +$ \id{maxl} $*($ \id{maxl}$ + 4) + 1$ \id{realtype}
  words.  (In a parallel setting, this value is global --- summed over
  all processors.)
}
%%
\index{KINSPGMR@{\kinspgmr} linear solver!memory requirements|)} 
\index{memory requirements!KINSPGMR@{\kinspgmr} linear solver|)}
%%
%%
\ucfunction{KINSpgmrGetNumLinIters}
{
  flag = KINSpgmrGetNumLinIters(kin\_mem, \&nliters);
}
{
  The function \ID{KINSpgmrGetNumLinIters} returns the
  cumulative number of linear iterations.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nliters] (\id{long int})
    the current number of linear iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpgmrGetNumConvFails}
{
  flag = KINSpgmrGetNumConvFails(kin\_mem, \&nlcfails);
}
{
  The function \ID{KINSpgmrGetNumConvFails} returns the
  cumulative number of linear convergence failures.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nlcfails] (\id{long int})
    the current number of linear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpgmrGetNumPrecEvals}
{
  flag = KINSpgmrGetNumPrecEvals(kin\_mem, \&npevals);
}
{
  The function \ID{KINSpgmrGetNumPrecEvals} returns the
  number of preconditioner evaluations, i.e., the number of 
  calls made to \id{psetup} with \id{jok=FALSE}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[npevals] (\id{long int})
    the current number of calls to \id{psetup}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpgmrGetNumPrecSolves}
{
  flag = KINSpgmrGetNumPrecSolves(kin\_mem, \&npsolves);
}
{
  The function \ID{KINSpgmrGetNumPrecSolves} returns the
  cumulative number of calls made to the preconditioner 
  solve function, \id{psolve}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[npsolves] (\id{long int})
    the current number of calls to \id{psolve}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpgmrGetNumJtimesEvals}
{
  flag = KINSpgmrGetNumJtimesEvals(kin\_mem, \&njvevals);
}
{
  The function \ID{KINSpgmrGetNumJtimesEvals} returns the
  cumulative number made to the Jacobian-vector function,
  \id{jtimes}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[njvevals] (\id{long int})
    the current number of calls to \id{jtimes}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpgmrGetNumRhsEvals}
{
  flag = KINSpgmrGetNumRhsEvals(kin\_mem, \&nfevalsSG);
}
{
  The function \ID{KINSpgmrGetNumRhsEvals} returns the
  number of calls to the user right-hand side function for
  finite difference Jacobian-vector product approximation.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nfevalsSG] (\id{long int})
    the number of calls to the user right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{
  The value \id{nfevalsSG} is incremented only if the default 
  \id{KINSpgmrDQJtimes} difference quotient function is used.
}
%%
%%
\ucfunction{KINSpgmrGetLastFlag}
{
  flag = KINSpgmrGetLastFlag(kin\_mem, \&flag);
}
{
  The function \ID{KINSpgmrGetLastFlag} returns the
  last return value from a {\kinspgmr} routine. 
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[flag] (\id{int})
    the value of the last return flag from a {\kinspgmr} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPGMR\_LMEM\_NULL]
  \item[\Id{KINSPGMR\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPGMR\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPGMR\_LMEM\_NULL}]
    The {\kinspgmr} linear solver has not been initialized.
  \end{args}
}
{
  If the {\kinspgmr} setup function failed (\id{KINode} returned
  \id{KIN\_LSETUP\_FAIL}), \id{flag} contains the return value of the
  preconditioner setup function \id{psetup}.

  If the {\kinspgmr} solve function failed (\id{KINode} returned
  \id{KIN\_LSETUP\_FAIL}), \id{flag} contains the error return flag from
  \id{SpgmrSolve} and will be one of:
 \id{SPGMR\_CONV\_FAIL}, indicating a failure to converge;
 \id{SPGMR\_QRFACT\_FAIL}, indicating a singular matrix found during the QR
  factorization;
 \id{SPGMR\_PSOLVE\_FAIL\_REC}, indicating that the preconditioner solve function
 \id{psolve} failed recoverably;
  \id{SPGMR\_MEM\_NULL}, indicating that the {\spgmr} memory is \id{NULL};
  \id{SPGMR\_ATIMES\_FAIL}, indicating a failure in the Jacobian times vector
  function;
  \id{SPGMR\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
  function \id{psolve} failed unrecoverably;
  \id{SPGMR\_GS\_FAIL}, indicating a failure in the Gram-Schmidt procedure; 
  or \id{SPGMR\_QRSOL\_FAIL}, indicating that the matrix $R$ was found to be
  singular during the QR solve phase.
}
%%
%%
\index{KINSPGMR@{\kinspgmr} linear solver!optional output|)} 
\index{optional output!iterative linear solver|)}

%%==============================================================================
\section{User-supplied functions}\label{ss:user_fct_sol}
%%==============================================================================

The user-supplied functions consist of one function defining the nonlinear system, 
(optionally) a function that provides Jacobian related information for the linear
solver, and (optionally) one or two functions that define the preconditioner for 
use in the {\spgmr} algorithm. 

%%==============================================================================
\subsection{Problem-defining function} \label{ss:sysFn}
%%==============================================================================
\index{problem-defining function}

The user must provide a function of type \ID{KINSysFn} defined as follows:
\usfunction{KINSysFn}
{
  typedef void (*KINSysFn)(N\_Vector y, N\_Vector fval, void *f\_data );
}
{
  This function computes $F(y)$ for a given value of the vector $y$.
}
{
  \begin{args}[f\_data]
  \item[y]
    is the current value of the variable vector, $y$.
  \item[fval]
    is the output vector $F(y)$.
  \item[f\_data]
    is a pointer to user data --- the same as the \Id{f\_data}      
    parameter passed to \id{KINSetFdata}.   
  \end{args}
}
{
  A \id{KINSysFn} function type does not have a return value.
}
{
Allocation of memory for \id{fval} is handled within {\kinsol}.
}



%%==============================================================================
\subsection{Jacobian information (SPGMR matrix-vector product)}
\label{ss:jtimesFn}
%%==============================================================================

%%==============================================================================
\subsection{Preconditioning (SPGMR linear system solution)} \label{ss:psolveFn}
%%==============================================================================

%%==============================================================================
\subsection{Preconditioning (SPGMR Jacobian data)}\label{ss:precondFn}
%%==============================================================================

%%==============================================================================
\section{Preconditioner modules}\label{ss:preconds}
%%==============================================================================
The efficiency of Krylov iterative methods for the solution of linear systems 
can be greatly enhanced through preconditioning. For problems in which the 
user cannot define a more effective, problem-specific preconditioner,
{\kinsol} provides a band-block-diagonal preconditioner module {\kinbbdpre}.

%%==============================================================================
\subsection{A parallel band-block-diagonal preconditioner module}
\label{sss:kinbbdpre}
%%==============================================================================
.......
.......
......

%%==============================================================================
\section{FKINSOL, a {\F}-{\C} interface module}\label{ss:fcmix}
%%==============================================================================

The {\fkinsol} interface module is a package of {\C} functions which support
the use of the {\kinsol} solver, for the solution nonlinear systems
$F(y)=0$, in a mixed {\F}/{\C} setting.  While {\kinsol} is written
in {\C}, it is assumed here that the user's calling program and
user-supplied problem-defining routines are written in {\F}.
This package provides the necessary interface to {\kinsol} for both the
serial and the parallel {\nvector} implementations.

%%==============================================================================
\subsection{FKINSOL routines}
%%==============================================================================



%%==============================================================================
\subsubsection{Important note on portability}
%%==============================================================================
\index{portability!Fortran}

In this package, the names of the interface functions, and the names of
the {\F} user routines called by them, appear as dummy names
which are mapped to actual values by a series of definitions in the
header files \id{fkinsol.h} and \id{fkinbbd.h}.
By default, those mapping definitions depend in turn on the {\C} macro
\id{F77\_FUNC} defined in the header file \id{config.h} by \id{configure}. However,
the set of flags --- \Id{SUNDIALS\_CASE\_UPPER}, \Id{SUNDIALS\_CASE\_LOWER},
\Id{SUNDIALS\_UNDERSCORE\_NONE}, \Id{SUNDIALS\_UNDERSCORE\_ONE}, and
\Id{SUNDIALS\_UNDERSCORE\_TWO} can be explicitly defined in \id{config.h} when
configuring {\sundials} via the \id{--with-f77underscore} and
\id{--with-f77case} options to override the default behavior if necessary
(see Chapter \ref{s:install}). Either way, the names into which the dummy names
are mapped are in upper or lower case and have up to two underscores appended.

The user must also ensure that variables in the user {\F} code are
declared in a manner consistent with their counterparts in {\kinsol}.
All real variables must be declared as \id{REAL}, \id{DOUBLE PRECISION},
or perhaps as \id{REAL*}{\em n}, where {\em n} denotes the number of bytes,
depending on whether {\kinsol} was built in single, double or extended precision 
(see Chapter \ref{s:install}). Moreover, some of the {\F} integer variables
must be declared as \id{INTEGER*4} or \id{INTEGER*8} according to the 
{\C} type \id{long int}. These integer variables include: the array
of integer optional inputs and outputs (\id{IOPT}), problem dimensions (\id{NEQ},
\id{NLOCAL}, \id{NGLOBAL}), and Jacobian half-bandwidths (\id{MU}, \id{ML},
\id{MUDQ}, and \id{MLDQ}). This is particularly important when using
{\kinsol} and the {\fkinsol} package on 64-bit architectures.


%%==============================================================================
\subsection{FKINSOL optional input and output}
%%==============================================================================
\index{FKINSOL@{\fkinsol} interface module!optional input and output}

In order to keep the number of user-callable {\fkinsol} interface routines to
a minimum, optional inputs and outputs to the {\kinsol} solver and to related 
modules are not accessed through individual functions, but rather through a
pair of arrays, \Id{IOPT} of integer type and \Id{ROPT} of real type.
Table \ref{t:fkinsol_io} lists the entries in these two arrays and specifies the
{\fkinsol} user-callable routine which sets/accesses the corresponding optional
variable, as well as the {\kinsol} optional function which is actually called.
For more details on the optional inputs and outputs, see \S\ref{ss:optional_input}
and \S\ref{ss:optional_output}.

%%==============================================================================
\subsection{Usage of the FKINSOL interface module}\label{ss:fkinsol_usage}
%%==============================================================================

%%==============================================================================
\subsection{Usage of the FKINBBD interface to KINBBDPRE}
%%==============================================================================
