%===================================================================================
\chapter{Using CVODES for Adjoint Sensitivity Analysis}\label{s:adjoint}
%===================================================================================

This chapter describes the use of {\cvodes} to compute sensitivities of derived 
functions using adjoint sensitivity analysis. As mentioned before, the adjoint
sensitivity module of {\cvodes} provides the infrastructure for integrating
backward in time any system of ODEs that depends on the solution of the original
IVP, by providing various interfaces to the main {\cvodes} integrator, as well 
as several supporting user-callable functions. For this reason, in the following
sections we refer to the {\em backward problem} and not to the 
{\em adjoint problem} when discussing details relevant to the ODEs that
are integrated backward in  time. The backward problem can be the adjoint problem
(\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}), and
can be augmented with some quadrature differential equations.

{\cvodes} uses various constants for both input and output.  These are
defined as needed in this chapter, but for convenience are also listed
separately in Appendix \ref{c:constants}.

We begin with a brief overview, in the form of a skeleton user program.
Following that are detailed descriptions of the interface to the
various user-callable functions and of the user-supplied functions that were not already
described in Chapter \ref{s:simulation}.

%%
%%----------------------------------------------------------------------
%%----------------------------------------------------------------------
\section{A skeleton of the user's main program}
\label{ss:skeleton_adj}
%%---------------------------------------------------------------------
%%----------------------------------------------------------------------
%%

The following is a skeleton of the user's main program as an application of
{\cvodes}. The user program is to have these steps in the order indicated, 
unless otherwise noted. For the sake of brevity, we defer many of the details to 
the later sections.
As in \S\ref{ss:skeleton_sim}, most steps are independent of the {\nvector}
implementation used; where this is not the case, usage specifications are given for the
two implementations provided with {\cvodes}: steps marked with {\p} correspond to 
{\nvecp}, while steps marked with {\s} correspond to {\nvecs}.

\index{User main program!Adjoint sensitivity analysis}
\begin{Steps}

\item
  {\bf Include necessary header files}
  
  The \id{cvodes.h} header file also defines additional types, constants, and
  function prototypes for the adjoint sensitivity module user-callable functions.
  In addition, the main program should include an {\nvector} 
  implementation header file (\id{nvector\_serial.h} or \id{nvector\_parallel.h}
  for the two implementations provided with {\cvodes}) and, if Newton iteration 
  was selected, the main header file of the desired linear solver module.

\item
  \textcolor{gray}{\bf {\p} Initialize MPI}

  \vspace{0.2in}\centerline{\bf Forward problem}

\item
  \textcolor{gray}{\bf Set problem dimensions for the forward problem}

\item
  \textcolor{gray}{\bf Set initial conditions for the forward problem}

\item
  \textcolor{gray}{\bf Create {\cvodes} object for the forward problem}

\item
  \textcolor{gray}{\bf Allocate internal memory for the forward problem}

\item
  \textcolor{gray}{\bf Specify integration tolerances for forward problem}

\item
  \textcolor{gray}{\bf Set optional inputs for the forward problem}

\item
  \textcolor{gray}{\bf Attach linear solver module for the forward problem}

\item
  \textcolor{gray}{\bf Set linear solver optional inputs for the forward problem}

\item
  {\bf Allocate space for the adjoint computation}

  Call \Id{CVodeAdjInit}\id{()} to allocate memory for the 
  combined forward-backward problem (see \S\ref{sss:cvadjinit} for more details).
  This call requires \id{Nd}, the number of steps between two consecutive checkpoints.
  \Id{CVodeAdjInit} also specifies the type of interpolation used 
  (see \S\ref{ss:checkpointing}).

\item
  {\bf Integrate forward problem}

  Call \Id{CVodeF}, a wrapper for the {\cvodes} main integration
  function \id{CVode}, either in \Id{CV\_NORMAL} mode to the time 
  \id{tout} or in \Id{CV\_ONE\_STEP} mode inside a loop (if intermediate
  solutions of the forward problem are desired (see \S\ref{sss:cvsolvef})).
  The final value of \id{tret}, denoted \id{tfinal}, is then
  the maximum allowable value for the endpoint $t_1$.

  \vspace{0.2in}\centerline{\bf Backward problem(s)}

 \item \label{i:back_start}
   {\bf Set problem dimensions for the backward problem}
   
   {\s} set \id{NB}, the number of variables in the backward problem \\
   {\p} set \id{NB} and \id{NBlocal}

\item
  {\bf Create the backward problem}

  Call \Id{CVodeCreateB}, a wrapper for \id{CVodeCreate}, to
  create the {\cvodes} memory block the new backward problem. Unlike \id{CVodeCreate}, 
  the function \id{CVodeCreateB} does not return a pointer to the newly created 
  memory block (see \S\ref{sss:cvinitb}). Instead, this pointer is attached to 
  the internal adjoint memory  block (created by \id{CVodeAdjInit} and returns an identifier 
  that user must later specify in any actions on the newly created 
  backward problem.

\item
  {\bf Allocate memory for the backward problem}

  Call \Id{CVodeInitB} or \Id{CVodeInitBS} (when the backward problem depends on the
  forward sensitivities). The two function are actually wrappers for \id{CVodeInit} 
  and allocate internal memory, specify problem and initialize {\cvodes} 
  at \id{tB0} for the backward problem (see \S\ref{sss:cvinitb}).

\item 
  {\bf Specify integration tolerances for backward problem}
  
  Call \id{CVodeSStolerancesB}\id{(...);} or \id{CVodeSVtolerancesB}\id{(...);}
  to specify a scalar relative tolerance and scalar absolute tolerance or
  scalar relative tolerance and a vector of absolute tolerances, respectively.
  The functions are wrappers for \id{CVodeSStolerances}\id{(...);} and
  \id{CVodeSVtolerances}\id{(...);} but they require an extra argument \id{which},
  the identifier of the backward problem returned by \id{CVodeCreateB}.
  See \S\ref{sss:cvtolerances_b} for more information.


\item
  {\bf Set optional inputs for the backward problem}

  Call \id{CVodeSet*B} functions to change from their default values
  any optional inputs that control the behavior of {\cvodes}. Unlike
  their counterparts for the forward problem, these functions take an
  extra argument \id{which}, the identifier of the backward problem returned 
  by \id{CVodeCreateB} (see \S\ref{ss:optional_input_b}).


\item \label{i:lin_solverB}
  {\bf Attach linear solver module for the backward problem}

  Initialize the linear solver module 
  for the backward problem by calling the appropriate wrapper
  function: \id{CVDenseB}, \id{CVBandB}, \id{CVLapackDenseB}, \id{CVLapackBandB},
  \id{CVDiagB}, \id{CVodeSpgmrB}, \id{CVodeSpbcgB}, or \id{CVodeSptfqmr} (see \S\ref{sss:lin_solv_b}). 
  Note that it is not required to use the same linear solver module for both the forward 
  and the backward problems; for example, the forward problem could be solved
  with the {\cvdense} linear solver and the backward problem with {\cvspgmr}.

\item \label{i:quadB}
  {\bf Initialize quadrature calculation}

  If additional quadrature equations must be evaluated, 
  call \id{CVodeQuadInitB} or \id{CVodeQuadInitBS} (if quadrature depends also on the
  forward sensitivities as shown in \S\ref{sss:cvquadinitb}. These functions are
  wrapper around \id{CVodeQuadInit} and can be used to initialize and allocate 
  memory for quadrature integration. Optionally, call \id{CVodeSetQuad*B} functions 
  to change from their default values optional inputs that control the integration 
  of quadratures during the backward phase.

\item
  {\bf Integrate backward problem}

  Call \Id{CVodeB}, a second wrapper around the {\cvodes} main integration
  function \id{CVode}, to integrate the backward problem from \id{tB0}
  (see \S\ref{sss:cvsolveb}). This function can be called either in \id{CV\_NORMAL}
  or \id{CV\_ONE\_STEP} mode. Typically, \id{CVodeB} will be called in \id{CV\_NORMAL}
  mode with an end time equal to the initial time of the forward problem.

\item \label{i:back_end}
  {\bf Extract quadrature variables}

  If applicable, call \Id{CVodeGetQuadB}, a wrapper around \id{CVodeGetQuad},
  to extract the values of the quadrature variables at the time returned
  by the last call to \id{CVodeB}.

\item
  {\bf Deallocate memory}

  Upon completion of the backward integration, call all necessary deallocation
  functions. These include appropriate destructors for the vectors 
  \id{y} and \id{yB}, a call to \id{CVodeFree} to free the {\cvodes} memory block 
  for the forward problem, and a call to \id{CVodeAdjFree} (see \S\ref{sss:cvadjinit}) to free 
  the memory allocated for the combined problem. 
  Note that \id{CVodeAdjFree} also deallocates the {\cvodes} memory for the backward problems.

\item
  \textcolor{gray}{\bf Finalize MPI}

  {\p} If {\mpi} was initialized by the user main program, call \id{MPI\_Finalize();}.

\end{Steps}

The above user interface to the adjoint sensitivity module in {\cvodes} was motivated by
the desire to keep it as close as possible in look and feel to the one for ODE IVP 
integration. Note that if steps (\ref{i:back_start})-(\ref{i:back_end}) are not present, 
a program with the above structure will have the same functionality as one described in
\S\ref{ss:skeleton_sim} for integration of ODEs, albeit with some overhead due to 
the checkpointing scheme.

%%
%%-------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------
\section{User-callable functions for adjoint sensitivity analysis}
%%-------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------
%%

%%-------------------------------------------------------------------------------
\subsection{Adjoint sensitivity allocation and deallocation functions}
\label{sss:cvadjinit}
%%-------------------------------------------------------------------------------

After the setup phase for the forward problem, but before the call
to \id{CVodeF}, memory for the combined forward-backward problem must be
allocated by a call to the function \id{CVodeAdjInit}.
The form of the call to this function is
%%
%%
\ucfunction{CVodeAdjInit}
{
  flag = CVodeAdjInit(cvode\_mem, Nd, interpType);
}
{
  The function \ID{CVodeAdjInit} updates {\cvodes} memory block by allocating 
  the internal memory needed for backward integration.
  Space is allocated for the $N_d$ interpolation data points and a linked 
  list of checkpoints is initialized.
}
{
  \begin{args}[interpType]
  \item[cvode\_mem] (\id{void *}) 
    is the {\cvodes} memory block returned by a previous call to \id{CVodeCreate}.
  \item[Nd] (\id{long int}) 
    is the number of integration steps between two consecutive checkpoints.
  \item[interpType] (\id{int})
    specifies the type of interpolation used and can be \Id{CV\_POLYNOMIAL}
    or \Id{CV\_HERMITE}, indicating variable-degree polynomial and cubic Hermite
    interpolation, respectively (see \S\ref{ss:checkpointing}).
  \end{args}
}
{
   The return value \id{flag} of \id{CVodeAdjInit} is one of:
   \begin{args}[CV\_ILL\_INPUT]
   \item[\Id{CV\_SUCCESS}] 
     \id{CVodeAdjInit} was successful.
   \item[\Id{CV\_MEM\_FAIL}]
     A memory allocation request has failed.
   \item[CV\_MEM\_NULL] 
     \id{cvode\_mem} was NULL.
   \item[\Id{CV\_ILL\_INPUT}]
     One of the parameters was invalid: \id{Nd} was not positive or \id{interpType}
     is not one of the \id{CV\_POLYNOMIAL} or \id{CV\_HERMITE}.
   \end{args}
}
{
  The user must set \id{Nd} so that all data needed for interpolation of the 
  forward problem solution between two checkpoints fits in memory. \id{CVodeAdjInit}
  attempts to allocate space for $(2$\id{Nd}$+3)$ variables of type \id{N\_Vector}.

  If an error occured, \id{CVodeAdjInit} also sends an error to the
  error handler function.
}
%%
%%
\ucfunction{CVodeAdjFree}
{
  CVodeAdjFree(cvode\_mem);
}
{
  The function \ID{CVodeAdjFree} frees the memory related to backward integration
  allocated by a previous call to \id{CVodeAdjInit}.
}
{
  The only argument is  is the {\cvodes} memory block returned by a previous call 
  to \id{CVodeCreate}.
}
{
  The function \id{CVodeAdjFree} has no return value.
}
{
  This function frees all memory allocated by \id{CVodeAdjInit}. This includes workspace memory, 
  the linked list of checkpoints, memory for the interpolation data, as well as the {\cvodes} memory 
  for the backward integration phase.
}
%%
%%

%%---------------------------------------------------------------------
\subsection{Forward integration function}
\label{sss:cvsolvef}
%%---------------------------------------------------------------------

The function \ID{CVodeF} is very similar to the {\cvodes} function \id{CVode}
(see \S\ref{sss:cvode}) in that it integrates the solution of the forward
problem and returns the solution in \id{y}. At the same time, however, 
\id{CVodeF} stores checkpoint data every \id{Nd} integration steps. \id{CVodeF} 
can be called repeatedly by the user.
%%
The call to this function has the form
%%
\ucfunction{CVodeF}
{
  flag = CVodeF(cvode\_mem, tout, yret, tret, itask, ncheck);
}
{
  The function \ID{CVodeF} integrates the forward problem over an interval in $t$
  and saves checkpointing data.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[tout] (\id{realtype})
    the next time at which a computed solution is desired.
  \item[yret] (\id{N\_Vector})
    the computed solution vector $y$.
  \item[tret] (\id{realtype *})
    the time reached by the solver.
  \item[itask] (\id{int})
    \index{itask@\texttt{itask}}
    \index{output mode}
    a flag indicating the job of the solver for the next step. 
    The \Id{CV\_NORMAL} task is to have the solver take internal steps until   
    it has reached or just passed the user-specified \id{tout}
    parameter. The solver then interpolates in order to   
    return an approximate value of $y($\id{tout}$)$. 
    The \Id{CV\_ONE\_STEP} option tells the solver to just take one internal step  
    and return the solution at the point reached by that step. 
  \item[ncheck] (\id{int *})
    the number of check points stored so far.
  \end{args}
}
{
  On return, \id{CVodeF} returns the vector \id{yret} and a corresponding 
  independent variable value $t=$\id{*tret}, such that \id{yret} is the computed 
  value of $y(t)$.. Additionally, it returns in \id{ncheck} the number of checkpoints saved.
  The return value \id{flag} (of type \id{int}) will be one of the following.
  For more details see \S\ref{sss:cvode}.
  \begin{args}[CV\_TOO\_MUCH\_WORK]
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeF} succeeded.
  \item[\Id{CV\_TSTOP\_RETURN}]
    \id{CVodeF} succeeded by reaching the optional stopping point.
  \item[\Id{CV\_NO\_MALLOC}]
    The function \id{CVodeInit} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}]
    One of the inputs to \id{CVodeF} is illegal.
  \item[\Id{CV\_TOO\_MUCH\_WORK}] 
    The solver took \id{mxstep} internal steps but could not reach tout. 
  \item[\Id{CV\_TOO\_MUCH\_ACC}] 
    The solver could not satisfy the accuracy demanded by the user for some 
    internal step.
  \item[\Id{CV\_ERR\_FAILURE}]
    Error test failures occurred too many times during one 
    internal time step or occurred with $|h| = h_{min}$.
  \item[\Id{CV\_CONV\_FAILURE}] 
    Convergence test failures occurred too many times during 
    one internal time step or occurred with $|h| = h_{min}$.             
  \item[\Id{CV\_LSETUP\_FAIL}] 
    The linear solver's setup function failed in an unrecoverable manner.
  \item[\Id{CV\_LSOLVE\_FAIL}] 
    The linear solver's solve function failed in an unrecoverable manner.
  \item[\Id{CV\_NO\_ADJ}]
     The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_MEM\_FAIL}]
    A memory allocation request has failed (in an attempt to allocate space
    for a new checkpoint).
  \end{args} 
}
{
  All failure return values are negative and therefore a test \id{flag}$< 0$
  will trap all \id{CVodeF} failures.

  At this time, \id{CVodeF} stores checkpoint information in memory only. 
  Future versions will provide for a safeguard option of dumping checkpoint
  data into a temporary file as needed. The data stored at each checkpoint is basically
  a snapshot of the {\cvodes} internal memory block and contains enough information
  to restart the integration from that time and to proceed with the same step size and
  method order sequence as during the forward integration.
  
  In addition, \id{CVodeF} also stores interpolation data between consecutive checkpoints
  so that, at the end of this first forward integration phase, interpolation information
  is already available from the last checkpoint forward. In particular,
  if no check points were necessary, there is no need for the second forward integration phase.

  {\warn}It is illegal to change the integration tolerances between consecutive calls
  to \id{CVodeF}, as this information is not captured in the checkpoints data.
}  

%%---------------------------------------------------------------------
\subsection{Backward problem initialization functions}
\label{sss:cvinitb}
%%---------------------------------------------------------------------

The functions \id{CVodeCreateB} and \id{CVodeInitB} (or \id{CVodeInitBS}) must be 
called in the order listed. They instantiate a {\cvodes} solver object, provide problem 
and solution specifications, and allocate internal memory for the backward problem.
%%
%%
\ucfunction{CVodeCreateB}
{
  flag = CVodeCreateB(cvode\_mem, \&which);
}
{
  The function \ID{CVodeCreateB} instantiates a {\cvodes} solver object and specifies 
  the solution method for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeInit}.
  \item[which] (\id{int})
    contains the identifier assigned by {\cvodes} for the newly created backward 
    problem. Any call to \id{CVode*B} functions requires such an identifier.
  \end{args}
}
{
   The return \id{flag} (of type \id{int}) is one of:
   \begin{args}[CV\_MEM\_FAIL]
   \item[\Id{CV\_SUCCESS}]
     The call to \id{CVodeCreateB} was successful.
   \item[\Id{CV\_MEM\_NULL}]
     The \id{cvode\_mem} was \id{NULL}.
   \item[\Id{CV\_NO\_ADJ}]
     The function \id{CVodeAdjInit} has not been previously called.
   \item[\Id{CV\_MEM\_FAIL}]
     A memory allocation request has failed.
   \end{args}
}
{}
%%
%%
The function \id{CVodeInitB} is essentially a call to \id{CVodeInit} with some 
particularization for backward integration as described below. It is essentially 
a wrapper for \id{CVodeInit} and so all details given for \id{CVodeReInit} in 
\S\ref{sss:cvreinit} apply.

\ucfunction{CVodeInitB}
{
  flag = CVodeInitB(cvode\_mem, which, rhsB, tB0, yB0);
}
{
  The function \ID{CVodeInitB} provides problem specification, allocates internal memory, 
  and initializes the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeInit}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[rhsB] (\Id{CVRhsFnB})
    is the {\C} function which computes $fB$, the right-hand side of the 
    backward ODE problem. This function has the form 
    \id{rhsB(t, y, yB, yBdot, user\_dataB)} (for full details see \S\ref{ss:user_fct_adj}).
  \item[tB0] (\id{realtype})
    specifies the endpoint where final conditions are provided for the 
    backward problem.
  \item[yB0] (\id{N\_Vector})
    is the final value of the backward problem. 
  \end{args}
}
{
  The return \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeInitB} was successful.
  \item[\Id{CV\_NO\_MALLOC}]
    The function \id{CVodeInit} has not been previously called.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_BAD\_TB0}]
    The final time \id{tB0} was outside the interval over which the forward problem
    was solved.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, 
    \id{yB0} or \id{rhsB} was \id{NULL}.
  \end{args}
}
{
  The memory allocated by \id{CVodeInitB} is deallocated by the function 
  \id{CVodeAdjFree}.
}

For the case when backward problem also depends on the forward sensitivities, user
must call \id{CVodeInitBS} instead of \id{CVodeInitB}. Only the third argument of each function
differs from that of another.

\ucfunction{CVodeInitBS}
{
  flag = CVodeInitBS(cvode\_mem, which, rhsBS, tB0, yB0);
}
{
  The function \ID{CVodeInitBS} provides problem specification, allocates internal memory, 
  and initializes the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeInit}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[rhsBS] (\Id{CVRhsFnBS})
    is the {\C} function which computes $fB$, the right-hand side of the 
    backward ODE problem. This function has the form 
    \id{rhsBS(t, y, yS, yB, yBdot, user\_dataB)} 
    (for full details see \S\ref{ss:user_fct_adj}).
  \item[tB0] (\id{realtype})
    specifies the endpoint where final conditions are provided for the 
    backward problem.
  \item[yB0] (\id{N\_Vector})
    is the final value of the backward problem. 
  \end{args}
}
{
  The return \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeInitB} was successful.
  \item[\Id{CV\_NO\_MALLOC}]
    The function \id{CVodeInit} has not been previously called.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_BAD\_TB0}]
    The final time \id{tB0} was outside the interval over which the forward problem
    was solved.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, 
    or \id{yB0} or \id{rhsB} was \id{NULL},
    or sensitivities has not been active during the forward integration.
  \end{args}
}
{
  The memory allocated by \id{CVodeInitBS} is deallocated by the function 
  \id{CVodeAdjFree}.  
}

Note that \id{CVodeReInitB} is essentially a wrapper for \id{CVodeReInit}
and so all details given for \id{CVodeReInit} in \S\ref{sss:cvreinit}
apply.\index{reinitialization} Also note that \id{CVodeReInitB} can be called to reinitialize
the backward problem, even it has been initialized with the sensitivity-dependent version
routine \id{CVodeInitBS}.

The call to the \id{CVodeReInitB} function has the form
%%
%%
\ucfunction{CVodeReInitB}
{
  flag = CVodeReInitB(cvode\_mem, which, tB0, yB0)
}
{
  The function \id{CVodeReInitB} reinitializes {\cvodes} the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to {\cvodes} memory block returned by \id{CVodeInit}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[tB0] (\id{realtype})
    specifies the endpoint where final conditions are provided for the 
    backward problem.
  \item[yB0] (\id{N\_Vector})
    is the final value of the backward problem. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeReInitB} was successful.
  \item[\Id{CV\_NO\_MALLOC}]
    The function \id{CVodeInit} has not been previously called.
  \item[\Id{CV\_MEM\_NULL}] 
    The \id{cvode\_mem} memory block was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_BAD\_TB0}]
    The final time \id{tB0} is outside the interval over which the forward problem
    was solved.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or else 
    \id{yB0} was \id{NULL}.
  \end{args}
}
{}

%%
%%==============================================================================
\subsection{Tolerance specification functions for backward problem}
\label{sss:cvtolerances_b}
%%==============================================================================
%%
One of the following two functions must be called to specify the integration 
tolerances for the backward problem. Note that this call must be made after the 
call to \id{CVodeInitB} or \id{CVodeInitBS}.
%%
\ucfunction{CVodeSStolerancesB}
{
  flag = CVodeSStolerances(cvode\_mem, which, reltolB, abstolB);
}
{
  The function \ID{CVodeSStolerancesB} specifies scalar relative and absolute
  tolerances.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[reltolB] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstolB] (\id{realtype})
    is the scalar absolute error tolerance.
  \end{args}
}
{
  The return flag \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeSStolerancesB} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    The {\cvodes} memory block was not initialized through a previous call to
    \id{CVodeCreate}.
  \item[\Id{CV\_NO\_MALLOC}] 
    The allocation function \id{CVodeInit} has not been called.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}] 
    One of the input tolerances was negative.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeSVtolerancesB}
{
  flag = CVodeSVtolerancesB(cvode\_mem, which, reltolB, abstolB);
}
{
  The function \ID{CVodeSVtolerancesB} specifies scalar relative tolerance and
  vector absolute tolerances.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[reltol] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstol] (\id{N\_Vector})
    is the vector of absolute error tolerances.
  \end{args}
}
{
  The return flag \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeSVtolerancesB} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    The {\cvodes} memory block was not initialized through a previous call to
    \id{CVodeCreate}.
  \item[\Id{CV\_NO\_MALLOC}] 
    The allocation function \id{CVodeInit} has not been called.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}] 
    The relative error tolerance was negative or the absolute tolerance
    had a negative component.
  \end{args}
}
{
  This choice of tolerances is important when the absolute error tolerance needs to
  be different for each component of the ODE. 
}
%%

%%---------------------------------------------------------------------
\subsection{Linear solver initialization functions for backward problem}
\label{sss:lin_solv_b}
%%---------------------------------------------------------------------

\index{CVODES@{\cvodes} linear solvers!usage with adjoint module|(} 
All linear solver modules in {\cvodes} provide additional specification functions 
for backward problems.
The initialization functions described in \S\ref{sss:lin_solv_init} cannot be directly used 
since the optional user-defined Jacobian-related functions have different prototypes for the
backward problem than for the forward problem (see \S\ref{ss:user_fct_adj}).
\index{CVODES@{\cvodes} linear solvers!usage with adjoint module|)} 

The following wrapper functions can be used to initialize one of the linear
solver modules for the backward problem. Their arguments are identical to those
of the functions in \S\ref{sss:lin_solv_init} with the exception of the additional
second argument, \id{which}, the identifier of the backward problem.
\begin{verbatim}
  flag = CVDenseB(cvode_mem, which, nB);
  flag = CVBandB(cvode_mem, which, nB, mupperB, mlowerB);
  flag = CVLapackDenseB(cvode_mem, which, nB);
  flag = CVLapackBandB(cvode_mem, which, nB, mupperB, mlowerB);
  flag = CVDiagB(cvode_mem, which);
  flag = CVSpgmrB(cvode_mem, which, maxlB);
  flag = CVSpbcgB(cvode_mem, which, maxlB);
  flag = CVSptfqmrB(cvode_mem, which, maxlB);
\end{verbatim}

Their return value \id{flag} (of type \id{int}) can have any of the return values 
of their counterparts.
If the \id{cvode\_mem} argument was \id{NULL}, \id{flag} will be
%%
If the \id{cvode\_mem} argument was \id{NULL}, 
\id{flag} will be \id{CVDIRECT\_MEM\_NULL}, \id{CVDIAG\_MEM\_NULL}, or \id{CVSPILS\_MEM\_NULL}. 
%%
Also, if \id{which} is not a valid identifier, the functions will return 
\id{CVDIRECT\_ILL\_INPUT}, \id{CVDIAG\_ILL\_INPUT}, or \id{CVSPILS\_ILL\_INPUT}.


%%---------------------------------------------------------------------
\subsection{Backward integration function}
\label{sss:cvsolveb}
%%---------------------------------------------------------------------

The function \ID{CVodeB} performs the integration of the backward problem.
It is essentially a wrapper for the {\cvodes} main integration function 
\id{CVode} and, in the case in which checkpoints were needed, it evolves 
the solution of the backward problem through a sequence of forward-backward 
integrations between consecutive checkpoints. 
The first run integrates the original IVP forward in time and
stores interpolation data; the second run integrates the backward problem 
backward in time and performs the required interpolation to provide
the solution of the IVP to the backward problem.

The call to this function has the form
%%
%%
\ucfunction{CVodeB}
{
  flag = CVodeB(cvode\_mem, tBout, itaskB);
}
{
  The function \ID{CVodeB} integrates the backward ODE problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeInit}.
  \item[tBout] (\id{realtype})
    the next time at which a computed solution is desired.
  \item[itaskB] (\id{int})
    \index{output mode}
    a flag indicating the job of the solver for the next step. 
    The \Id{CV\_NORMAL} task is to have the solver take internal steps until   
    it has reached or just passed the user specified \id{tBout}
    parameter. The solver then interpolates in order to   
    return an approximate value of $yB($\id{tBout}$)$. 
    The \Id{CV\_ONE\_STEP} option tells the solver to just take one internal step  
    and return the solution at the point reached by that step. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following.
  For more details see \S\ref{sss:cvode}.
  \begin{args}[CV\_TOO\_MUCH\_WORK]
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeB} succeeded.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_NO\_BCK}]
    No backward problem has been added to the list of backward problems by
    a call to \id{CVodeCreateB}
  \item[\Id{CV\_NO\_FWD}]
    The function \id{CVodeF} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}]
    One of the inputs to \id{CVodeB} is illegal.
  \item[\Id{CV\_BAD\_ITASK}]
    The \id{itaskB} argument has an illegal value.
  \item[\Id{CV\_TOO\_MUCH\_WORK}] 
    The solver took \id{mxstep} internal steps but could not reach \id{tBout}. 
  \item[\Id{CV\_TOO\_MUCH\_ACC}] 
    The solver could not satisfy the accuracy demanded by the user for some 
    internal step.
  \item[\Id{CV\_ERR\_FAILURE}]
    Error test failures occurred too many times during one internal time step.
  \item[\Id{CV\_CONV\_FAILURE}] 
    Convergence test failures occurred too many times during one internal time step.
  \item[\Id{CV\_LSETUP\_FAIL}] 
    The linear solver's setup function failed in an unrecoverable manner.
  \item[\Id{CV\_SOLVE\_FAIL}] 
    The linear solver's solve function failed in an unrecoverable manner.
  \item[\Id{CV\_BCKMEM\_NULL}]
    The solver memory for the backward problem was not created through
    a call to \id{CVodeCreateB}.
  \item[\Id{CV\_BAD\_TBOUT}]
    The desired output time \id{tBout} is outside the interval over which the 
    forward problem was solved.
  \item[\Id{CV\_REIFWD\_FAIL}]
    Reinitialization of the forward problem failed at the first checkpoint
    (corresponding to the initial time of the forward problem).
  \item[\Id{CV\_FWD\_FAIL}]
    An error occured during the integration of the forward problem.
  \end{args} 
}
{
  All failure return values are negative and therefore a test \id{flag}$< 0$
  will trap all \id{CVodeB} failures.
}

%%-------------------------------------------------------------------------------
\subsection{Adjoint sensitivity optional input}

User can disable anytime during the integration of the forward problem the 
checkpointing of the forward sensitivities by calling the following function:

\ucfunction{CVodeAdjSetNoSensi}
{
  flag = CVodeAdjSetNoSensi(cvode\_mem);
}
{
  The function \ID{CVodeAdjSetNoSensi} instructs \id{CVodeF} not
  to save checkpointing data for forward sensitivities anymore.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes}  memory block.
  \end{args}
}
{
  The return \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_FAIL]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeCreateB} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \end{args}
}
{}
%%-------------------------------------------------------------------------------


%%---------------------------------------------------------------------
\subsection{Optional input functions for the backward problem}
\label{ss:optional_input_b}
%%---------------------------------------------------------------------
%%
\subsubsection{Main solver optional input functions}
\index{optional input!backward solver|(}

The adjoint module in {\cvodes} provides wrappers for most of the optional 
input functions defined in \S\ref{sss:optin_main}. The only difference is 
that the user must specifies the identifier \id{which} of the backward problem 
within the list managed by {\cvodes}. 

The optional input functions defined for the backward problem are:
\begin{verbatim}
  flag = CVodeSetUserDataB(cvode_mem, which, user_dataB);
  flag = CVodeSetMaxOrdB(cvode_mem, which, maxordB);
  flag = CVodeSetMaxNumStepsB(cvode_mem, which, mxstepsB);
  flag = CVodeSetInitStepB(cvode_mem, which, hinB)
  flag = CVodeSetMaxStepB(cvode_mem, which, hmaxB);
\end{verbatim}
Their return value \id{flag} (of type \id{int}) can have any of the return values 
of their counterparts, but it can also be \Id{CV\_NO\_ADJ} if \id{CVodeAdjInit} 
has not been called or \Id{CV\_ILL\_INPUT} if \id{which} was an invalid identifier. 

\index{optional input!backward solver|)}

\subsubsection{Dense linear solver}
\index{optional input!dense linear solver|(}
\index{CVDENSE@{\cvdense} linear solver!optional input|(}
Optional inputs for the {\cvdense} linear solver module can be set for the backward
problem through the following function:
%%
\index{Jacobian approximation function!dense!user-supplied (backward)}
\ucfunction{CVDlsSetDenseJacFnB}
{
  flag = CVDlsSetDenseJacFnB(cvode\_mem, which, jacB);
}
{
  The function \ID{CVDlsSetDenseJacFnB} specifies the dense Jacobian
  approximation function to be used for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeInit}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[djacB] (\id{CVDlsDenseJacFnB})
    user-defined dense Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVDIRECT\_ILL\_INPUT]
  \item[\Id{CVDIRECT\_SUCCESS}] 
    \id{CVDlsSetDenseJacFnB} succeeded.
  \item[\Id{CVDIRECT\_MEM\_NULL}]
    The \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVDIRECT\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVDIRECT\_LMEM\_NULL}]
    The linear solver has not been initialized through a call to \id{CVDenseB}
    or \id{CVLapackDenseB}.
  \item[\Id{CVDIRECT\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVDlsDenseJacFnB} is described in \S\ref{ss:user_fct_adj}.
}
\index{CVDENSE@{\cvdense} linear solver!optional input|)}
\index{optional input!dense linear solver|)}


\subsubsection{Band linear solver}
\index{optional input!band linear solver|(}
\index{CVBAND@{\cvband} linear solver!optional input|(}
Optional inputs for the {\cvband} linear solver module can be set for the backward
problem through the following function:
%%
\index{Jacobian approximation function!band!user-supplied (backward)}
\ucfunction{CVDlsSetBandJacFnB}
{
  flag = CVDlsSetBandJacFnB(cvode\_mem, which, jacB);
}
{
  The function \ID{CVDlsSetBandJacFnB} specifies the banded Jacobian
  approximation function to be used for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeInit}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacB] (\id{CVDlsBandJacFnB})
    user-defined banded Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVDIRECT\_ILL\_INPUT]
  \item[\Id{CVDIRECT\_SUCCESS}] 
    \id{CVDlsSetBandJacFnB} succeeded.
  \item[\Id{CVDIRECT\_MEM\_NULL}]
    The \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVDIRECT\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVDIRECT\_LMEM\_NULL}]
    The linear solver has not been initialized through a call to \id{CVBandB}
    or \id{CVLapackBandB}.
  \item[\Id{CVDIRECT\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVDlsBandJacFnB} is described in \S\ref{ss:user_fct_adj}.
}
\index{CVBAND@{\cvband} linear solver!optional input|)}
\index{optional input!band linear solver|)}

\subsubsection{SPILS linear solvers}
\index{optional input!iterative linear solver|(}
\index{CVSPGMR@{\cvspgmr} linear solver!optional input|(}
\index{CVSPBCG@{\cvspbcg} linear solver!optional input|(}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!optional input|(}
Optional inputs for the {\cvspils} linear solver module can be set for the backward
problem through the following functions:
%%
\index{preconditioning!user-supplied|(}
\ucfunction{CVSpilsSetPreconditionerB}
{
  flag = CVSpilsSetPreconditionerB(cvode\_mem, which, psetupB, psolveB);
}
{
  The function \ID{CVSpilsSetPrecSolveFnB} specifies the preconditioner
  setup and solve functions for the backward integration.
}
{
  \begin{args}[psetupB]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[psetupB] (\id{CVSpilsPrecSetupFnB})
    user-defined preconditioner setup function.
  \item[psolveB] (\id{CVSpilsPrecSolveFnB})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfuly set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} memory block was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
   The function types \id{CVSpilsPrecSolveFnB} and \id{CVSpilsPrecSetupFnB} are
   described in \S\ref{ss:user_fct_adj}.
}
%%
\index{preconditioning!user-supplied|)}
%%
\index{Jacobian approximation function!Jacobian-vector product!user-supplied (backward)}
\ucfunction{CVSpilsSetJacTimesVecFnB}
{
  flag = CVSpilsSetJacTimesVecFnB(cvode\_mem, which, jtvB);
}
{
  The function \ID{CVSpilsSetJacTimesFnB} specifies the Jacobian-vector 
  product function to be used.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[jtvB] (\id{CVSpilsJacTimesVecFnB})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfuly set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} memory block was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVSpilsJacTimesVecFnB} is described in \S\ref{ss:user_fct_adj}.
}
%%
%%
\ucfunction{CVSpilsSetGSTypeB}
{
  flag = CVSpilsSetGSType(cvode\_mem, which, gstypeB);
}
{
  The function \ID{CVSpilsSetGSTypeB} specifies the type of
  Gram-Schmidt orthogonalization to be used with {\cvspgmr}.
  This must be one of the enumeration constants \ID{MODIFIED\_GS}
  or \ID{CLASSICAL\_GS}. These correspond to using modified Gram-Schmidt 
  and classical Gram-Schmidt, respectively. 
  \index{Gram-Schmidt procedure}
}
{
  \begin{args}[gstypeB]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[gstypeB] (\id{int})
    type of Gram-Schmidt orthogonalization.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfuly set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} memory block was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier or the 
    Gram-Schmidt orthogonalization type \id{gstypeB} is not valid.
  \end{args}
}
{
  The default value is \id{MODIFIED\_GS}.

  {\warn}This option is available only with {\cvspgmr}.
}
%%
\ucfunction{CVSpilsSetMaxlB}
{
  flag = CVSpilsSetMaxlB(cvode\_mem, which, maxlB);
}
{
  The function \ID{CVSpilsSetMaxlB} resets maximum Krylov subspace
  dimension for the Bi-CGStab\index{Bi-CGStab method} or TFQMR\index{TFQMR method} 
  methods.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[maxlB] (\id{realtype})
    maximum dimension of the Krylov subspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfuly set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} memory block was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier or 
  \end{args}
}
{
  The maximum subspace dimension is initially specified in the call
  to \id{CVodeSpbcgB} or \id{CVodeSptfqmrB}.
  The call to \id{CVodeSpilsSetMaxlB} is needed only if \id{maxl} is being changed from its 
  previous value.

  {\warn}This option is available only for the {\cvspbcg} and {\cvsptfqmr} linear solvers.

}
%%
\ucfunction{CVSpilsSetDeltB}
{
  flag = CVSpilsSetDeltB(cvode\_mem, which, deltB);
}
{
  The function \ID{CVSpilsSetDeltB} specifies the factor by
  which the Krylov linear solver's convergence test constant is reduced
  from the Newton iteration test constant.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[deltB] (\id{realtype})
    the value of the convergence test constant reduction factor.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfuly set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} memory block was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier or 
  \end{args}
}
{
  The default value is $0.05$.
  Passing a value \id{deltB}$ = 0.0$ also indicates using the default value.
}
%%
\ucfunction{CVSpilsSetPrecTypeB}
{
  flag = CVSpilsSetPrecTypeB(cvode\_mem, which, pretypeB);
}
{
  The function \ID{CVSpilsSetPrecTypeB} resets the type
  of preconditioning to be used.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[pretypeB] (\id{int})
    \index{pretypeB@\texttt{pretypeB}}
    specifies the type of prconditioning and must be one of:
    \Id{PREC\_NONE}, \Id{PREC\_LEFT}, \Id{PREC\_RIGHT}, or \Id{PREC\_BOTH}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfuly set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} memory block was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier or 
  \end{args}
}
{
  The preconditioning type is initially specified in the call
  to the linear solver specification function (see \S\ref{sss:lin_solv_b}). 
  The call to \id{CVSpilsSetPrecTypeB} is needed only if \id{pretypeB} is being changed from its 
  previous value.
}
%%
\index{CVSPGMR@{\cvspgmr} linear solver!optional input|)}
\index{CVSPBCG@{\cvspbcg} linear solver!optional input|)}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!optional input|)}
\index{optional input!iterative linear solver|)}

%---------------------------------------------------------------------------
\subsection{Optional output functions for the backward problem}\label{ss:optional_output_b}
\index{optional output!backward solver|(}
%%
The user of the adjoint module in {\cvodes} has access to any of the optional output 
functions described in \S\ref{ss:optional_output}, both for the main solver and for
the linear solver modules. The first argument of these \id{CVodeGet*} and \id{CVode*Get*}
functions is the {\cvodes} memory block for the backward problem. In order to call any of these
functions, the user must first call the following function to obtain a pointer to
this memory block:
%%
\ucfunction{CVodeGetAdjCVodeBmem}
{
  cvode\_memB = CVodeGetAdjCVodeBmem(cvode\_mem, which);
}
{
  The function \ID{CVodeGetAdjCVodeBmem} returns a pointer to the {\cvodes}
  memory block for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block created by using \id{CVodeCreate}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \end{args}
}
{
  The return value, \id{cvode\_memB} (of type \id{void *}), is a pointer to the
  {\cvodes} memory for the backward problem.
}
{
  {\warn}The user should not modify in any way \id{cvode\_memB}.
}
\index{optional output!backward solver|)}


%%---------------------------------------------------------------------
\subsection{Backward integration of quadrature equations}
%%---------------------------------------------------------------------

Not only the backward problem but also the backward quadrature equations 
may or may not depend on the forward sensitivities. While one of the 
\id{CVodeQuadInitB} or \id{CVodeQuadInitBS} should be used to allocate internal 
memory and to initialize backward quadratures, the same function should be 
called for any other operation (extraction, optional input/output, 
reinitialization, deallocation).

\subsubsection{Backward quadrature initialization functions}
\label{sss:cvquadinitb}

The function \id{CVodeQuadInitB} initializes and allocates memory for the backward
integration of quadrature equations. It has the following form:
%%
%%
\ucfunction{CVodeQuadInitB}
{
flag = CVodeQuadInitB(cvode\_mem, which, rhsQB, yQB0);
}
{
  The function \ID{CVodeQuadInitB} provides required problem specifications,
  allocates internal memory, and initializes backward quadrature integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[rhsQB] (\Id{CVQuadRhsFnB})
    is the {\C} function which computes $fQB$, the right-hand side of the 
    backward quadrature equations. This function has the form 
    \id{rhsQB(t, y, yB, qBdot, user\_dataB)} 
    (see \S\ref{sss:rhs_quad_B}).
  \item[yQB0] (\id{N\_Vector})
    is the value of the quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeQuadInitB} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    The \id{cvode\_mem} memory block was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{}
%%
%%


The function \id{CVodeQuadInitBS} initializes and allocates memory for the backward
integration of quadrature equations that dependes on the forward sensitivites.
%%
%%
\ucfunction{CVodeQuadInitBS}
{
flag = CVodeQuadInitB(cvode\_mem, which, rhsQBS, yQBS0);
}
{
  The function \ID{CVodeQuadInitBS} provides required problem specifications,
  allocates internal memory, and initializes backward quadrature integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[rhsQB] (\Id{CVQuadRhsFnBS})
    is the {\C} function which computes $fQBS$, the right-hand side of the 
    backward quadrature equations. This function has the form 
    \id{rhsQB(t, y, yS, yB, qBdot, user\_dataB)} 
    (see \S\ref{sss:rhs_quad_sens_B}).
  \item[yQBS0] (\id{N\_Vector})
    is the value of the sensitivity-dependent quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeQuadInitBS} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    The \id{cvode\_mem} memory block was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{}


The integration of quadrature equations during the backward phase can be
re-initialized by calling
%%
%%
\ucfunction{CVodeQuadReInitB}
{
  flag = CVodeQuadReInitB(cvode\_mem, which, yQB0);
}
{
  The function \id{CVodeQuadReInitB} re-initializes the backward quadrature integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[yQB0] (\id{N\_Vector})
    is the value of the quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeReInitB} was successful.
 \item[\Id{CV\_MEM\_NULL}] 
    The \id{cvode\_mem} memory block was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{CV\_NO\_QUAD}] 
    Quadrature integration was not activated through a  previous 
    call to \id{CVodeQuadInitB}.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{
  \id{CVodeQuadReInitB} can be used not only after a call to \id{CVodeQuadInitB} but
  also to \id{CVodeQuadInitBS}.
}

\subsubsection{Backward quadrature extraction function}
\label{sss:quad_get_b}
To extract the values of the quadrature variables at the last return time
of \id{CVodeB}, {\cvodes} provides a wrapper for the function \ID{CVodeGetQuad}
(see \S\ref{ss:quad_get}). The call to this function has the form
%%
%%
\ucfunction{CVodeGetQuadB}
{
  flag = CVodeGetQuadB(cvode\_mem, which, \&t, yQB);
}
{
  The function \id{CVodeGetQuadB} returns the quadrature solution vector after
  a successful return from \id{CVodeB}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory.
  \item[t] (\id{realtype})
    the time reached by the solver.
  \item[yQB] (\id{N\_Vector})
    the computed quadrature vector.
  \end{args}
}
{
  The return value \id{flag} of \id{CVodeGetQuadB} is one of:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}] 
    \id{CVodeGetQuadB} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    \id{cvode\_mem} is \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[CV\_NO\_QUAD] 
    Quadrature integration was not initialized.
  \item[CV\_BAD\_DKY] 
    \id{yQB} was \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{}
%%\subsubsection{Tolerance specification functions for backward quadrature integration}

\subsubsection{Optional input/output functions for backward quadrature integration}
\label{sss:quad_optional_input_B}
\index{optional input!quadrature integration}
\index{optional output!quadrature integration}
Optional values controlling the backward integration of quadrature equations can be 
changed from their default values through calls to one of the following functions 
which are wrappers for the corresponding optional input functions defined in 
\S\ref{ss:quad_optional_input}. The user must specifies  the identifier \id{which} 
of the backward problem for which the optional values are specified.

\begin{verbatim}
  flag = CVodeSetQuadErrConB(cvode_mem, which, errconQ);
  flag = CVodeQuadSVtolerancesB(cvode_mem, which, reltolQ, abstolQ);
  flag = CVodeQuadSVtolerancesB(cvode_mem, which, reltolQ, abstolQ);
\end{verbatim}
Their return value \id{flag} (of type \id{int}) can have any of the return values 
of its counterparts, but it can also be \Id{CV\_NO\_ADJ} if the function 
\id{CVodeAdjInit} has not been previously called or \Id{CV\_ILL\_INPUT} if the
parameter \id{which} was an invalid identifier.

Access to optional outputs related to backward quadrature integration can be obtained
by calling the corresponding \id{CVodeGetQuad*} functions 
(see \S\ref{ss:quad_optional_output}). 
A pointer to the {\cvodes} memory block for the backward problem, required as the first 
argument of these functions, can be obtained through a call to the functions 
\id{CVodeGetAdjCVodeBmem} (see \S\ref{ss:optional_output_b}).



%%---------------------------------------------------------------------
\subsection{Optional output from the adjoint module}
%%---------------------------------------------------------------------
\subsubsection{Checkpoint information function}
\index{optional output!checkpoint information}
For debugging purposes, {\cvodes} provides a function \ID{CVodeGetAdjCheckPointsInfo} which
returns partial information from the linked list of checkpoints generated by
\id{CVodeF}. The call to this function has the form:
%%
%%
\ucfunction{CVodeGetAdjCheckPointsInfo}
{
  flag = CVodeGetAdjCheckPointsInfo(cvode\_mem, ckpnt);
}
{
  The function \ID{CVodeGetAdjCheckPointsInfo} returns a structure array
  with checkpoint information.
}
{  
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeInit}.
  \item[ckpnt] (\id{CVadjCheckPointRec *})
    an array of \id{ncheck}+1 structures with checkpoint information, where
    \id{ncheck} is the numebr of checkpoints returned by \id{CVodeF}.
  \end{args}
}
{
  The return value \id{flag} of \id{CVodeGetAdjCheckPointsInfo} is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    \id{CVodeGetAdjCheckPointsInfo} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    \id{cvode\_mem} is \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \end{args}
}
{
  {\warn}The user must allocate space for ckpnt (ncheck+1 structures).
}
%%
%%
The type \Id{CVadjCheckPointRec} is defined in the header file \id{cvodes.h}:
\begin{verbatim}
     typedef struct {
       void *my_addr;
       void *next_addr;
       realtype t0;
       realtype t1;
       long int nstep;
       int order;
       realtype step;
     } CVadjCheckPointRec;
\end{verbatim}
%%
The fields in this structure have the following meanings:
\begin{args}[next\_addr]
\item[my\_addr]
  Address of current checkpoint.
\item[next\_addr]
  Address of next checkpoint.
\item[t0]
\item[t1]
  Time interval between current and next checkpoint.
\item[nstep]
  Step number at which the current checkpoint was saved.
\item[order]
  Linear multistep method order at the current checkpoint.
\item[step]
  Integration stepsize at current checkpoint.
\end{args}
%%
%%
\subsubsection{Interpolation data}
%%
\index{optional output!interpolation data}
Fo debugging purposes, {\cvodea} provides two extraction functions which 
return the data stored for interpolation purposes.
%%
\ucfunction{CVodeGetAdjDataPointHermite}
{
  int = CVodeGetAdjDataPointHermite(cvode\_mem, which, \&t, y, yd);
}
{
  The function \ID{CVodeGetAdjDataPointHermite} returns the
  time and two vectors associated with the \id{which} interpolation data point.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    index of the intepolation data point.
  \item[t] (\id{realtype *})
  \item[y] (\id{N\_Vector})
  \item[yd] (\id{N\_Vector})
    time, solution, and solution derivative for the forward problem 
    stored for interpolation purposes at the \id{which} data point.
  \end{args}
}
{
  The return value \id{flag} is one of:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}] 
    \id{CVodeGetAdjDataPointHermite} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    \id{cvode\_mem} is \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}]
    The interpolation type was not cubic Hermite.
  \end{args}
}
{
  It is the user's responsibility to allocate space for \id{y} and \id{yd}.
}
%%
\ucfunction{CVodeGetAdjDataPointPolynomial}
{
  int = CVodeGetAdjDataPointPolynomial(cvode\_mem, which, \&t, order, y);
}
{
  The function \ID{CVodeGetAdjDataPointPolynomial} returns the
  time and two vectors associated with the \id{which} interpolation data point.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    index of the intepolation data point.
  \item[t] (\id{realtype *})
  \item[order] (\id{int})
  \item[yd] (\id{N\_Vector})
    time, method order, and solution of the forward problem 
    stored for interpolation purposes at the \id{which} data point.
  \end{args}
}
{
  The return value \id{flag} is one of:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}] 
    \id{CVodeGetAdjDataPointHermite} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    \id{cvode\_mem} is \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}]
    The interpolation type was not variable-order polynomial.
  \end{args}
}
{
  It is the user's responsibility to allocate space for \id{y}.
}

%%-------------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------------
\section{User-supplied functions for adjoint sensitivity analysis}
\label{ss:user_fct_adj}
%%-------------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------------
%%

In addition to the required ODE right-hand side function and any optional functions
for the forward problem, when using the adjoint sensitivity module in {\cvodes},
the user must supply one function defining the backward problem ODE and, optionally,
functions to supply Jacobian-related information and one or two functions 
that define the preconditioner (if one of the {\cvspils} solvers is
selected) for the backward problem.
Type definitions for all these user-supplied functions are given below.

\subsection{ODE right-hand side for the backward problem}
\index{adjoint sensitivity analysis!right-hand side evaluation}
\index{right-hand side function!backward problem}

The user must provide a function of type \ID{CVRhsFnB} defined as follows:
\usfunction{CVRhsFnB}
{
  typedef int (*CVRhsFnB)(&realtype t, N\_Vector y, \\
  &N\_Vector yB, N\_Vector yBdot, \\
  &void *user\_dataB);
}
{
  This function evaluates the right-hand side of the backward problem ODE system.
  This could be (\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}).
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the dependent variable vector.
  \item[yBdot]
    is the output vector containing the right-hand side of the backward ODE problem.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  A \id{CVRhsFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_RHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{yBdot} is handled within {\cvodes}.

  The \id{y}, \id{yB}, and \id{yBdot} arguments are all 
  of type \id{N\_Vector}, but \id{yB} and \id{yBdot} typically have 
  different internal representations from \id{y}. It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\cvodes} do not perform any consistency checks with respect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to 
  the user's \id{rhsB} function every time it is called and can be the same as the 
  \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{CVRhsFnB}, {\cvodea} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurrs in the interpolation, {\cvodea} triggers an unrecoverable
  failure in the righ-hand side function which will halt the integration and
  \id{CVodeB} will return \id{CV\_RHSFUNC\_FAIL}.
}

\subsection{ODE right-hand side for the backward problem depending on the forward sensitivities}
\index{adjoint sensitivity analysis!right-hand side evaluation}
\index{right-hand side function!backward problem}

The user must provide a function of type \ID{CVRhsFnBS} defined as follows:
\usfunction{CVRhsFnBS}
{
  typedef int (*CVRhsFnBS)(&realtype t, N\_Vector y, N\_Vector *yS, \\
  &N\_Vector yB, N\_Vector yBdot, \\
  &void *user\_dataB);
}
{
  This function evaluates the right-hand side of the backward problem ODE system.
  This could be (\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}).
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[yB]
    is the current value of the dependent variable vector.
  \item[yBdot]
    is the output vector containing the right-hand side of the backward ODE problem.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  A \id{CVRhsFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_RHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{qBdot} is handled within {\cvodes}.

  The \id{y}, \id{yB}, and \id{yBdot} arguments are all 
  of type \id{N\_Vector}, but \id{yB} and \id{yBdot} typically have 
  different internal representations from \id{y}.. It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\cvodes} do not perform any consistency checks with respect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to 
  the user's \id{rhsBS} function every time it is called and can be the same as the 
  \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{CVRhsFnBS}, {\cvodea} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurrs in the interpolation, {\cvodea} triggers an unrecoverable
  failure in the righ-hand side function which will halt the integration and
  \id{CVodeB} will return \id{CV\_RHSFUNC\_FAIL}.
}


%%-------------------------------------------------------------------------------------
\subsection{Quadrature right-hand side for the backward problem}
\index{right-hand side function!quadrature backward problem}
\index{adjoint sensitivity analysis!quadrature evaluation}
\label{sss:rhs_quad_B}
The user must provide a function of type \ID{CVQuadRhsFnB} defined by
\usfunction{CVQuadRhsFnB}
{
  typedef int (*CVQuadRhsFnB)(&realtype t, N\_Vector y, \\
  &N\_Vector yB, N\_Vector qBdot, \\
  &void *user\_dataB);
}
{
  This function computes the quadrature equation right-hand side for the
  backward problem.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the dependent variable vector.
  \item[qBdot]
    is the output vector containing the right-hand side of the backward quadrature
    equations.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  A \id{CVQuadRhsFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_QRHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{rhsvalBQ} is handled within {\cvodes}.

  The \id{y}, \id{yB}, and \id{qBdot} arguments are all 
  of type \id{N\_Vector}, but they typically all have 
  different internal representations. It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\cvodes} do not perform any consistency checks with repsect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to the user's \id{fQB} function every time 
  it is called and can be the same as the \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{CVQuadRhsFnB}, {\cvodea} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurrs in the interpolation, {\cvodea} triggers an unrecoverable
  failure in the quadrature righ-hand side function which will halt the integration and
  \id{CVodeB} will return \id{CV\_QRHSFUNC\_FAIL}.
}

\subsection{Sensitivity-dependent quadrature right-hand side for the backward problem}
\index{right-hand side function!sensitivity-dependent quadrature backward problem}
\index{adjoint sensitivity analysis!sensitivity-dependent quadrature evaluation}
\label{sss:rhs_quad_sens_B}
The user must provide a function of type \ID{CVQuadRhsFnBS} defined by
\usfunction{CVQuadRhsFnBS}
{
  typedef int (*CVQuadRhsFnBS)(&realtype t, N\_Vector y, N\_Vector *yS, \\
  &N\_Vector yB, N\_Vector qBdot, \\
  &void *user\_dataB);
}
{
  This function computes the quadrature equation right-hand side for the
  backward problem.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[yB]
    is the current value of the dependent variable vector.
  \item[qBdot]
    is the output vector containing the right-hand side of the backward quadrature
    equations.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  A \id{CVQuadRhsFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_QRHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{rhsvalQS} is handled within {\cvodes}.

  The \id{y}, \id{yS}, and \id{qBdot} arguments are all 
  of type \id{N\_Vector}, but they typically all have 
  different internal representations. It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\cvodes} do not perform any consistency checks with repsect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to the user's \id{fQB} function every time 
  it is called and can be the same as the \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{CVQuadRhsFnBS}, {\cvodea} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurrs in the interpolation, {\cvodea} triggers an unrecoverable
  failure in the quadrature righ-hand side function which will halt the integration and
  \id{CVodeB} will return \id{CV\_QRHSFUNC\_FAIL}.
}


%%-------------------------------------------------------------------------------------
\subsection{Jacobian information for the backward problem 
  (direct method with dense Jacobian)}
  
If the direct linear solver with dense treatment of the Jacobian is selected
for the backward problem (i.e. \Id{CVDenseB} or \Id{CVLapackDenseB} is called in step \ref{i:lin_solverB} 
of \S\ref{ss:skeleton_adj}), the user may provide, through a call to \id{CVDlsSetDenseJacFnB}
(see \S\ref{ss:optional_input_b}), a function of the following type:
%%
\index{Jacobian approximation function!dense!user-supplied (backward)}
\usfunction{CVDlsDenseJacFnB}
{
  typedef int (*CVDlsDenseJacFnB)(&int NeqB, realtype t, \\
  &N\_Vector y, \\
  &N\_Vector yB, N\_Vector fyB, \\
  &DlsMat JacB, void *user\_dataB, \\
  &N\_Vector tmp1B, N\_Vector tmp2B, \\
  &N\_Vector tmp3B);
}
{
  This function computes the dense Jacobian of the backward problem (or an approximation
  to it). 
}
{
  \begin{args}[user\_dataB]
  \item[NeqB]
    is the backward problem size (number of equations).
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the dependent variable vector.
  \item[fyB]
    is the current value of the dependent derivative variable vector.
  \item[JacB]
    is the output dense Jacobian matrix.
  \item[user\_dataB]
    is a pointer to user data - the same as the parameter passed to \id{CVodeSetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{CVDlsDenseJacFnB} as temporary storage or work space.    
  \end{args}
}
{
  A \id{CVDlsDenseJacFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct, while {\cvdense} sets
  \id{last\_flag} on \Id{CVDIRECT\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{CVodeB}
  returns \Id{CV\_LSETUP\_FAIL} and {\cvdense} sets \id{last\_flag} on 
  \Id{CVDIRECT\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied dense Jacobian function must load the \id{NeqB} by \id{NeqB}
  dense matrix \id{JacB} with an approximation to the Jacobian matrix
  at the point (\id{t},\id{y},\id{yB}), where \id{y} is the solution
  of the original IVP at time \id{tt} and \id{yB} is the solution of the
  backward problem at the same time.
  Only nonzero elements need to be loaded into \id{JacB} as this matrix 
  is set to zero before the call to the Jacobian function. 
  The type of \id{JacB} is \Id{DlsMat}. The user is referred to 
  \S\ref{ss:djacFn} for details regarding accessing a \id{DlsMat} object.

  {\warn}Before calling the user's \id{CVDlsDenseJacFnB}, {\cvodea} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurrs in the interpolation, {\cvodea} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{CVodeB} returns \id{CV\_LSETUP\_FAIL} and {\cvdense} sets \id{last\_flag} on 
  \Id{CVDIRECT\_JACFUNC\_UNRECVR}).
}

%%-------------------------------------------------------------------------------------
\subsection{Jacobian information for the backward problem
  (direct method with banded Jacobian)}
\index{Jacobian approximation function!band!user-supplied (backward)}
If the direct linear solver with banded treatment of the Jacobian is selected
for the backward problem (i.e. \Id{CVBandB} or \Id{CVLapackBandB} is called in step \ref{i:lin_solverB} 
of \S\ref{ss:skeleton_adj}), the user may provide, through a call to \id{CVDlsSetBandJacFnB}
(see \S\ref{ss:optional_input_b}), a function the following type:
%%
\usfunction{CVDlsBandJacFnB}
{
 typedef int (*CVDlsBandJacFnB)(&int NeqB, int mupperB, int mlowerB,\\
                             &realtype t, N\_Vector y \\
                             &N\_Vector yB, N\_Vector fyB, \\
                             &DlsMat JacB, void *user\_dataB, \\
                             &N\_Vector tmp1B, N\_Vector tmp2B, \\
                             &N\_Vector tmp3B);
}
{
  This function computes the banded Jacobian of the backward problem
  (or a banded approximation to it).
}
{
  \begin{args}[user\_dataB]
  \item[NeqB]
    is the backward problem size.
  \item[mlowerB]
  \item[mupperB]
    are the lower and upper half-bandwidth of the Jacobian.
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the dependent variable vector.
  \item[fyB]
    is the current value of the dependent derivative variable vector.
  \item[JacB]
    is the output band Jacobian matrix. 
  \item[user\_dataB]
    is a pointer to user data - the same as the parameter passed to \id{CVodeSetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{CVDlsBandJacFnB} as temporary storage or work space.    
  \end{args}
}
{
  A \id{CVDlsBandJacFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct, while {\cvband} sets
  \id{last\_flag} on \Id{CVDIRECT\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{CVodeB}
  returns \Id{CV\_LSETUP\_FAIL} and {\cvdense} sets \id{last\_flag} on 
  \Id{CVDIRECT\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied band Jacobian function must load the band matrix \id{JacB}
  (of type \Id{BandMat}) with the elements of the Jacobian at the
  point (\id{t},\id{y},\id{yB}), where \id{y} is the solution
  of the original IVP at time \id{tt} and \id{yB} is the solution of the
  backward problem at the same time.  
  Only nonzero elements need to be loaded into
  \id{JacB} because \id{JacB} is preset to zero before the call to the
  Jacobian function. More details on the accessor macros provided for
  a \id{BandMat} object and on the rest of the arguments passed to a function
  of type \id{CVDlsBandJacFnB} are given in \S\ref{ss:bjacFn}.

  {\warn}Before calling the user's \id{CVDlsBandJacFnB}, {\cvodea} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurrs in the interpolation, {\cvodea} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{CVodeB} returns \id{CV\_LSETUP\_FAIL} and {\cvband} sets \id{last\_flag} on 
  \Id{CVDIRECT\_JACFUNC\_UNRECVR}).
}

%%-------------------------------------------------------------------------------------
\subsection{Jacobian information for the backward problem (matrix-vector product)}
\index{Jacobian approximation function!Jacobian-vector product!user-supplied (backward)}
If one of the Krylov iterative linear solvers {\spgmr}, {\spbcg}, or {\sptfqmr}
is selected (\id{CVodeSp*B} is called in step \ref{i:lin_solverB} of \S\ref{ss:skeleton_adj}), 
the user may provide a function of type \ID{CVSpilsJacTimesVecFnB} in the following form:
%%
\usfunction{CVSpilsJacTimesVecFnB}
{
  typedef int (*CVSpilsJacTimesVecFnB)(&N\_Vector vB, N\_Vector JvB, realtype t, \\
  &N\_Vector y, N\_Vector yB, N\_Vector fyB,\\
  &void *user\_dataB, N\_Vector tmpB);
}
{
  This function computes the action of the Jacobian on a given vector \id{vB} for
  the backward problem (or an approximation to it).
}
{
  \begin{args}[user\_dataB]
  \item[vB]
    is the vector by which the Jacobian must be multiplied to the right.
  \item[JvB]
    is the output vector computed.
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the dependent variable vector.
  \item[fyB]
    is the current value of the dependent derivative variable vector.
  \item[user\_dataB]
    is a pointer to user data - the same as the \id{user\_dataB}      
    parameter passed to \id{CVodeSetUserDataB}.
  \item[tmpB]
    is a pointer to memory allocated for a variable of type \id{N\_Vector} which
    can be used by \id{CVSpilsJacTimesVecFn} as temporary storage or work space.
  \end{args}
}
{  
  The return value of a function of type \id{CVSpilsJtimesFnB} should be
  $0$ if successful or nonzero if an error was encountered, in which case
  the integration is halted.
}
{
  A user-supplied Jacobian-vector product function must load the vector \id{JvB}
  with the result of the product between the Jacobian of the backward problem 
  at the point (\id{t},\id{y}, \id{yB}) and the vector \id{vB}. 
  Here, \id{y} is the solution of the original IVP at time \id{t} and 
  \id{yB} is the solution of the backward problem at the same time.  
  The rest of the arguments are equivalent to those passed to a function of type
  \id{CVSpilsJacTimesVecFn} (see \S\ref{ss:jtimesFn}).
  If the backward problem is the adjoint of ${\dot y} = f(t, y)$, then this 
  function is to compute $-(\dfdyI)^T v_B$.
}

%%-------------------------------------------------------------------------------------
\subsection{Preconditioning for the backward problem (linear system solution)}
\index{preconditioning!user-supplied}
\index{CVSPGMR@{\cvspgmr} linear solver!preconditioner solve function}
\index{CVSPBCG@{\cvspbcg} linear solver!preconditioner solve function}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!preconditioner solve function}
If preconditioning is used during integration of the backward problem, 
then the user must provide a {\C} function to solve the linear system 
$Pz = r$, where $P$ may be either a left or a right preconditioner matrix.
This function must be of type \ID{CVSpilsPrecSolveFnB} defined by
%%
\usfunction{CVSpilsPrecSolveFnB}
{
  typedef int (*CVSpilsPrecSolveFnB)(&realtype t, N\_Vector y, \\
                                     &N\_Vector yB, N\_Vector fyB, \\
                                     &N\_Vector rvecB, N\_Vector zvecB, \\
                                     &realtype gammaB, realtype deltaB, \\
                                     &void *user\_dataB, N\_Vector tmpB);
}
{
  This function solves the preconditioning system $Pz = r$ for the backward problem.
}
{  
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the dependent variable vector.
  \item[fyB]
    is the current value of the dependent derivative variable vector.
  \item[rvecB]
    is the right-hand side vector $r$ of the linear system to be solved.
  \item[zvecB]
    is the output vector computed.
  \item[gammaB]
    is the scalar appearing in the Newton matrix.
  \item[deltaB]
    is an input tolerance to be used if an iterative method 
    is employed in the solution.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}      
    parameter passed to the function \id{CVodeSetUserDataB}.
  \item[tmpB]
    is a pointer to memory allocated for a variable of type    
    \id{N\_Vector} which can be used for work space.
  \end{args}
}
{
  The return value of a preconditioner solve function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried), or
  negative for an unrecoverable error (in which case the integration is halted).
}
{}

%%-------------------------------------------------------------------------------------
\subsection{Preconditioning for the backward problem (Jacobian data)}
\index{preconditioning!user-supplied}
\index{CVSPGMR@{\cvspgmr} linear solver!preconditioner setup function}
\index{CVSPBCG@{\cvspbcg} linear solver!preconditioner setup function}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!preconditioner setup function}
If the user's preconditioner requires that any Jacobian-related data
be preprocessed or evaluated, then this needs to be done in a
user-supplied {\C} function of type \ID{CVSpilsPrecSetupFnB} defined by
%%
\usfunction{CVSpilsPrecSetupFnB}
{
  typedef int (*CVSpilsPrecSetupFnB)(&realtype t, N\_Vector y, \\
                                     &N\_Vector yB, N\_Vector fyB, \\ 
                                     &booleantype jokB, booleantype *jcurPtrB, \\
                                     &realtype gammaB, void *user\_dataB,\\
                                     &N\_Vector tmp1B, N\_Vector tmp2B, \\
                                     &N\_Vector tmp3B);
}
{
  This function preprocesses and/or evaluates Jacobian-related data needed
  by the preconditioner for the backward problem.
}
{
  The arguments of a \id{CVSpilsPrecSetupFnB} are as follows:
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the dependent variable vector.
  \item[fyB]
    is the current value of the dependent variable vector.
  \item[jokB]
    is an input flag indicating whether Jacobian-related
    data needs to be recomputed (\id{jokB}=\id{FALSE}) or information saved 
    from a previous invokation can be safely used (\id{jokB}=\id{TRUE}).
  \item[jcurPtr]
    is an output flag which must be set to \id{TRUE} if Jacobian-relatd data 
    was recomputed or \id{FALSE} otherwise.
  \item[gammaB]
    is the scalar appearing in the Newton matrix.
  \item[user\_dataB]
    is a pointer to user data - the same as the \id{user\_dataB}
    parameter passed to the function \id{CVodeSetUserDataB}.
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated for vectors which can be used           
    as temporary storage or work space.    
  \end{args}
}
{
  The return value of a preconditioner setup function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried),     
  or negative for an unrecoverable error (in which case the integration is halted).
}
{}


%%
%%-------------------------------------------------------------------
%%-------------------------------------------------------------------
\section{Using CVODES preconditioner modules for the backward problem}
%%-------------------------------------------------------------------
%%-------------------------------------------------------------------
%%

As on the forward integration phase, the efficiency of Krylov iterative methods 
for the solution of linear systems can be greatly enhanced through preconditioning.
Both preconditioner modules provided with {\sundials}, the banded
preconditioner {\cvbandpre} and the band-block-diagonal preconditioner module {\cvbbdpre},
provide interface functions through which they can be used on the backward integration phase.


%%-------------------------------------------------------------------
\subsection{Using the banded preconditioner CVBANDPRE}
%%-------------------------------------------------------------------

\index{CVBANDPRE@{\cvbandpre} preconditioner!usage with adjoint module|(}
The adjoint module in {\cvodes} offers an interface to the banded 
preconditioner module {\cvbandpre} described in section \S\ref{sss:cvbandpre}.
This preconditioner provides a band matrix preconditioner based on difference
quotients of the backward problem right-hand side function \id{fB}. It generates
a banded approximation to the Jacobian with $m_{lB}$ sub-diagonals and $m_{uB}$
super-diagonals to be used with one of the Krylov linear solvers.

In order to use the {\cvbandpre} module in the solution of the backward problem,
the user need not define any additional functions. 
Instead, {\em after} one of the {\cvspils} linear solvers has been specified,
by calling the appropriate function (see \S\ref{sss:lin_solv_b}), the following call
to the {\cvbandpre} module initialization function must be made.
%%
%%
\index{CVBANDPRE@{\cvbandpre} preconditioner!user-callable functions|(}
\ucfunction{CVBandPrecInitB}
{
  flag = CVBandPrecInitB(cvode\_mem, which, nB, muB, mlB);
}
{
  The function \ID{CVBandPrecInitB} initializes and allocates
  memory for the {\cvbandpre} preconditioner for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[nB] (\id{long int})
    backward problem dimension.
  \item[muB] (\id{long int})
    upper half-bandwidth of the backward problem Jacobian approximation.
  \item[mlB] (\id{long int})
    lower half-bandwidth of the backward problem Jacobian approximation.
  \end{args}
}
{
  If successful, \id{CVBandPrecInit} creates, allocates, and stores (internally
  in the {\cvodes} solver block) a pointer to the newly created 
  {\cvbandpre} memory block.
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}]
    The call to \id{CVodeBandPrecInitB} was successful.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} argument was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    No linear solver has been attached.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    An invalid parameter has been passed.
  \end{args}
}
{}
%%
%%
\index{CVBANDPRE@{\cvbandpre} preconditioner!user-callable functions|)}
For more details on {\cvbandpre} see \S\ref{sss:cvbandpre}.
\index{CVBANDPRE@{\cvbandpre} preconditioner!usage with adjoint module|)}



%%-------------------------------------------------------------------
\subsection{Using the band-block-diagonal preconditioner CVBBDPRE}
%%-------------------------------------------------------------------
\index{CVBBDPRE@{\cvbbdpre} preconditioner!usage with adjoint module|(}
The adjoint module in {\cvodes} offers an interface to the band-block-diagonal
preconditioner module {\cvbbdpre} described in section \S\ref{sss:cvbbdpre}.
This generates a preconditioner that is a block-diagonal matrix with each
block being a band matrix and can be used with one of the Krylov linear solvers
and with the parallel vector module {\nvecp}.

In order to use the {\cvbbdpre} module in the solution of the backward problem,
the user must define one or two additional functions, described at the end of this section. 

\subsection{Usage of CVBBDPRE for the backward problem}
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-callable functions|(}
The {\cvbbdpre} module is initialized by calling the following function,
{\em after} one of the {\cvspils} linear solvers has been specified,
by calling the appropriate function (see \S\ref{sss:lin_solv_b}).
%%
%%
\ucfunction{CVBBDPrecInitB}
{
  \begin{tabular}[t]{@{}r@{}l@{}}
    flag = CVBBDPrecInitB(&cvode\_mem, int which, NlocalB, \\
                           &mudqB, mldqB, \\
                           &mukeepB, mlkeepB, \\
                           &dqrelyB, glocB, gcommB);
  \end{tabular}
}
{
  The function \ID{CVBBDPrecInitB} initializes and allocates
  memory for the {\cvbbdpre} preconditioner for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[NlocalB] (\id{int})
    local vector dimension for the backward problem.
  \item[mudqB] (\id{int})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldqB] (\id{int})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mukeepB] (\id{int})
    upper half-bandwidth of the retained banded approximate Jacobian block.
  \item[mlkeepB] (\id{int})
    lower half-bandwidth of the retained banded approximate Jacobian block.
  \item[dqrelyB] (\id{realtype})
    the relative increment in components of \id{yB} used in the difference quotient
    approximations.  The default is \id{dqrelyB}$ = \sqrt{\text{unit roundoff}}$, which
    can be specified by passing \id{dqrely}$ = 0.0$.
  \item[glocB] (\id{CVBBDLocalFnB})
    the {\C} function which computes the approximation $g_B(t,y,y_B)$ 
    to the right-hand side of the backward problem. 
  \item[gcommB] (\id{CVBBDCommFnB})
    the optional {\C} function which performs all interprocess communication required for
    the computation of $g_B$.
  \end{args}
}
{
  If successful, \id{CVodeBBDPrecInitB} creates, allocates, and stores (internally
  in the {\cvodes} solver block) a pointer to the newly created 
  {\cvbbdpre} memory block.
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}]
    The call to \id{CVodeBBDPrecInitB} was successful.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} argument was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    No linear solver has been attached.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    An invalid parameter has been passed.
  \end{args}
}
{}
%%
%%
To reinitialize the {\cvbbdpre} preconditioner module for the backward problem
call the following function:
%%
\ucfunction{CVBBDPrecReInitB}
{
  flag = CVBBDPrecReInitB(cvode\_mem, which, mudqB, mldqB, dqrelyB);
}
{
  The function \ID{CVBBDPrecReInitB} reinitializes the {\cvbbdpre} preconditioner
  for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeInit}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[mudqB] (\id{int})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldqB] (\id{int})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[dqrelyB] (\id{realtype})
    the relative increment in components of \id{yB} used in the difference quotient
    approximations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}]
    The call to \id{CVodeBBDPrecReInitB} was successful.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} argument was \id{NULL}.
  \item[\Id{CVSPILS\_PMEM\_NULL}]
    The \id{CVodeBBDPrecInitB} has not been previously called.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    No linear solver has been attached.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    An invalid parameter has been passed.
  \end{args}
}
{}
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-callable functions|)}
%%
For more details on {\cvbbdpre} see \S\ref{sss:cvbbdpre}.

\subsection{User-supplied functions for CVBBDPRE}
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-supplied functions|(}
To use the {\cvbbdpre} module, the user must supply one or two functions which the
module calls to construct the preconditioner: a required function \id{glocB} 
(of type \id{CVBBDLocalFnB}) which approximates the right-hand side of the backward
problem and which is computed locally, and an optional function \id{gcommB} 
(of type \id{CVBBDCommFnB}) which performs all interprocess communication necessary 
to evaluate this approximate right-hand side (see \S\ref{sss:cvbbdpre}).
The prototypes for these two functions are described below.
%%
%%
\usfunction{CVBBDLocalFnB}
{
  typedef int (*CVBBDLocalFnB)(&int NlocalB, realtype t,  \\
  &N\_Vector y, N\_Vector yB, \\
  &N\_Vector gB, \\
  &void *user\_dataB);
}
{
  This function loads the vector \id{gB}, an approximation to the
  right-hand side of the backward problem, as a function of \id{t}, \id{y},
  and \id{yB}.
}
{
  \begin{args}[user\_dataB]
  \item[NlocalB] 
    is the local vector length for the backward problem.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the dependent variable vector.
  \item[gB]
    is the output vector.
  \item[user\_dataB]
    is a pointer to user data - the same as the \Id{user\_dataB}      
    parameter passed to \id{CVodeSetUserDataB}.  
  \end{args}
}
{
  An \id{CVBBDLocalFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_LSETUP\_FAIL}). 
}
{
  This routine assumes that all interprocess communication of data needed to 
  calculate \id{gB} has already been done, and this data is accessible within
  \id{user\_dataB}.

  {\warn}Before calling the user's \id{CVBBDLocalFnB}, {\cvodea} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurrs in the interpolation, {\cvodea} triggers an unrecoverable
  failure in the preconditioner setup function which will halt the integration
  (\id{CVodeB} returns \id{CV\_LSETUP\_FAIL}).
}
%%
%%
\usfunction{CVBBDCommFnB}
{
  typedef int (*CVBBDCommFnB)(&int NlocalB, realtype t,  \\
                           &N\_Vector y, N\_Vector yB, \\
                           &void *user\_dataB);
}
{
  This function performs all interprocess communications necessary 
  for the execution of the \id{glocB} function above, using the input 
  vectors \id{y} and \id{yB}.
}
{
  \begin{args}[user\_dataB]
  \item[NlocalB] 
    is the local vector length.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the dependent variable vector.
  \item[user\_dataB]
    is a pointer to user data - the same as the \Id{user\_dataB}
    parameter passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  An \id{CVBBDCommFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_LSETUP\_FAIL}). 
}
{
  The \id{gcommB} function is expected to save communicated data in space defined within the
  structure \id{user\_dataB}. 

  Each call to the \id{gcommB} function is preceded by a call to the function that 
  evaluates the right-hand side of the backward problem with the same \id{t}, \id{y}, 
  and \id{yB}, arguments. If there is no additional communication needed, then 
  pass \id{gcommB} $=$ \id{NULL} to \id{CVBBDPrecInitB}.
}
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-supplied functions|)}
%%
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!usage with adjoint module|)}
