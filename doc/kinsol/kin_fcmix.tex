%%==============================================================================
\chapter{FKINSOL, an Interface Module for FORTRAN Applications}\label{s:fcmix}
%%==============================================================================

The {\fkinsol} interface module is a package of {\CC} functions which support
the use of the {\kinsol} solver, for the solution of nonlinear systems
$F(u)=0$, in a mixed {\F}/{\CC} setting.  While {\kinsol} is written
in {\CC}, it is assumed here that the user's calling program and
user-supplied problem-defining routines are written in {\F}.
This package provides the necessary interface to {\kinsol} for all supplied
serial and parallel {\nvector} implementations.

%%==============================================================================
% Pull in sections on portability and data types.
%%==============================================================================
\input{fortran}

%% In this package, the names of the interface functions, and the names of
%% the {\F} user routines called by them, appear as dummy names
%% which are mapped to actual values by a series of definitions in the
%% header files \id{fkinsol.h} and \id{fkinbbd.h}.
%% By default, those mapping definitions depend in turn on the {\CC} macro
%% \id{F77\_FUNC} defined in the header file \id{sundials\_config.h} and
%% decided upon at configuration time (see Appendix \ref{c:install}).

%% The user must also ensure that variables in the user {\F} code are
%% declared in a manner consistent with their counterparts in {\kinsol}.
%% All real variables must be declared as \id{REAL}, \id{DOUBLE PRECISION},
%% or perhaps as \id{REAL*}{\em n}, where {\em n} denotes the number of bytes,
%% depending on whether {\kinsol} was built in single, double or extended precision 
%% (see Appendix \ref{c:install}). Moreover, some of the {\F} integer variables
%% must be declared as \id{INTEGER*4} or \id{INTEGER*8} according to the 
%% {\CC} type \id{long int}. These integer variables include:
%% the optional input (\id{IVAL}), the problem size and bandwidth parameters
%% (\id{NEQ}, \id{NLOCAL}, \id{NGLOBAL}, \id{ML}, \id{MU}, etc.),
%% and the array of integer optional outputs (\id{IOUT}).
%% EXCEPTION: In the case that Lapack linear solvers are to be used, the
%% input arguments to \id{FKINLAPACKDENSE} or \id{FKINLAPACKBAND} (\id{NEQ},
%% \id{ML}, and \id{MU}) must be declared to be consistent with {\CC} type \id{int}.
%% This type consistency is particularly important when using
%% {\kinsol} and the {\fkinsol} package on 64-bit architectures.

%%==============================================================================
\section{FKINSOL routines}\label{sss:fkinroutines}
%%==============================================================================

\index{FKINSOL@{\fkinsol} interface module!user-callable functions|(}
The user-callable functions, with the corresponding {\kinsol} functions,
are as follows:
\begin{itemize}
\item
  Interface to the {\nvector} modules
  \begin{itemize}
  \item \id{FNVINITS} (defined by {\nvecs}) 
    interfaces to \id{N\_VNewEmpty\_Serial}.
  \item \id{FNVINITP} (defined by {\nvecp}) 
    interfaces to \id{N\_VNewEmpty\_Parallel}.
  \item \id{FNVINITOMP} (defined by {\nvecopenmp}) 
    interfaces to \id{N\_VNewEmpty\_OpenMP}.
  \item \id{FNVINITPTS} (defined by {\nvecpthreads}) 
    interfaces to \id{N\_VNewEmpty\_Pthreads}.
%  \item \id{FNVINITPH} (defined by {\nvecph}) 
%    interfaces to \id{N\_VNewEmpty\_ParHyp}.
  \end{itemize}
\item Interface to the main {\kinsol} module
  \begin{itemize}
  \item \id{FKINCREATE}
    interfaces to \id{KINCreate}.
  \item \id{FKINSETIIN} and \id{FKINSETRIN}
    interface to \id{KINSet*} functions.
  \item \id{FKININIT}
    interfaces to \id{KINInit}.
  \item \id{FKINSETVIN}
    interfaces to \id{KINSetConstraints}.
  \item \id{FKINSOL}
    interfaces to \id{KINSol}, \id{KINGet*} functions, and to the optional
    output functions for the selected linear solver module.
  \item \id{FKINFREE}    
    interfaces to \id{KINFree}.
  \end{itemize}  
\item Interface to the linear solver modules
  \begin{itemize}
  \item \id{FKINDENSE}
    interfaces to \id{KINDense}.
  \item \id{FKINDENSESETJAC}
    interfaces to \id{KINDlsSetDenseJacFn}.
  \item \id{FKINLAPACKDENSE}
    interfaces to \id{KINLapackDense}.
  \item \id{FKINLAPACKDENSESETJAC}
    interfaces to \id{KINDlsSetDenseJacFn}.
  \item \id{FKINBAND}
    interfaces to \id{KINBand}.
  \item \id{FKINBANDSETJAC}
    interfaces to \id{KINDlsSetBandJacFn}.
  \item \id{FKINLAPACKBAND}
    interfaces to \id{KINLapackBand}.
  \item \id{FKINLAPACKBANDSETJAC}
    interfaces to \id{KINDlsSetBandJacFn}.
  \item \id{FKINKLU}
    interfaces to \id{KINKLU}.
  \item \id{FKINKLUREINIT}
    interfaces to \id{KINKLUReInit}.
  \item \id{FKINSUPERLUMT}
    interfaces to \id{KINSuperLUMT}.
  \item \id{FKINSPARSESETJAC}
    interfaces to \id{KINSlsSetSparseJacFn}.
  \item \id{FKINSPGMR}
    interfaces to \id{KINSpgmr} and {\spgmr} optional input functions.
  \item \id{FKINSPFGMR}
    interfaces to \id{KINSpfgmr} and {\spfgmr} optional input functions.
  \item \id{FKINSPBCG}
    interfaces to \id{KINSpbcg} and {\spbcg} optional input functions.
  \item \id{FKINSPTFQMR}
    interfaces to \id{KINSptfqmr} and {\sptfqmr} optional input functions.
  \item \id{FKINSPILSSETJAC}
    interfaces to \id{KINSpilsSetJacTimesVecFn}.
  \item \id{FKINSPILSSETPREC}
    interfaces to \id{KINSpilsSetPreconditioner}.
 \end{itemize}

\end{itemize}
\index{FKINSOL@{\fkinsol} interface module!user-callable functions|)}

\index{FKINSOL@{\fkinsol} interface module!user-supplied functions}
The user-supplied functions, each listed with the corresponding internal
interface function which calls it (and its type within {\kinsol}), are as follows:
\begin{center}
\begin{tabular}{l||l|l}
{\fkinsol} routine      &  {\kinsol} function & {\kinsol} type of \\
({\F}, user-supplied)  &  ({\CC}, interface) & interface function \\ \hline\hline
\id{FKFUN}    & \id{FKINfunc}           & \id{KINSysFn} \\
\id{FKDJAC}   & \id{FKINDenseJac}       & \id{KINDlsDenseJacFn} \\
{}            & \id{FKINLapackDenseJac} & \id{KINDlsDenseJacFn} \\
\id{FKBJAC}   & \id{FKINBandJac}        & \id{KINDlsBandJacFn} \\
{}            & \id{FKINLapackBandJac}  & \id{KINDlsBandJacFn} \\
\id{FKINSPJAC} & \id{FKINSparseJac}     & \id{KINSlsSparseJacFn} \\
\id{FKPSET}   & \id{FKINPSet}           & \id{KINSpilsPrecSetupFn} \\
\id{FKPSOL}   & \id{FKINPSol}           & \id{KINSpilsPrecSolveFn} \\
\id{FKJTIMES} & \id{FKINJtimes}         & \id{KINSpilsJacTimesVecFn} \\
\end{tabular}
\end{center}
In contrast to the case of direct use of {\kinsol}, the names of all 
user-supplied routines here are fixed, in order to maximize portability 
for the resulting mixed-language program.

%%==============================================================================
\section{Usage of the FKINSOL interface module}\label{ss:fkinsol_usage}
%%==============================================================================
\index{FKINSOL@{\fkinsol} interface module!usage|(}

The usage of {\fkinsol} requires calls to a few different interface
functions, depending on the method options selected, and one or more
user-supplied routines which define the problem to be solved.  These
function calls and user routines are summarized separately below.
Some details are omitted, and the user is referred to the description
of the corresponding {\kinsol} functions for information on the arguments 
of any given user-callable interface routine, or of a given user-supplied 
function called by an interface function.

%
\index{User main program!FKINSOL@{\fkinsol} usage}
\begin{Steps}
 
%%====================
\item {\bf Nonlinear system function specification}
%%====================
  
  The user must, in all cases, supply the following {\F} routine
  \index{FKFUN@\texttt{FKFUN}}
\begin{verbatim}
      SUBROUTINE FKFUN (U, FVAL, IER)
      DIMENSION U(*), FVAL(*)
\end{verbatim}
  It must set the \id{FVAL} array to $F(u)$, the system function,
  as a function of \id{U =} $u$.  
  \id{IER} is an error return flag which should be set to $0$ if successful,
  a positive value if a recoverable error occurred (in which case {\kinsol}
  will attempt to correct), or a negative value if it failed unrecoverably
  (in which case the solution process is halted).

%%====================
\item  {\bf {\nvector} module initialization}
%%====================

  If using one of the {\nvector} modules supplied with {\sundials},
  the user must make a call of the form
\begin{verbatim}
      CALL FNVINIT***(...)
\end{verbatim}
in which the name and call sequence are as described in the appropriate
section of Chapter \ref{s:nvector}.

%%====================
\item {\bf Problem specification}
%%====================

  To create the main solver memory block, make the following call:
  \index{FKINCREATE@\texttt{FKINCREATE}}
  \ucfunction{FKINCREATE}
  {
    \begin{tabular}[t]{@{}r@{}l@{}l@{}}
        &CALL FKINCREATE (IER)
    \end{tabular}
  }
  {
    This function creates the {\kinsol} memory structure.
  }
  {
    \begin{args}[IOUT\,]
    \item[None.]
    \end{args}
  }
  {
    \id{IER} is the return completion flag. Values are $0$ for successful return
    and $-1$ otherwise. See printed message for details in case of failure.
  }
  {
  }

%%====================
\item\label{i:fkinsol_opt_input}{\bf Set optional inputs} 
%%====================

  Call \id{FKINSETIIN}, \id{FKINSETRIN}, and/or \id{FKINSETVIN}, to set desired 
  optional inputs, if any.  See \S\ref{fkin_opt_inout} for details.

%%====================
\item {\bf Solver Initialization}
%%====================

  To set various problem and solution parameters and allocate
  internal memory, make the following call:
  \index{FKININIT@\texttt{FKININIT}}
  \ucfunction{FKININIT}
  {
    \begin{tabular}[t]{@{}r@{}l@{}l@{}}
        &CALL FKININIT (IOUT, ROUT, IER)
    \end{tabular}
  }
  {
    This function specifies the optional output arrays,
    allocates internal memory, and initializes {\kinsol}.
  }
  {
    \begin{args}[IOUT\,]
    \item[IOUT] is an integer array for integer optional outputs.
    \item[ROUT] is a real array for real optional outputs.
    \end{args}
  }
  {
    \id{IER} is the return completion flag. Values are $0$ for successful return
    and $-1$ otherwise. See printed message for details in case of failure.
  }
  {
    The user integer data array \id{IOUT} must be declared as \id{INTEGER*4} or
    \id{INTEGER*8} according to the {\CC} type \id{long int}.

    The optional outputs associated with the main {\kinsol} integrator
    are listed in Table~\ref{t:fkinsol_out}.
  }

%%====================
\item\label{i:fkinsol_lin_solv_spec}{\bf Linear solver specification} 
%%====================

  The solution method in {\kinsol} involves the solution of linear systems 
  related to the Jacobian of the nonlinear system. The user of 
  {\fkinsol} must call a routine with a specific name to make the desired
  choice of linear solver.
  Note that the direct (dense or band) and sparse linear solver options are
  usable only in a serial environment.


  %%-------------------------------------------------

  {\bf Dense treatment of the linear system}
  \index{KINDENSE@{\kindense} linear solver!use in {\fkinsol}}
  
  To use the direct dense linear solver based on the internal {\kinsol}
  implementation, the user must make the call:
  \index{FKINDENSE@\texttt{FKINDENSE}}
\begin{verbatim}
      CALL FKINDENSE (NEQ, IER)
\end{verbatim}
  where \id{NEQ} is the size of the nonlinear system.
  The argument \id{IER} is an error return flag which is $0$ for success , 
  $-1$ if a memory allocation failure occurred, or $-2$ for illegal input.

  Alternatively, to use the Lapack-based direct dense linear solver, 
  the user must make the call:
\begin{verbatim}
      CALL FKINLAPACKDENSE(NEQ, IER)
\end{verbatim}
  where the arguments have the same meanings as for \id{FKINDENSE}, except
  that here \id{NEQ} must be declared so as to match {\CC} type \id{int}.

  \index{Jacobian approximation function!dense!use in {\fkinsol}}
  As an option when using the {\dense} linear solver, the user may supply a
  routine that computes a dense approximation of the system Jacobian 
  $J = \partial F / \partial u$. If supplied, it must have the following form:
  \index{FKDJAC@\texttt{FKDJAC}}
\begin{verbatim}
      SUBROUTINE FKDJAC (NEQ, U, FVAL, DJAC, WK1, WK2, IER)
      DIMENSION U(*), FVAL(*), DJAC(NEQ,*), WK1(*), WK2(*)
\end{verbatim}
  Typically this routine will use only \id{NEQ}, \id{U}, and \id{DJAC}. 
  It must compute the Jacobian and store it columnwise in \id{DJAC}.
  The input arguments \id{U} and \id{FVAL} contain the current
  values of $u$ and $F(u)$, respectively.
  The vectors \id{WK1} and \id{WK2},
  of length \id{NEQ}, are provided as work space for use in \id{FKDJAC}.
  \id{IER} is an error return flag which should be set to $0$ if successful,
  a positive value if a recoverable error occurred (in which case {\kinsol}
  will attempt to correct), or a negative value if \id{FKDJAC} failed
  unrecoverably (in which case the solution process is halted).
  NOTE: The argument \id{NEQ} has a type consistent with {\CC} type \id{long int}
  even in the case when the Lapack dense solver is to be used.

  If the \id{FKDJAC} routine is provided, then, 
  following the call to \id{FKINDENSE}, the user must make the call:
  \index{FKINDENSESETJAC@\texttt{FKINDENSESETJAC}}
\begin{verbatim}
      CALL FKINDENSESETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied Jacobian
  approximation.  The argument \id{IER} is an error return flag which is $0$ 
  for success or non-zero if an error occurred.
  If using the Lapack-based direct dense linear solver, the use of a
  Jacobian approximation supplied by the user is indicated through the call
\begin{verbatim}
      CALL FKINLAPACKDENSESETJAC (FLAG, IER)
\end{verbatim}

  Optional outputs specific to the {\dense} case are listed in
  Table~\ref{t:fkinsol_out}.

  %%-------------------------------------------------

  {\bf Band treatment of the linear system}
  \index{KINBAND@{\kinband} linear solver!use in {\fkinsol}}
  
  To use the direct band linear solver based on the internal {\kinsol}
  implementation, the user must make the call:
  \index{FKINBAND@\texttt{FKINBAND}}
\begin{verbatim}
      CALL FKINBAND (NEQ, MU, ML, IER)
\end{verbatim}
  The arguments are: \id{MU}, the upper half-bandwidth; \id{ML}, 
  the lower half-bandwidth; and \id{IER}, an error return flag which is 
  $0$ for success , $-1$ if a memory allocation failure occurred, or $-2$ 
  in case an input has an illegal value.     
  
  Alternatively, to use the Lapack-based direct band linear solver, 
  the user must make the call:
\begin{verbatim}
      CALL FKINLAPACKBAND(NEQ, MU, ML, IER)
\end{verbatim}
  where the arguments have the same meanings as for \id{FKINBAND}, except
  that here \id{NEQ}, \id{MU}, and \id{ML} must be declared so as to match
  {\CC} type \id{int}.

  \index{Jacobian approximation function!band!use in {\fkinsol}}
  As an option when using the {\band} linear solver, the user may supply a
  routine that computes a band approximation of the system Jacobian 
  $J = \partial F / \partial u$. If supplied, it must have the following form:
  \index{FKBJAC@\texttt{FKBJAC}}
\begin{verbatim}
      SUBROUTINE FKBJAC (NEQ, MU, ML, MDIM, U, FVAL, BJAC, WK1, WK2, IER)
      DIMENSION U(*), FVAL(*), BJAC(MDIM,*), WK1(*), WK2(*)
\end{verbatim}
  Typically this routine will use only \id{NEQ}, \id{MU}, \id{ML},
  \id{U}, and \id{BJAC}.
  It must load the \id{MDIM} by \id{N} array \id{BJAC} with the Jacobian matrix
  at the current $u$ in band form.  Store in \id{BJAC}$(k,j)$ the Jacobian
  element $J_{i,j}$ with $k = i - j + $ \id{MU} $ + 1$ ($k = 1 \cdots $
  \id{ML + MU + 1}) and $j = 1 \cdots N$.
  The input arguments \id{U} and \id{FVAL} contain the current
  values of $u$, and $F(u)$, respectively.
  The vectors \id{WK1} and \id{WK2}
  of length \id{NEQ} are provided as work space for use in
  \id{FKBJAC}.
  \id{IER} is an error return flag, which should be set to $0$ if successful,
  a positive value if a recoverable error occurred (in which case {\kinsol} will
  attempt to correct), or a negative value if \id{FKBJAC} failed unrecoverably
  (in which case the solution process is halted).
  NOTE: The arguments \id{NEQ}, \id{MU}, \id{ML}, and \id{MDIM} have a type
  consistent with {\CC} type \id{long int} even in the case when the Lapack band
  solver is to be used.

  If the \id{FKBJAC} routine is provided, then, following the call to \id{FKINBAND},
  the user must make the call:
  \index{FKINBANDSETJAC@\texttt{FKINBANDSETJAC}}
\begin{verbatim}
      CALL FKINBANDSETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied Jacobian approximation.
  The argument \id{IER} is an error return flag which is $0$ 
  for success or non-zero if an error occurred.
  If using the Lapack-based direct band linear solver, the use of a
  Jacobian approximation supplied by the user is indicated through the call
\begin{verbatim}
      CALL FKINLAPACKNBANDSETJAC (FLAG, IER)
\end{verbatim}

  Optional outputs specific to the {\band} case are listed in Table~\ref{t:fkinsol_out}.

  %%-------------------------------------------------

  {\bf Sparse direct treatment of the linear system}
  \index{KINSPARSE@{\kinsparse} linear solver!use in {\fkinsol}}
  
  To use the KLU sparse direct linear solver,
  the user must make the call:
  \index{FKINKLU@\texttt{FKINKLU}}
\begin{verbatim}
      CALL FKINKLU (NEQ, NNZ, SPARSETYPE, ORDERING, IER)
\end{verbatim}
  where \id{NEQ} is the size of the nonlinear system, 
  \id{NNZ} is the maximum number of nonzeros in the Jacobian matrix,
  \id{SPARSETYPE} is a flag indicating whether the matrix is in
  compressed-sparse-column or compressed-sparse-row format (0 = CSC, 1
  = CSR), and \id{ORDERING} is the matrix ordering desired with possible values
  from the KLU package (0 = AMD, 1 = COLAMD).
  The argument \id{IER} is an error return flag which is $0$ for success 
  or negative for an error.

 
  \index{FKINKLUREINIT@\texttt{FKINKLURENIT}}
 The {\kinsol} KLU solver will reuse much of the factorization 
 information from one nonlinear iteration to the next.  If at any time 
 the user wants to force a full refactorization, or if the number of 
 nonzeros in the Jacobian matrix changes, the user should make the call
\begin{verbatim}
       CALL FKINKLUREINIT(NEQ, NNZ, REINIT_TYPE)
\end{verbatim}
  where \id{NEQ} is the size of the nonlinear system, 
  \id{NNZ} is the maximum number of nonzeros in the Jacobian matrix,
  and \id{REINIT\_TYPE} is 1 or 2.  For a value of 1, the matrix will be 
  destroyed and a new one will be allocated with \id{NNZ} nonzeros.  
  For a value of 2, only symbolic and numeric factorizations 
  will be completed. 

  \index{FKINSUPERLUMT@\texttt{FKINSUPERLUMT}}
  Alternatively, to use the \id{SuperLUMT} linear solver,
  the user must make the call:
\begin{verbatim}
      CALL FKINSUPERLUMT (NEQ, NNZ, ORDERING, IER)
\end{verbatim}
  where the arguments have the same meanings as for \id{FKINKLU}, except
  that here possible values for \id{ORDERING} derive from the {\superlumt} 
  package and include: 0 for Natural ordering, 1 for Minimum degree on $A^T A$,
  2 for Minimum degree on $A^T + A$, and 3 for COLAMD.

  \index{FKINSPJAC@\texttt{FKINSPJAC}}
  If the either of the sparse direct interface packages are used, 
  then the user must supply the \id{FKINSPJAC} routine
  that computes a compressed-sparse-column [or compressed-sparse-row if using KLU]
  approximation of the system Jacobian $J = \partial F / \partial u$.
  If supplied, it must have the following form:
\begin{verbatim}
       SUBROUTINE FKINSPJAC(Y, FY, N, NNZ, JDATA, JRVALS, 
      &                     JCPTRS, WK1, WK2, IER)
\end{verbatim}
  Typically this routine will use only \id{N, NNZ, JDATA, JRVALS} and 
  \id{JCPTRS}. It must load the \id{N} by \id{N} 
  compressed sparse column  [or compressed sparse row] matrix 
  with storage for \id{NNZ} nonzeros, stored in the arrays \id{JDATA} (nonzero
  values), \id{JRVALS} (row [or column] indices for each nonzero), \id{JCOLPTRS} (indices 
  for start of each column [or row]), with the Jacobian matrix at the current
  (y) in CSC [or CSR] form (see \id{sundials\_sparse.h} for more information).
 The arguments are \id{Y}, an array containing state variables; \id{FY}, an
 array containing residual values; \id{N}, the number of matrix rows/columns 
 in the Jacobian; \id{NNZ}, allocated length of nonzero storage; \id{JDATA},
 nonzero values in the Jacobian (of length \id{NNZ}); 
 \id{JRVALS}, row [or column] indices for each nonzero in Jacobian (of length \id{NNZ});
 \id{JCPTRS}, pointers to each Jacobian column [or row] in the two preceding arrays
 (of length \id{N}+1); \id{WK*}, work arrays containing temporary workspace 
 of same size as \id{Y}; and \id{IER}, error return code (0 if successful,
 $>0$ if a recoverable error occurred, or $<0$ if an unrecoverable error occurred.)

  To indicate that the \id{FKINSPJAC} routine has been provided, then
  following either the call to \id{FKINKLU} or \id{FKINSUPERLUMT}, the
  following call must be made    
  \index{FKINSPARSESETJAC@\texttt{FKINSPARSESETJAC}}
\begin{verbatim}
      CALL FKINSPARSESETJAC (IER)
\end{verbatim}
  The int return flag \id{IER} is an error return flag which is $0$
  for success or nonzero for an error.

  Optional outputs specific to the {\sparse} case are listed in
  Table~\ref{t:fkinsol_out}.

  %%-------------------------------------------------
  
  {\bf SPGMR and SPFGMR treatment of the linear systems}
  \index{KINSPGMR@{\kinspgmr} linear solver!use in {\fkinsol}}
  \index{KINSPFGMR@{\kinspfgmr} linear solver!use in {\fkinsol}}

  For the Scaled Preconditioned GMRES 
  or the Scaled Preconditioned Flexible GMRES solution of the linear systems,
  the user must make either the call
  \index{FKINSPGMR@\texttt{FKINSPGMR}}
\begin{verbatim}
      CALL FKINSPGMR (MAXL, MAXLRST, IER)
\end{verbatim}
or the call
\index{FKINSPFGMR@\texttt{FKINSPFGMR}}
\begin{verbatim}
      CALL FKINSPFGMR (MAXL, MAXLRST, IER)
\end{verbatim}
  The arguments are as follows.
  \id{MAXL} is the maximum Krylov subspace dimension.
  \id{MAXLRST} is the maximum number of restarts.
  \id{IER} is an error return flag which is $0$ to indicate success, $-1$
  if a memory allocation failure occurred, or $-2$ to indicate an illegal input.
  
  Optional outputs specific to the {\spgmr} and {\spfgmr} cases are listed in
  Table~\ref{t:fkinsol_out}.

  For descriptions of the relevant optional user-supplied routines, see 
  {\bf User-supplied routines for SPGMR/SPFMGR/SPBCG/SPTFQMR} below.
  
  %%-------------------------------------------------
  
  {\bf SPBCG treatment of the linear systems}
  \index{KINSPBCG@{\kinspbcg} linear solver!use in {\fkinsol}}
  
  For the Scaled Preconditioned Bi-CGStab solution of the linear systems,
  the user must make the call
  \index{FKINSPBCG@\texttt{FKINSPBCG}}
\begin{verbatim}
      CALL FKINSPBCG (MAXL, IER)
\end{verbatim}
  Its arguments are the same as those with the same names for \id{FKINSPGMR}.

  Optional outputs specific to the {\spbcg} case are listed in
  Table~\ref{t:fkinsol_out}.

  For descriptions of the relevant optional user-supplied routines, see below.
  
  %%-------------------------------------------------
  
  {\bf SPTFQMR treatment of the linear systems}
  \index{KINSPTFQMR@{\kinsptfqmr} linear solver!use in {\fkinsol}}
  
  For the Scaled Preconditioned Transpose-Free Quasi-Minimal Residual solution 
  of the linear systems, the user must make the call
  \index{FKINSPTFQMR@\texttt{FKINSPTFQMR}}
\begin{verbatim}
      CALL FKINSPTFQMR (MAXL, IER)
\end{verbatim}
  Its arguments are the same as those with the same names for \id{FKINSPGMR}.

  Optional outputs specific to the {\sptfqmr} case are listed in
  Table~\ref{t:fkinsol_out}.

  For descriptions of the relevant optional user-supplied routines, see below.

  %%-------------------------------------------------

  {\bf Functions used by SPGMR/SPFGMR/SPBCG/SPTFQMR}

  An optional user-supplied routine, \id{FKINJTIMES} (see below), can be provided for
  Jacobian-vector products.  
  (Note that this routine is required if Picard iteration is being used.)
  If it is, then, following the call to
  \id{FKINSPGMR}, \id{FKINSPFGMR}, \id{FKINSPBCG}, or \id{FKINSPTFQMR}, the user must make the call:
  \index{FKINSPILSSETJAC@\texttt{FKINSPILSSETJAC}}
\begin{verbatim}
      CALL FKINSPILSSETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied
  Jacobian-times-vector approximation.
  The argument \id{IER} is an error return flag which is $0$ 
  for success or non-zero if an error occurred.
  
  If preconditioning is to be done, then the user must call
  \index{FKINSPILSSETPREC@\texttt{FKINSPILSSETPREC}}
\begin{verbatim}
      CALL FKINSPILSSETPREC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$.  The return flag \id{IER} is 0 if
  successful, or negative if a memory error occurred.
  In addition, the user program must include
  preconditioner routines \id{FKPSOL} and \id{FKPSET} (see below).

  %%-------------------------------------------------

 {\bf User-supplied routines for SPGMR/SPFGMR/SPBCG/SPTFQMR}

  With treatment of the linear systems by any of the Krylov iterative
  solvers, there are three optional user-supplied routines ---
  \id{FKINJTIMES}, \id{FKPSOL}, and \id{FKPSET}.  The specifications
  for these routines are given below.

  \index{Jacobian approximation function!Jacobian times vector!use in {\fkinsol}}
  As an option when using the {\spgmr}, {\spfgmr}, {\spbcg}, or {\sptfqmr}  
  linear solvers, 
  the user may supply a routine that computes the product of the system Jacobian 
  $J = \partial F / \partial u$ 
  and a given vector $v$.  If supplied, it must have the following form:
  \index{FKINJTIMES@\texttt{FKINJTIMES}}
\begin{verbatim}
      SUBROUTINE FKINJTIMES (V, FJV, NEWU, U, IER)
      DIMENSION V(*), FJV(*), U(*)
\end{verbatim}
  Typically this routine will use only \id{U}, \id{V}, and \id{FJV}.
  It must compute the product vector $Jv$, where the vector $v$ is
  stored in \id{V}, and store the product in \id{FJV}.  
  The input argument \id{U} contains the current value of $u$.  On return, set
  \id{IER = 0} if \id{FKINJTIMES} was successful, and nonzero otherwise.
  \id{NEWU} is a flag to indicate if \id{U} has been changed since the last
  call; if it has, then \id{NEWU = 1}, and \id{FKINJTIMES} should recompute any
  saved Jacobian data it uses and reset \id{NEWU} to 0.  (See \S\ref{ss:jtimesFn}.)

  If preconditioning is to be included, the following routine must be
  supplied, for solution of the preconditioner linear system:
  \index{FKPSOL@\texttt{FKPSOL}}
\begin{verbatim}
      SUBROUTINE FKPSOL (U, USCALE, FVAL, FSCALE, VTEM, FTEM, IER)
      DIMENSION U(*), USCALE(*), FVAL(*), FSCALE(*), VTEM(*), FTEM(*)
\end{verbatim}
  Typically this routine will use only \id{U}, \id{FVAL}, \id{VTEM} and \id{FTEM}.
  It must solve the preconditioned linear system $Pz = r$, where
  $r = $ \id{VTEM} is input, and store the solution $z$ in \id{VTEM} as well. 
  Here $P$ is the right preconditioner. If scaling is being used, the
  routine supplied must also account for scaling on either coordinate
  or function value, as given in the arrays \id{USCALE} and
  \id{FSCALE}, respectively.
  
  If the user's preconditioner requires that any Jacobian-related data be evaluated
  or preprocessed, then the following routine can be used for the evaluation and
  preprocessing of the preconditioner:
  \index{FKPSET@\texttt{FKPSET}}
\begin{verbatim}
      SUBROUTINE FKPSET (U, USCALE, FVAL, FSCALE, VTEMP1, VTEMP2, IER)
      DIMENSION U(*), USCALE(*), FVAL(*), FSCALE(*), VTEMP1(*), VTEMP2(*)
\end{verbatim}
  It must perform any evaluation of Jacobian-related data and
  preprocessing needed for the solution of the preconditioned linear
  systems by \id{FKPSOL}. The variables \id{U} through \id{FSCALE} are for use in the
  preconditioning setup process. Typically, the system function \id{FKFUN} is
  called before any calls to \id{FKPSET}, so that \id{FVAL} will have
  been updated. \id{U} is the current solution
  iterate. The arrays \id{VTEMP1} and \id{VTEMP2} are available for work space. 
  If scaling is being used, \id{USCALE} and \id{FSCALE} are available for those operations
  requiring scaling.
  
  On return, set \id{IER} $= 0$ if \id{FKPSET} was successful, or set \id{IER} $= 1$
  if an error occurred.
  
  {\warn} If the user calls \id{FKINSPILSSETPREC}, the routine \id{FKPSET} must
  be provided, even if it is not needed, and then it should return \id{IER = 0}.

%%====================
\item {\bf Problem solution}
%%====================

  Solving the nonlinear system is accomplished by making the following call:
  \index{FKINSOL@\texttt{FKINSOL}}
\begin{verbatim}
      CALL FKINSOL (U, GLOBALSTRAT, USCALE, FSCALE, IER)
\end{verbatim}
  The arguments are as follows.
  \id{U} is an array containing the initial guess on input, and the
  solution on return.
  \id{GLOBALSTRAT} is an integer (type \id{INTEGER}) defining the global strategy 
  choice ($0$ specifies Inexact Newton, $1$ indicates Newton with line search,
  $2$ indicates Picard iteration, and $3$ indicates Fixed Point iteration).
  \id{USCALE} is an array of scaling factors for the \id{U} vector.
  \id{FSCALE} is an array of scaling factors for the \id{FVAL} vector.
  \id{IER} is an integer completion flag and will have one of the following values:
  $0$ to indicate success,
  $1$ to indicate that the initial guess satisfies $F(u) = 0$ within tolerances,
  $2$ to indicate apparent stalling (small step), or a negative value to indicate
  an error or failure. These values correspond to the \id{KINSol} returns
  (see \S\ref{sss:kinsol} and \S\ref{s:kinsol_out_constants}). The values of
  the optional outputs are available in \id{IOPT} and \id{ROPT}
  (see Table~\ref{t:fkinsol_out}).

%%====================
\item {\bf Memory deallocation}
%%====================

  To free the internal memory created by the calls to \id{FKINCREATE} and\id{FKININIT},
  make the call
  \index{FKINFREE@\texttt{FKINFREE}}
\begin{verbatim}
      CALL FKINFREE
\end{verbatim}

\end{Steps}
\index{FKINSOL@{\fkinsol} interface module!usage|)}


%%==============================================================================
\section{FKINSOL optional input and output}\label{fkin_opt_inout}
%%==============================================================================
\index{FKINSOL@{\fkinsol} interface module!optional input and output}

In order to keep the number of user-callable {\fkinsol} interface routines to
a minimum, optional inputs to the {\kinsol} solver are passed through only three
routines: \Id{FKINSETIIN} for integer optional inputs, \ID{FKINSETRIN} for real
optional inputs, and \ID{FKINSETVIN} for real vector (array) optional inputs.
These functions should be called as follows:
\begin{verbatim}
      CALL FKINSETIIN (KEY, IVAL, IER)
      CALL FKINSETRIN (KEY, RVAL, IER)
      CALL FKINSETVIN (KEY, VVAL, IER)
\end{verbatim}
where \id{KEY} is a quoted string indicating which optional input is set,
\id{IVAL} is the integer input value to be used,
\id{RVAL} is the real input value to be used, and
\id{VVAL} is the input real array to be used.
\id{IER} is an integer return flag which is set to $0$ on success and
a negative value if a failure occurred.
For the legal values of \id{KEY} in calls to \ID{FKINSETIIN} and \ID{FKINSETRIN},
see Table \ref{t:fkinsol_in}.  The one legal value of \id{KEY} for \ID{FKINSETVIN}
is \id{CONSTR\_VEC}, for providing the array of inequality constraints to be
imposed on the solution, if any.
The integer \id{IVAL} should be declared in a manner consistent with {\CC}
type \id{long int}.

The optional outputs from the {\kinsol} solver are accessed not through
individual functions, but rather through a pair of arrays, \Id{IOUT}
(integer type) of dimension at least $15$, and \Id{ROUT} (real type) of
dimension at least $2$.  These arrays are owned (and allocated) by the user
and are passed as arguments to \id{FKININIT}.
Table \ref{t:fkinsol_out} lists the entries in these two arrays and specifies the
optional variable as well as the {\kinsol} function which is actually called to
extract the optional output.

For more details on the optional inputs and outputs, see \S\ref{ss:optional_input}
and \S\ref{ss:optional_output}.

\begin{table}
\centering
\caption{Keys for setting {\fkinsol} optional inputs}
\label{t:fkinsol_in}
\medskip
\begin{tabular}{|r|c|l|}
\multicolumn{3}{c}{Integer optional inputs \id{FKINSETIIN}}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\
\hline
\Id{PRNT\_LEVEL}     & Verbosity level of output & $0$ \\
\Id{MAA}             & Number of prior residuals for Anderson Acceleration & 0 \\
\Id{MAX\_NITERS}     & Maximum no. of nonlinear iterations & $200$ \\
\Id{ETA\_FORM}       & Form of $\eta$ coefficient & $1$ (\id{KIN\_ETACHOICE1}) \\
\Id{MAX\_SETUPS}     & Maximum no. of iterations without prec. setup & $10$ \\
\Id{MAX\_SP\_SETUPS} & Maximum no. of iterations without residual check & $5$ \\
\Id{NO\_INIT\_SETUP} & No initial preconditioner setup & \id{FALSE} \\
\Id{NO\_MIN\_EPS}    & Lower bound on $\epsilon$ & \id{FALSE} \\
\Id{NO\_RES\_MON}    & No residual monitoring & \id{FALSE} \\
\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real optional inputs (\id{FKINSETRIN})}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\
\hline
\Id{FNORM\_TOL}   & Function-norm stopping tolerance & uround$^{1/3}$ \\
\Id{SSTEP\_TOL}   & Scaled-step stopping tolerance & uround$^{2/3}$ \\
\Id{MAX\_STEP}    & Max. scaled length of Newton step & $1000 \| D_u u_0 \|_2$ \\
\Id{RERR\_FUNC}   & Relative error for F.D. $Jv$ & $\sqrt{\text{uround}}$ \\
\Id{ETA\_CONST}   & Constant value of $\eta$ & $0.1$ \\
\Id{ETA\_PARAMS}  & Values of $\gamma$ and $\alpha$ & $0.9$ and $2.0$ \\
\Id{RMON\_CONST}  & Constant value of $\omega$ & $0.9$ \\
\Id{RMON\_PARAMS} & Values of $\omega_{min}$ and $\omega_{max}$ & $0.00001$ and $0.9$ \\
\hline
\end{tabular}
\end{table}

\begin{table}
\centering
\caption{Description of the {\fkinsol} optional output arrays \Id{IOUT} and \Id{ROUT}}
\label{t:fkinsol_out}
\medskip
\begin{tabular}{|r|c|l|}
\multicolumn{3}{c}{Integer output array \id{IOUT}} \\
\hline
{\bf Index} & {\bf Optional output} & {\kinsol} {\bf function} \\
\hline
\multicolumn{3}{|c|}{{\kinsol} main solver} \\
\hline
1  & \id{LENRW}  & \id{KINGetWorkSpace} \\
2  & \id{LENIW}  & \id{KINGetWorkSpace} \\
3  & \id{NNI}    & \id{KINGetNumNonlinSolvIters} \\
4  & \id{NFE}    & \id{KINGetNumFuncEvals} \\
5  & \id{NBCF}   & \id{KINGetNumBetaCondFails} \\
6  & \id{NBKTRK} & \id{KINGetNumBacktrackOps} \\
\hline
\multicolumn{3}{|c|}{{\kindls} linear solvers}\\
\hline
7  & \id{LENRWLS}  & \id{KINDlsGetWorkSpace} \\ 
8  & \id{LENIWLS}  & \id{KINDlsGetWorkSpace} \\ 
9  & \id{LS\_FLAG} & \id{KINDlsGetLastFlag} \\ 
10 & \id{NFELS}    & \id{KINDlsGetNumFuncEvals} \\ 
11 & \id{NJE}      & \id{KINDlsGetNumJacEvals} \\ 
\hline
\multicolumn{3}{|c|}{{\kinsls} linear solvers}\\
\hline
8  & \id{LS\_FLAG} & \id{KINSlsGetLastFlag} \\ 
10 & \id{NJE}      & \id{KINSlsGetNumJacEvals} \\ 
\hline
\multicolumn{3}{|c|}{{\kinspils} linear solvers}\\
\hline
7  & \id{LENRWLS}  & \id{KINSpilsGetWorkSpace} \\
8  & \id{LENIWLS}  & \id{KINSpilsGetWorkSpace} \\
9  & \id{LS\_FLAG} & \id{KINSpilsGetLastFlag} \\
10 & \id{NFELS}    & \id{KINSpilsGetNumFuncEvals} \\
11 & \id{NJTV}     & \id{KINSpilsGetNumJacEvals} \\
12 & \id{NPE}      & \id{KINSpilsGetNumPrecEvals} \\
13 & \id{NPS}      & \id{KINSpilsGetNumPrecSolves} \\
14 & \id{NLI}      & \id{KINSpilsGetNumLinIters} \\
15 & \id{NCFL}     & \id{KINSpilsGetNumConvFails} \\
\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real output array \id{ROUT}}\\
\hline
{\bf Index} & {\bf Optional output} & {\kinsol} {\bf function} \\ 
\hline
1  & \id{FNORM} & \id{KINGetFuncNorm} \\
2  & \id{SSTEP} & \id{KINGetStepLength} \\
\hline
\end{tabular}
\end{table}                                                                  


%%==============================================================================
\section{Usage of the FKINBBD interface to KINBBDPRE}
%%==============================================================================
\index{FKINBBD@{\fkinbbd} interface module!interface to the {\kinbbdpre} module|(}

The {\fkinbbd} interface sub-module is a package of {\CC} functions which,
as part of the {\fkinsol} interface module, support the use of the
{\kinsol} solver with the parallel {\nvecp} module and the {\kinbbdpre} 
preconditioner module (see \S\ref{sss:kinbbdpre}), for the solution of 
nonlinear problems in a mixed {\F}/{\CC} setting.  

The user-callable functions in this package, with the corresponding
{\kinsol} and {\kinbbdpre} functions, are as follows: 
\begin{itemize}
\item \id{FKINBBDINIT}
  interfaces to \id{KINBBDPrecInit}.
\item \id{FKINBBDOPT}
  interfaces to {\kinbbdpre} optional output functions.
\end{itemize}

In addition to the {\F} right-hand side function \id{FKFUN}, the
user-supplied functions used by this package, are listed below,
each with the corresponding interface function which calls it (and its
type within {\kinbbdpre} or {\kinsol}):
\begin{center}
\begin{tabular}{l||l|l}
{\fkinbbd} routine     &  {\kinsol} function & {\kinsol} type of \\
({\F}, user-supplied)  &  ({\CC}, interface) & interface function \\ \hline\hline
\id{FKLOCFN}  & \id{FKINgloc}     & \id{KINLocalFn} \\
\id{FKCOMMF}  & \id{FKINgcomm}    & \id{KINCommFn} \\
\id{FKJTIMES} & \id{FKINJtimes}   & \id{KINSpilsJacTimesVecFn} \\
\end{tabular}
\end{center}
As with the rest of the {\fkinsol} routines, the names of all user-supplied routines
here are fixed, in order to maximize portability for the resulting mixed-language
program. Additionally, based on flags discussed above in \S\ref{sss:fkinroutines},
the names of the user-supplied routines are mapped to actual values through a
series of definitions in the header file \id{fkinbbd.h}.

The following is a summary of the usage of this module. Steps that are unchanged
from the main program described in \S\ref{ss:fkinsol_usage} are grayed-out.

\index{User main program!FKINBBD@{\fkinbbd} usage}
\begin{Steps}
  
\item \textcolor{gray}{\bf Nonlinear system function specification}

\item \textcolor{gray}{\bf {\nvector} module initialization}

\item \textcolor{gray}{\bf Problem specification}

\item \textcolor{gray}{\bf Set optional inputs}

\item \textcolor{gray}{\bf {\kinsol} Initialization}

\item {\bf Linear solver specification}

  First, specify one of the {\kinspils} iterative linear solvers, by calling
  one of \id{FKINSPGMR}, \id{FKINSPFGRM}, \id{FKINSPBCG}, or \id{FKINSPTFQMR}.

  To initialize the {\kinbbdpre} preconditioner, make the following call:
  \index{FKINBBDINIT@\texttt{FKINBBDINIT}}
\begin{verbatim}
      CALL FKINBBDINIT (NLOCAL, MUDQ, MLDQ, MU, ML, IER)
\end{verbatim}
  The arguments are as follows.
  \id{NLOCAL} is the local size of vectors for this process.
  \id{MUDQ} and \id{MLDQ} are the upper and lower half-bandwidths to be used
  in the computation of the local Jacobian blocks by difference quotients;
  these may be smaller than the true half-bandwidths of the Jacobian of the
  local block of $G$, when smaller values may provide greater efficiency.
  \id{MU} and \id{ML} are the upper and lower half-bandwidths of the band
  matrix that is retained as an approximation of the local Jacobian block;
  these may be smaller than \id{MUDQ} and \id{MLDQ}.
  \id{IER} is a return completion flag.  A value of $0$ indicates success, while
  a value of $-1$ indicates that a memory failure occurred or that an input had
  an illegal value.

  Optionally, to specify that {\spgmr}, {\spfgmr}, {\spbcg}, or {\sptfqmr} should use
  the supplied \id{FKJTIMES}, make the call
  \index{FKINSPILSSETJAC@\texttt{FKINSPILSSETJAC}}
\begin{verbatim}
      CALL FKINSPILSSETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$.
  (See step \ref{i:fkinsol_lin_solv_spec} in \S\ref{ss:fkinsol_usage}).

\item \textcolor{gray}{\bf Problem solution}

\item {\bf {\kinbbdpre} Optional outputs}

  Optional outputs specific to the {\spgmr}, {\spfgmr}, {\spbcg}, or {\sptfqmr} solver are
  listed in Table \ref{t:fkinsol_out}.
  To obtain the optional outputs associated with the {\kinbbdpre} module, make
  the following call:
  \index{FKINBBDOPT@\texttt{FKINBBDOPT}}
\begin{verbatim}
      CALL FKINBBDOPT (LENRBBD, LENIBBD, NGEBBD)
\end{verbatim}
  The arguments should be consistent with {\CC} type \id{long int}.  Their
  returned values are as follows:
  \id{LENRBBD} is the length of real preconditioner work space, in \id{realtype}
  words. \id{LENIBBD} is the length of integer preconditioner work space, in
  integer words. These sizes are local to the current process.
  \id{NGEBBD} is the cumulative number of $G(u)$ evaluations (calls to \id{FKLOCFN})
  so far.
  
\item \textcolor{gray}{\bf Memory deallocation}

  (The memory allocated for the {\fkinbbd} module is deallocated automatically
  by \id{FKINFREE}.)
\index{FKINSOL@{\fkinsol} interface module!interface to the {\kinbbdpre} module|)}

\item {\bf User-supplied routines}

  The following two routines must be supplied for use with the {\kinbbdpre}
  module:
  \index{FKLOCFN@\texttt{FKLOCFN}}
\begin{verbatim}
      SUBROUTINE FKLOCFN (NLOC, ULOC, GLOC, IER)
      DIMENSION ULOC(*), GLOC(*)
\end{verbatim}
  This routine is to evaluate the function $G(u)$ approximating $F$
  (possibly identical to $F$), in terms of the array
  \id{ULOC} (of length \id{NLOC}), which is the sub-vector
  of $u$ local to this processor.  The resulting (local) sub-vector
  is to be stored in the array \id{GLOC}.
  \id{IER} is an error return flag which should be set to $0$ if successful,
  a positive value if a recoverable error occurred (in which case {\kinsol} will
  attempt to correct), or a negative value if \id{FKLOCFN} failed unrecoverably
  (in which case the solution process is halted).

  \index{FKCOMMFN@\texttt{FKCOMMFN}}
\begin{verbatim}
      SUBROUTINE FKCOMMFN (NLOC, ULOC, IER)
      DIMENSION ULOC(*)
\end{verbatim}
  This routine is to perform the inter-processor communication necessary
  for the \id{FKLOCFN} routine.
  Each call to \id{FKCOMMFN} is preceded by a call to the system function
  routine \id{FKFUN} with the same argument \id{ULOC}.
  \id{IER} is an error return flag which should be set to $0$ if successful,
  a positive value if a recoverable error occurred (in which case {\kinsol} will
  attempt to correct), or a negative value if \id{FKCOMMFN} failed recoverably
  (in which case the solution process is halted).

  {\warn}The subroutine \id{FKCOMMFN} must be supplied even if it is not needed
  and must return \id{IER = 0}.

  \index{FKINJTIMES@\texttt{FKINJTIMES}}
  Optionally, the user can supply a routine \id{FKINJTIMES} for the evaluation of
  Jacobian-vector products, as described above in step \ref{i:fkinsol_lin_solv_spec}
  in \S\ref{ss:fkinsol_usage}.  Note that this routine is required if using
  Picard iteration.

\end{Steps}
