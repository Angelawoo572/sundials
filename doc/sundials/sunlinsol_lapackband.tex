%% This is a shared SUNDIALS TEX file with a description of the
%% lapackband sunlinsol implementation
%%

The LAPACK band implementation of the {\sunlinsol} module provided
with {\sundials}, {\sunlinsollapband}, is designed to be used with the
corresponding {\sunmatband} matrix type, and one of the serial or
shared-memory {\nvector} implementations ({\nvecs}, {\nvecopenmp}, or
{\nvecpthreads}).  The {\sunlinsollapband} module defines the {\em
content} field of a\\
\noindent\id{SUNLinearSolver} to be the following structure:
%%
\begin{verbatim} 
struct _SUNLinearSolverContent_Band {
  sunindextype N;
  sunindextype *pivots;
  long int last_flag;
};
\end{verbatim}
%%
These entries of the \emph{content} field contain the following
information:
\begin{description}
  \item[N] - size of the linear system,
  \item[pivots] - index array for partial pivoting in LU factorization,
  \item[last\_flag] - last error return flag from internal function evaluations.
\end{description}

{\warn} The {\sunlinsollapband} module is a {\sunlinsol} wrapper for
the LAPACK band matrix factorization and solve routines, \id{*GBTRF}
and \id{*GBTRS}, where \id{*} is either \id{D} or \id{S}, depending on
whether {\sundials} was configured to have \id{realtype} set to
\id{double} or \id{single}, respectively (see Section \ref{s:types}).
In order to use the {\sunlinsollapband} module it is assumed
that LAPACK has been installed on the system prior to installation of
{\sundials}, and that {\sundials} has been configured appropriately to
link with LAPACK (see Appendix \ref{c:install} for details).  We note
that since there do not exist 128-bit floating-point factorization and
solve routines in LAPACK, this interface cannot be compiled when
using \id{extended} precision for \id{realtype}.  Similarly, since
there do not exist 64-bit integer LAPACK routines, the
{\sunlinsollapband} module also cannot be compiled when using 
\id{int64\_t} for the \id{sunindextype}.

This solver is constructed to perform the following operations:
\begin{itemize}
\item The ``setup'' call performs a $LU$ factorization with
  partial (row) pivoting, $PA=LU$, where $P$ is a permutation matrix,
  $L$ is a lower triangular matrix with 1's on the diagonal, and $U$
  is an upper triangular matrix.  This factorization is stored
  in-place on the input {\sunmatband} object $A$, with pivoting
  information encoding $P$ stored in the \id{pivots} array.
\item The ``solve'' call performs pivoting and forward and
  backward substitution using the stored \id{pivots} array and the
  $LU$ factors held in the {\sunmatband} object.
\item
  {\warn} $A$ must be allocated to accommodate the increase in upper
  bandwidth that occurs during factorization.  More precisely, if $A$
  is a band matrix with upper bandwidth \id{mu} and lower bandwidth
  \id{ml}, then the upper triangular factor $U$ can have upper
  bandwidth as big as \id{smu = MIN(N-1,mu+ml)}. The lower triangular
  factor $L$ has lower bandwidth \id{ml}.
\end{itemize}


\noindent The header file to be included when using this module 
is \id{sunlinsol/sunlinsol\_lapackband.h}. \\
%%
%%----------------------------------------------
%%
The {\sunlinsollapband} module defines band implementations of all
``direct'' linear solver operations listed in
Table \ref{t:sunlinsolops}:
\begin{itemize}
\item \id{SUNLinSolGetType\_LapackBand}
\item \id{SUNLinSolInitialize\_LapackBand} -- this does nothing, since all
  consistency checks are performed at solver creation.
\item \id{SUNLinSolSetup\_LapackBand} -- this calls either
  \id{DGBTRF} or \id{SGBTRF} to perform the $LU$ factorization.
\item \id{SUNLinSolSolve\_LapackBand} -- this calls either
  \id{DGBTRS} or \id{SGBTRS} to use the $LU$ factors and \id{pivots}
  array to perform the solve.
\item \id{SUNLinSolLastFlag\_LapackBand}
\item \id{SUNLinSolSpace\_LapackBand} -- this only returns information for
  the storage \emph{within} the solver object, i.e.~storage
  for \id{N}, \id{last\_flag}, and \id{pivots}.
\item \id{SUNLinSolFree\_LapackBand}
\end{itemize}
The module {\sunlinsollapband} provides the following additional
user-callable routine: 
%%
\begin{itemize}

%%--------------------------------------

\item \ID{SUNLapackBand}

  This function creates and allocates memory for a LAPACK band
  \id{SUNLinearSolver}.  Its arguments are an {\nvector} and
  {\sunmatrix}, that it uses to determine the linear system size and
  to assess compatibility with the linear solver implementation.

  This routine will perform consistency checks to ensure that it is
  called with consistent {\nvector} and {\sunmatrix} implementations.
  These are currently limited to the {\sunmatband} matrix type and
  the {\nvecs}, {\nvecopenmp}, and {\nvecpthreads} vector types.  As
  additional compatible matrix and vector implementations are added to
  {\sundials}, these will be included within this compatibility check.

  Additionally, this routine will verify that the input matrix \id{A}
  is allocated with appropriate upper bandwidth storage for the $LU$
  factorization.

  If either \id{A} or \id{y} are incompatible then this routine will
  return \id{NULL}.

  \verb|SUNLinearSolver SUNLapackBand(N_Vector y, SUNMatrix A);|

\end{itemize}
%%
%%------------------------------------
%%
For solvers that include a Fortran interface module, the
{\sunlinsollapband} module also includes the Fortran-callable
function \id{FSUNLapackBandInit(code, ier)} to initialize
this\\
\noindent {\sunlinsollapband} module for a given {\sundials} solver.
Here \id{code} is an integer input solver id (1 for {\cvode}, 2 for {\ida}, 3
for {\kinsol}, 4 for {\arkode}); \id{ier} is an error return flag 
equal to 0 for success and -1 for failure. Both \id{code} and \id{ier}
are declared to match C type \id{int}.
This routine must be called \emph{after} both the
{\nvector} and {\sunmatrix} objects have been initialized.
Additionally, when using {\arkode} with a non-identity mass matrix, the
Fortran-callable function \id{FSUNMassLapackBandInit(ier)}  
initializes this {\sunlinsollapband} module for solving mass matrix
linear systems.
