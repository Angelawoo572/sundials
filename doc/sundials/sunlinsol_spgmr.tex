%% This is a shared SUNDIALS TEX file with a description of the
%% spgmr sunlinsol implementation
%%

The {\spgmr} (Scaled, Preconditioned, Generalized Minimum
Residual \cite{SaSc:86}) implementation of the {\sunlinsol} module
provided with {\sundials}, {\sunlinsolspgmr}, is an iterative linear
solver that is designed to be compatible with any {\nvector}
implementation (serial, threaded, parallel, and user-supplied) that
supports a minimal subset of operations (\id{N\_VClone}, 
\id{N\_VDotProd}, \id{N\_VScale}, \id{N\_VLinearSum}, \id{N\_VProd},
\id{N\_VConst}, \id{N\_VDiv}, and \id{N\_VDestroy}).  

The {\sunlinsolspgmr} module defines the {\em content} field of a
\id{SUNLinearSolver} to be the following structure:
%%
\begin{verbatim} 
struct _SUNLinearSolverContent_SPGMR {
  int maxl;
  int pretype;
  int gstype;
  int max_restarts;
  int numiters;
  realtype resnorm;
  long int last_flag;
  ATimesFn ATimes;
  void* ATData;
  PSetupFn Psetup;
  PSolveFn Psolve;
  void* PData;
  N_Vector s1;
  N_Vector s2;
  N_Vector *V;
  realtype **Hes;
  realtype *givens;
  N_Vector xcor;
  realtype *yg;
  N_Vector vtemp;
};
\end{verbatim}
%%
These entries of the \emph{content} field contain the following
information:
\begin{description}
  \item[maxl] - number of GMRES basis vectors to use (default is 5),
  \item[pretype] - flag for type of preconditioning to employ
    (default is none),
  \item[gstype] - flag for type of Gram-Schmidt orthogonalization
    (default is modified Gram-Schmidt),
  \item[max\_restarts] - number of GMRES restarts to allow
    (default is 0),
  \item[numiters] - number of iterations from the most-recent solve,
  \item[resnorm] - final linear residual norm from the most-recent solve,
  \item[last\_flag] - last error return flag from an internal function,
  \item[ATimes] - function pointer to perform $Av$ product,
  \item[ATData] - pointer to structure for \id{ATimes},
  \item[Psetup] - function pointer to preconditioner setup routine,
  \item[Psolve] - function pointer to preconditioner solve routine,
  \item[PData] - pointer to structure for \id{Psetup} and \id{Psolve},
  \item[s1, s2] - vector pointers for supplied scaling matrices
    (default is \id{NULL}),
  \item[V] - the array of Krylov basis vectors
    $v_1, \ldots, v_{\text{\id{maxl}}+1}$, stored in \id{V[0]},
    \ldots, \id{V[maxl]}. Each $v_i$ is a vector of type {\nvector}.,
  \item[Hes] - the $(\text{\id{maxl}}+1)\times\text{\id{maxl}}$
    Hessenberg matrix. It is stored row-wise so that the (i,j)th
    element is given by \id{Hes[i][j]}.,
  \item[givens] - a length \id{2*maxl} array which represents the
    Givens rotation matrices that arise in the GMRES algorithm. These
    matrices are $F_0, F_1, \ldots, F_j$, where
    $F_i = \begin{bmatrix}
      1 &        &   &     &      &   &        &   \\
        & \ddots &   &     &      &   &        &   \\
        &        & 1 &     &      &   &        &   \\
        &        &   & c_i & -s_i &   &        &   \\
        &        &   & s_i &  c_i &   &        &   \\
        &        &   &     &      & 1 &        &   \\
        &        &   &     &      &   & \ddots &   \\
        &        &   &     &      &   &        & 1\end{bmatrix}$,
    are represented in the \id{givens} vector as \id{givens[0] =}
    $c_0$, \id{givens[1] = } $s_0$, \id{givens[2] = } $c_1$,
    \id{givens[3] = } $s_1$, \ldots \id{givens[2j] = } $c_j$,
    \id{givens[2j+1] = } $s_j$.,
  \item[xcor] - a vector which holds the scaled, preconditioned
    correction to the initial guess,
  \item[yg] - a length \id{(maxl+1)} array of \id{realtype} values
    used to hold ``short'' vectors (e.g. $y$ and $g$),
  \item[vtemp] - temporary vector storage.
\end{description}

This solver is constructed to perform the following operations:
\begin{itemize}
\item During construction, the \id{xcor} and \id{vtemp} arrays are
  cloned from a template {\nvector} that is input, and default solver
  parameters are set.
\item User-facing ``set'' routines may be called to modify default
  solver parameters.
\item Additional ``set'' routines are called by the {\sundials} solver
  that interfaces with {\sunlinsolspgmr} to supply the 
  \id{ATimes}, \id{PSetup}, and \id{Psolve} function pointers and
  \id{s1} and \id{s2} scaling vectors.
\item In the ``initialize'' call, the remaining solver data is
  allocated (\id{V}, \id{Hes}, \id{givens}, and \id{yg} )
\item In the ``setup'' call, any non-\id{NULL} 
  \id{PSetup} function is called.  Typically, this is provided by
  the {\sundials} solver itself, that translates between the
  generic \id{PSetup} function and the
  solver-specific routine (solver-supplied or user-supplied).
\item In the ``solve'' call, the GMRES iteration is performed.  This
  will include scaling, preconditioning, and restarts if those options
  have been supplied.
\end{itemize}

\noindent The header file to include when using this module 
is \id{sunlinsol/sunlinsol\_spgmr.h}. The {\sunlinsolspgmr} module
is accessible from all {\sundials} solvers \textit{without}
linking to the \\
\id{libsundials\_sunlinsolspgmr} module library. \\

%%
%%----------------------------------------------
%%

\noindent The {\sunlinsolspgmr} module defines implementations of all
``iterative'' linear solver operations listed in Table
\ref{t:sunlinsolops}:
\begin{itemize}
\item \id{SUNLinSolGetType\_SPGMR}
\item \id{SUNLinSolInitialize\_SPGMR}
\item \id{SUNLinSolSetATimes\_SPGMR}
\item \id{SUNLinSolSetPreconditioner\_SPGMR}
\item \id{SUNLinSolSetScalingVectors\_SPGMR}
\item \id{SUNLinSolSetup\_SPGMR}
\item \id{SUNLinSolSolve\_SPGMR}
\item \id{SUNLinSolNumIters\_SPGMR}
\item \id{SUNLinSolResNorm\_SPGMR}
\item \id{SUNLinSolResid\_SPGMR}
\item \id{SUNLinSolLastFlag\_SPGMR}
\item \id{SUNLinSolSpace\_SPGMR}
\item \id{SUNLinSolFree\_SPGMR}
\end{itemize}
The module {\sunlinsolspgmr} provides the following additional
user-callable routines: 
%%
\begin{itemize}

%%--------------------------------------

\item \ID{SUNSPGMR}

  This constructor function creates and allocates memory for a {\spgmr}
  \id{SUNLinearSolver}.  Its arguments are an {\nvector}, the desired
  type of preconditioning, and the number of Krylov basis vectors to use.

  This routine will perform consistency checks to ensure that it is
  called with a consistent {\nvector} implementation (i.e.~that it
  supplies the requisite vector operations).  If \id{y} is
  incompatible, then this routine will return \id{NULL}.

  A \id{maxl} argument that is $\le0$ will result in the default
  value (5).

  Allowable inputs for \id{pretype} are \id{PREC\_NONE} (0),
  \id{PREC\_LEFT} (1), \id{PREC\_RIGHT} (2) and \id{PREC\_BOTH} (3);
  any other integer input will result in the default (no
  preconditioning).
  We note that some {\sundials} solvers are designed to only work
  with left preconditioning ({\ida} and {\idas}) and others with only
  right preconditioning ({\kinsol}). While it is possible to configure
  a {\sunlinsolspgmr} object to use any of the preconditioning options
  with these solvers, this use mode is not supported and may result in
  inferior performance.

  \verb|SUNLinearSolver SUNSPGMR(N_Vector y, int pretype, int maxl);|

%%--------------------------------------

\item \ID{SUNSPGMRSetPrecType}

  This function updates the type of preconditioning to use.  Supported
  values are \id{PREC\_NONE} (0), \id{PREC\_LEFT} (1),
  \id{PREC\_RIGHT} (2) and \id{PREC\_BOTH} (3).  

  This routine will return with one of the error codes
  \id{SUNLS\_ILL\_INPUT} (illegal \id{pretype}), \id{SUNLS\_MEM\_NULL}
  (\id{S} is \id{NULL}) or \id{SUNLS\_SUCCESS}.
  
  \verb|int SUNSPGMRSetPrecType(SUNLinearSolver S, int pretype);|

%%--------------------------------------

\item \ID{SUNSPGMRSetGSType}

  This function sets the type of Gram-Schmidt orthogonalization to
  use.  Supported values are \id{MODIFIED\_GS} (1) and
  \id{CLASSICAL\_GS} (2).  Any other integer input will result in a
  failure, returning error code \id{SUNLS\_ILL\_INPUT}.

  This routine will return with one of the error codes
  \id{SUNLS\_ILL\_INPUT} (illegal \id{gstype}), \id{SUNLS\_MEM\_NULL}
  (\id{S} is \id{NULL}) or \id{SUNLS\_SUCCESS}.
  
  \verb|int SUNSPGMRSetGSType(SUNLinearSolver S, int gstype);|


%%--------------------------------------

\item \ID{SUNSPGMRSetMaxRestarts}

  This function sets the number of GMRES restarts to 
  allow.  A negative input will result in the default of 0.

  This routine will return with one of the error codes
  \id{SUNLS\_MEM\_NULL} (\id{S} is \id{NULL}) or \id{SUNLS\_SUCCESS}.
  
  \verb|int SUNSPGMRSetMaxRestarts(SUNLinearSolver S, int maxrs);|

\end{itemize}
%%
%%------------------------------------
%%
For solvers that include a Fortran interface module, the
{\sunlinsolspgmr} module also includes the Fortran-callable
function \id{FSUNSPGMRInit(code, pretype, maxl, ier)} to initialize
this {\sunlinsolspgmr} module for a given {\sundials} solver.
Here \id{code} is an integer input solver id (1 for {\cvode}, 2 for {\ida}, 3
for {\kinsol}, 4 for {\arkode}); \id{pretype} and \id{maxl} are the
same as for the C function \ID{SUNSPGMR}; \id{ier} is an error return
flag equal to 0 for success and -1 for failure.  All of these input
arguments should be declared so as to match C type \id{int}.  This
routine must be called \emph{after} the {\nvector} object has been
initialized.  Additionally, when using {\arkode} with a non-identity
mass matrix, the Fortran-callable
function \id{FSUNMassSPGMRInit(pretype, maxl, ier)} initializes this 
{\sunlinsolspgmr} module for solving mass matrix linear systems.

The \id{SUNSPGMRSetPrecType}, \id{SUNSPGMRSetGSType} and
\id{SUNSPGMRSetMaxRestarts} routines also support Fortran interfaces
for the system and mass matrix solvers (all arguments should be
commensurate with a C \id{int}):
\begin{itemize}
\item \id{FSUNSPGMRSetGSType(code, gstype, ier)}
\item \id{FSUNMassSPGMRSetGSType(gstype, ier)}
\item \id{FSUNSPGMRSetPrecType(code, pretype, ier)}
\item \id{FSUNMassSPGMRSetPrecType(pretype, ier)}
\item \id{FSUNSPGMRSetMaxRS(code, maxrs, ier)}
\item \id{FSUNMassSPGMRSetMaxRS(maxrs, ier)}
\end{itemize}
