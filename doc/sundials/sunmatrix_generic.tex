% This is a shared SUNDIALS TEX file with description of
% the generic sunmatrix abstraction
%
For problems that involve direct methods for solving linear systems,
the {\sundials} solvers not only operate on generic vectors, but also 
on generic matrices (of type \Id{SUNMatrix}), through a set of
operations defined by the particular {\sunmatrix} implementation.
Users can provide their own specific implementation of the
{\sunmatrix} module, particularly in cases where they provide their
own {\nvector} and/or linear solver modules, and require matrices that
are compatible with those implementations.  Alternately, we provide four
{\sunmatrix} implementations: dense, banded, diagonal, and sparse.  The
generic operations are described below, and descriptions of the
implementations provided with {\sundials} follow.

The generic \ID{SUNMatrix} type has been modeled after the
object-oriented style of the generic \id{N\_Vector} type.
Specifically, a generic \ID{SUNMatrix} is a pointer to a structure
that has an implementation-dependent {\em content} field containing
the description and actual data of the matrix, and an {\em ops} field 
pointing to a structure with generic matrix operations.
The type \id{SUNMatrix} is defined as
%%
%%
\begin{verbatim}
typedef struct _generic_SUNMatrix *SUNMatrix;

struct _generic_SUNMatrix {
    void *content;
    struct _generic_SUNMatrix_Ops *ops;
};
\end{verbatim}
%%
%%
The \id{\_generic\_SUNMatrix\_Ops} structure is essentially a list of pointers to
the various actual matrix operations, and is defined as
%%
\begin{verbatim}
struct _generic_SUNMatrix_Ops {
  SUNMatrix_ID (*getid)(SUNMatrix);
  SUNMatrix    (*clone)(SUNMatrix);
  void         (*destroy)(SUNMatrix);
  int          (*zero)(SUNMatrix);
  int          (*copy)(SUNMatrix, SUNMatrix);
  int          (*scaleadd)(realtype, SUNMatrix, SUNMatrix);
  int          (*scaleaddi)(realtype, SUNMatrix);
  int          (*matvec)(SUNMatrix, N_Vector, N_Vector);
  int          (*space)(SUNMatrix, long int*, long int*);
};
\end{verbatim}




The generic {\sunmatrix} module defines and implements the matrix operations 
acting on \id{SUNMatrix} objects.
These routines are nothing but wrappers for the matrix operations defined by
a particular {\sunmatrix} implementation, which are accessed through the {\em ops}
field of the \id{SUNMatrix} structure. To illustrate this point we
show below the implementation of a typical matrix operation from the
generic {\sunmatrix} module, namely \id{SUNMatZero}, which sets all
values of a matrix \id{A} to zero, returning a flag denoting a
successful/failed operation:
%%
%%
\begin{verbatim}
int SUNMatZero(SUNMatrix A)
{
  return((int) A->ops->zero(A));
}
\end{verbatim}
%%
%%
Table \ref{t:sunmatops} contains a complete list of all matrix operations defined
by the generic {\sunmatrix} module.
A particular implementation of the {\sunmatrix} module must:
\begin{itemize}
\item Specify the {\em content} field of the \id{SUNMatrix} object.
\item Define and implement a minimal subset of the matrix operations.
  See the documentation for each {\sundials} solver to determine which
  {\sunmatrix} operations they require.

  Note that the names of these routines should be unique to that
  implementation in order to permit using more than one {\sunmatrix}
  module (each with different \id{SUNMatrix} internal data
  representations) in the same code. 
\item Define and implement user-callable constructor and destructor
  routines to create and free a \id{SUNMatrix} with
  the new {\em content} field and with {\em ops} pointing to the
  new matrix operations.
\item Optionally, define and implement additional user-callable routines
  acting on the newly defined \id{SUNMatrix} (e.g., a routine to print
  the content for debugging purposes).
\item Optionally, provide accessor macros or functions as needed for
  that particular implementation to access different parts
  of the {\em content} field of the newly defined \id{SUNMatrix}. 
\end{itemize}

Each {\sunmatrix} implementation included in {\sundials} has a unique 
identifier specified in enumeration and shown in Table \ref{t:matrixIDs}.
It is recommended that a user-supplied {\sunmatrix} implementation use the 
\id{SUNMATRIX\_CUSTOM} identifier.

\begin{table}
\centering
\caption{Identifiers associated with matrix kernels supplied with {\sundials}.}
\label{t:matrixIDs}
\medskip
\begin{tabular}{|l|l|c|}
\hline
{\bf Matrix ID} & {\bf Matrix type} & {\bf ID Value} \\
\hline
SUNMATRIX\_DENSE      & Dense $\id{M} \times \id{N}$ matrix               & 0 \\ 
SUNMATRIX\_BAND       & Band $\id{M} \times \id{M}$ matrix                & 1 \\
SUNMATRIX\_DIAGONAL   & Diagonal $\id{M} \times \id{M}$ matrix            & 2 \\
SUNMATRIX\_SPARSE     & Sparse (CSR or CSC) $\id{M} \times \id{N}$ matrix & 3 \\ 
SUNMATRIX\_CUSTOM     & User-provided custom matrix                       & 4 \\
\hline
\end{tabular}
\end{table}

%---------------------------------------------------------------------------
% Table of matrix kernels
%---------------------------------------------------------------------------

\newlength{\ColOne}
\settowidth{\ColOne}{\id{SUNMatScaleAddI}}
\newlength{\ColTwo}
\setlength{\ColTwo}{\textwidth}
\addtolength{\ColTwo}{-0.5in}
\addtolength{\ColTwo}{-\ColOne}

\tablecaption{Description of the \id{SUNMatrix} operations}\label{t:sunmatops}
\tablehead{\hline {\rule{0mm}{5mm}}{\bf Name} & {\bf Usage and  Description} \\[3mm] \hline\hline}
\tabletail{\hline}
\begin{xtabular}{|p{\ColOne}|p{\ColTwo}|}
%%
\id{SUNMatGetID} & \id{id = SUNMatGetID(A);} \\ 
& Returns the type identifier for the matrix \id{A}. It is used to determine the
matrix implementation type (e.g.~dense, banded, sparse,\ldots) from the abstract 
\id{SUNMatrix} interface.  This is used to assess compatibility with
{\sundials}-provided linear solver implementations.  Returned values
are given in the Table \ref{t:matrixIDs}. 
\\[2mm]
%%
\id{SUNMatClone} & \id{B = SUNMatClone(A);} \\ 
& Creates a new \id{SUNMatrix} of the same type as an existing matrix \id{A} and sets the
{\em ops} field.
It does not copy the matrix, but rather allocates storage for the new matrix.
\\[2mm]
%%
\id{SUNMatDestroy} & \id{SUNMatDestroy(A);} \\
& Destroys the \id{SUNMatrix} \id{A} and frees memory allocated for its
internal data.
\\[2mm]
%%
\id{SUNMatSpace} & \id{ier = SUNMatSpace(A, \&lrw, \&liw);} \\
& Returns the storage requirements for the matrix \id{A}.  \id{lrw}
is a \id{long int} containing the number of realtype words
and \id{liw} is a \id{long int} containing the number of integer
words.  The return value is an integer flag denoting
success/failure of the operation.

This function is advisory only, for use in determining a user's total
space requirements; it could be a dummy function in a user-supplied
{\sunmatrix} module if that information is not of interest.
\\[2mm]
%%
\id{SUNMatZero} & \id{ier = SUNMatZero(A);} \\
& Performs the operation $A_{ij} = 0$ for all entries of the matrix
$A$.  The return value is an integer flag denoting success/failure of
the operation.
\\[2mm]
%%
\id{SUNMatScaleAdd} & \id{ier = SUNMatScaleAdd(c, A, B);} \\
& Performs the operation $A = cA + B$.  The return value is an integer
flag denoting success/failure of the operation.
\\[2mm]
%%
\id{SUNMatScaleAddI} & \id{ier = SUNMatScaleAddI(c, A);} \\
& Performs the operation $A = cA + I$.  The return value is an integer
flag denoting success/failure of the operation.
\\[2mm]
%%
\id{SUNMatMatvec} & \id{ier = SUNMatMatvec(A, x, y);} \\
& Performs the matrix-vector product operation, $y = Ax$. It should
only be called with vectors \id{x} and \id{y} that are compatible with
the matrix \id{A} -- both in storage type and dimensions.
\\[2mm]
%%
\end{xtabular}
\bigskip

%---------------------------------------------------------------------------
\section{The SUNMatrix\_Dense implementation}\label{ss:sunmat_dense}
\input{sunmatrix_dense}

%---------------------------------------------------------------------------
\section{The SUNMatrix\_Band implementation}\label{ss:sunmat_band}
\input{sunmatrix_band}

%---------------------------------------------------------------------------
\section{The SUNMatrix\_Diagonal implementation}\label{ss:sunmat_diag}
\input{sunmatrix_diag}

%---------------------------------------------------------------------------
\section{The SUNMatrix\_Sparse implementation}\label{ss:sunmat_sparse}
\input{sunmatrix_sparse}

%---------------------------------------------------------------------------

\section{SUNMatrix Examples}\label{ss:sunmat_examples}

There are \id{SUNMatrix} examples that may be installed for each
implementation: dense, banded, diagonal, and sparse.  Each implementation
makes use of the functions in \id{test\_sunmatrix.c}. 
These example functions show simple usage of the \id{SUNMatrix} family
of functions.  The inputs to the examples depend on the matrix type,
and are output to \texttt{stdout} if the example is run without the
appropriate number of command-line arguments. 

\noindent The following is a list of the example functions in \id{test\_sunmatrix.c}:
\begin{itemize}
\item \id{Test\_SUNMatGetID}: Verifies the returned matrix ID against
      the value that should be returned.
\item \id{Test\_SUNMatClone}: Creates clone of an existing matrix,
      copies the data, and checks that their values match.  
\item \id{Test\_SUNMatZero}: Zeros out an existing matrix and checks
      that each entry equals 0.0.
\item \id{Test\_SUNMatCopy}: Clones an input matrix, copies its data
      to a clone, and verifies that all values match.
\item \id{Test\_SUNMatScaleAdd}: Given an input matrix $A$ and an
      input identity matrix $I$, this test clones and copies $A$ to a new
      matrix $B$, computes $B = -B+B$, and verifies that the resulting
      matrix entries equal 0.0.  Additionally, if the matrix is
      square, this test clones and copies $A$ to a new matrix $D$, clones and
      copies $I$ to a new matrix $C$, computes $D = D+I$ and
      $C = C+A$ using \id{SUNMatScaleAdd}, and then verifies that
      $C==D$.
\item \id{Test\_SUNMatScaleAddI}: Given an input matrix $A$ and an
      input identity matrix $I$, this clones and copies $I$ to a new
      matrix $B$, computes $B = -B+I$ using \id{SUNMatScaleAddI}, and
      verifies that the resulting matrix entries equal 0.0.
\item \id{Test\_SUNMatMatvec} Given an input matrix $A$ and input
      vectors $x$ and $y$ such that $y=Ax$, this test has different
      behavior depending on whether $A$ is square.  If it is square,
      it clones and copies $A$ to a new matrix $B$, computes
      $B = 3B+I$ using \id{SUNMatScaleAddI}, clones $y$ to new vectors
      $w$ and $z$, computes $z = Bx$ using \id{SUNMatMatvec}, computes
      $w = 3y+x$ using \id{N\_VLinearSum}, and verifies that $w==z$.
      If $A$ is not square, it just clones $y$ to a new vector $z$,
      computes $z=Ax$ using \id{SUNMatMatvec}, and verifies that
      $y==z$.
\item \id{Test\_SUNMatSpace} verifies that \id{SUNMatSpace} can be
      called, and outputs the results to \texttt{stdout}.
\end{itemize}
