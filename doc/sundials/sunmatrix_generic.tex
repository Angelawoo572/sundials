% This is a shared SUNDIALS TEX file with description of
% the generic sunmatrix abstraction
%
For problems that involve direct methods for solving linear systems,
the {\sundials} solvers not only operate on generic vectors, but also 
on generic matrices (of type \Id{SUNMatrix}), through a set of
operations defined by the particular {\sunmatrix} implementation.
Users can provide their own specific implementation of the
{\sunmatrix} module, particularly in cases where they provide their
own {\nvector} and/or linear solver modules, and require matrices that
are compatible with those implementations.  Alternately, we provide three
{\sunmatrix} implementations: dense, banded, and sparse.  The
generic operations are described below, and descriptions of the
implementations provided with {\sundials} follow.

The generic \ID{SUNMatrix} type has been modeled after the
object-oriented style of the generic \id{N\_Vector} type.
Specifically, a generic \ID{SUNMatrix} is a pointer to a structure
that has an implementation-dependent {\em content} field containing
the description and actual data of the matrix, and an {\em ops} field 
pointing to a structure with generic matrix operations.
The type \id{SUNMatrix} is defined as
%%
%%
\begin{verbatim}
typedef struct _generic_SUNMatrix *SUNMatrix;

struct _generic_SUNMatrix {
    void *content;
    struct _generic_SUNMatrix_Ops *ops;
};
\end{verbatim}
%%
%%
The \id{\_generic\_SUNMatrix\_Ops} structure is essentially a list of pointers to
the various actual matrix operations, and is defined as
%%
\begin{verbatim}
struct _generic_SUNMatrix_Ops {
  SUNMatrix_ID (*getid)(SUNMatrix);
  SUNMatrix    (*clone)(SUNMatrix);
  void         (*destroy)(SUNMatrix);
  int          (*zero)(SUNMatrix);
  int          (*copy)(SUNMatrix, SUNMatrix);
  int          (*scaleadd)(realtype, SUNMatrix, SUNMatrix);
  int          (*scaleaddi)(realtype, SUNMatrix);
  int          (*matvec)(SUNMatrix, N_Vector, N_Vector);
  int          (*space)(SUNMatrix, long int*, long int*);
};
\end{verbatim}




The generic {\sunmatrix} module defines and implements the matrix operations 
acting on \id{SUNMatrix} objects.
These routines are nothing but wrappers for the matrix operations defined by
a particular {\sunmatrix} implementation, which are accessed through the {\em ops}
field of the \id{SUNMatrix} structure. To illustrate this point we
show below the implementation of a typical matrix operation from the
generic {\sunmatrix} module, namely \id{SUNMatZero}, which sets all
values of a matrix \id{A} to zero, returning a flag denoting a
successful/failed operation:
%%
%%
\begin{verbatim}
int SUNMatZero(SUNMatrix A)
{
  return((int) A->ops->zero(A));
}
\end{verbatim}
%%
%%
Table \ref{t:sunmatops} contains a complete list of all matrix operations defined
by the generic {\sunmatrix} module.
A particular implementation of the {\sunmatrix} module must:
\begin{itemize}
\item Specify the {\em content} field of the \id{SUNMatrix} object.
\item Define and implement a minimal subset of the matrix operations.
  See the documentation for each {\sundials} solver to determine which
  {\sunmatrix} operations they require.

  Note that the names of these routines should be unique to that
  implementation in order to permit using more than one {\sunmatrix}
  module (each with different \id{SUNMatrix} internal data
  representations) in the same code. 
\item Define and implement user-callable constructor and destructor
  routines to create and free a \id{SUNMatrix} with
  the new {\em content} field and with {\em ops} pointing to the
  new matrix operations.
\item Optionally, define and implement additional user-callable routines
  acting on the newly defined \id{SUNMatrix} (e.g., a routine to print
  the content for debugging purposes).
\item Optionally, provide accessor macros or functions as needed for
  that particular implementation to access different parts
  of the {\em content} field of the newly defined \id{SUNMatrix}. 
\end{itemize}

Each {\sunmatrix} implementation included in {\sundials} has a unique 
identifier specified in enumeration and shown in Table \ref{t:matrixIDs}.
It is recommended that a user-supplied {\sunmatrix} implementation use the 
\id{SUNMATRIX\_CUSTOM} identifier.

\begin{table}
\centering
\caption{Identifiers associated with matrix kernels supplied with {\sundials}.}
\label{t:matrixIDs}
\medskip
\begin{tabular}{|l|l|c|}
\hline
{\bf Matrix ID} & {\bf Matrix type} & {\bf ID Value} \\
\hline
SUNMATRIX\_DENSE      & Dense $\id{M} \times \id{N}$ matrix               & 0 \\ 
SUNMATRIX\_BAND       & Band $\id{M} \times \id{M}$ matrix                & 1 \\
SUNMATRIX\_SPARSE     & Sparse (CSR or CSC) $\id{M} \times \id{N}$ matrix & 2 \\ 
SUNMATRIX\_CUSTOM     & User-provided custom matrix                       & 3 \\
\hline
\end{tabular}
\end{table}

%---------------------------------------------------------------------------
% Table of matrix kernels
%---------------------------------------------------------------------------

\newlength{\ColOne}
\settowidth{\ColOne}{\id{SUNMatScaleAddI}}
\newlength{\ColTwo}
\setlength{\ColTwo}{\textwidth}
\addtolength{\ColTwo}{-0.5in}
\addtolength{\ColTwo}{-\ColOne}

\tablecaption{Description of the \id{SUNMatrix} operations}\label{t:sunmatops}
\tablehead{\hline {\rule{0mm}{5mm}}{\bf Name} & {\bf Usage and  Description} \\[3mm] \hline\hline}
\tabletail{\hline \multicolumn{2}{|r|}{\small\slshape continued on next page} \\ \hline}
\begin{xtabular}{|p{\ColOne}|p{\ColTwo}|}
%%
\id{SUNMatGetID} & \id{id = SUNMatGetID(A);} \\ 
& Returns the type identifier for the matrix \id{A}. It is used to determine the
matrix implementation type (e.g.~dense, banded, sparse,\ldots) from the abstract 
\id{SUNMatrix} interface.  This is used to assess compatibility with
{\sundials}-provided linear solver implementations.  Returned values
are given in the Table \ref{t:matrixIDs}. 
\\[2mm]
%%
\id{SUNMatClone} & \id{B = SUNMatClone(A);} \\ 
& Creates a new \id{SUNMatrix} of the same type as an existing matrix \id{A} and sets the
{\em ops} field.
It does not copy the matrix, but rather allocates storage for the new matrix.
\\[2mm]
%%
\id{SUNMatDestroy} & \id{SUNMatDestroy(A);} \\
& Destroys the \id{SUNMatrix} \id{A} and frees memory allocated for its
internal data.
\\[2mm]
%%
\id{SUNMatSpace} & \id{ier = SUNMatSpace(A, \&lrw, \&liw);} \\
& Returns the storage requirements for the matrix \id{A}.  \id{lrw}
is a \id{long int} containing the number of realtype words
and \id{liw} is a \id{long int} containing the number of integer
words.  The return value is an integer flag denoting
success/failure of the operation.

This function is advisory only, for use in determining a user's total
space requirements; it could be a dummy function in a user-supplied
{\sunmatrix} module if that information is not of interest.
\\[2mm]
%%
\id{SUNMatZero} & \id{ier = SUNMatZero(A);} \\
& Performs the operation $A_{ij} = 0$ for all entries of the matrix
$A$.  The return value is an integer flag denoting success/failure of
the operation.
\\[2mm]
%%
\id{SUNMatCopy} & \id{ier = SUNMatCopy(A,B);} \\
& Performs the operation $B_{ij} = A_{i,j}$ for all entries of the matrices
$A$ and $B$.  The return value is an integer flag denoting success/failure of
the operation.
\\[2mm]
%%
\id{SUNMatScaleAdd} & \id{ier = SUNMatScaleAdd(c, A, B);} \\
& Performs the operation $A = cA + B$.  The return value is an integer
flag denoting success/failure of the operation.
\\[2mm]
%%
\id{SUNMatScaleAddI} & \id{ier = SUNMatScaleAddI(c, A);} \\
& Performs the operation $A = cA + I$.  The return value is an integer
flag denoting success/failure of the operation.
\\[2mm]
%%
\id{SUNMatMatvec} & \id{ier = SUNMatMatvec(A, x, y);} \\
& Performs the matrix-vector product operation, $y = Ax$. It should
only be called with vectors \id{x} and \id{y} that are compatible with
the matrix \id{A} -- both in storage type and dimensions.  The return
value is an integer flag denoting success/failure of the operation.
\\[2mm]
%%
\end{xtabular}
\bigskip

We note that not all {\sunmatrix} types are compatible with all
{\nvector} types provided with {\sundials}.  This is primarily due to
the need for compatibility within the \id{SUNMatMatvec} routine;
however, compatibility between {\sunmatrix} and {\nvector}
implementations is more crucial when considering their interaction
within {\sunlinsol} objects, as will be described in more detail in
Chapter \ref{s:sunlinsol}.  More specifically, in Table 
\ref{t:matrix-vector} we show the matrix interfaces available as
{\sunmatrix} modules, and the compatible vector implementations.

\tablecaption{{\sundials} matrix interfaces and vector 
             implementations that can be used for each.}\label{t:matrix-vector}
\tablehead{\hline \multicolumn{1}{|p{1.5cm}|}{{Matrix Interface}} &
                  \multicolumn{1}{p{0.7cm}|}{{Serial}} & 
                  \multicolumn{1}{p{1.1cm}|}{{Parallel (MPI)}} & 
                  \multicolumn{1}{p{1.3cm}|}{{OpenMP}} & 
                  \multicolumn{1}{p{1.3cm}|}{{pThreads}} & 
                  \multicolumn{1}{p{0.9cm}|}{{{\hypre} Vec.}} & 
                  \multicolumn{1}{p{0.9cm}|}{{{\petsc} Vec.}} & 
                  \multicolumn{1}{p{0.8cm}|}{{{\cuda}}} & 
                  \multicolumn{1}{p{0.8cm}|}{{{\raja}}} & 
                  \multicolumn{1}{p{1.1cm}|}{{User Suppl.}} \\ \hline }
\tabletail{\hline \multicolumn{10}{|r|}{\small\slshape continued on next page} \\ \hline}
{\renewcommand{\arraystretch}{1.2}
\begin{xtabular}{|l|c|c|c|c|c|c|c|c|c|}
    Dense         &  \cm     &           & \cm      &  \cm       &             &          &          &          & \cm      \\ 
    Band          &  \cm     &           & \cm      &  \cm       &             &          &          &          & \cm      \\
    Sparse        &  \cm     &           & \cm      &  \cm       &             &          &          &          & \cm      \\
    User supplied &  \cm     & \cm       & \cm      &  \cm       & \cm         &  \cm     & \cm      & \cm      & \cm      \\ 
    \hline
\end{xtabular}
}
\bigskip

