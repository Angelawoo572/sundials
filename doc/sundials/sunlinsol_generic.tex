% This is a shared SUNDIALS TEX file with description of
% the generic sunlinsol abstraction
%
For problems that involve the solution of linear systems of equations,
the {\sundials} solvers operate using generic linear solver modules
(of type \Id{SUNLinearSolver}), through a set of operations defined by
the particular {\sunlinsol} implementation.  These work in
coordination with the {\sundials} generic {\nvector} and {\sunmatrix}
modules to provide a set of compatible data structures and solvers for
the solution of linear systems using direct or iterative methods.
Moreover, users can provide their own specific {\sunlinsol}
implementation to each {\sundials} solver, particularly in cases where
they provide their own {\nvector} and/or {\sunmatrix} modules, and the
customized linear solver leverages these additional data structures
to create highly efficient and/or scalable solvers for their
particular problem.  Additionally, {\sundials} provides native
implementations {\sunlinsol} modules, as well as {\sunlinsol} modules
that interface between {\sundials} and external
linear solver libraries.

The various {\sundials} solvers have been designed to specifically
leverage the use of either \emph{direct linear solvers}
or \emph{scaled, preconditioned, iterative linear solvers}, through
their ``Dls'' and ``Spils'' interfaces, respectively.  Additionally,
{\sundials} solvers can make use of user-supplied custom linear
solvers, whether these are problem-specific or come from external
solver libraries.

For iterative (and possibly custom) linear solvers, the {\sundials}
solvers leverage scaling and preconditioning, as applicable, to
balance error between solution components and to accelerate
convergence of the linear solver.  To this end, instead of solving the 
linear system $Ax = b$ directly, we apply the underlying iterative
algorithm to the transformed system  
\begin{equation}
  \label{eq:transformed_linear_system}
  \tilde{A} \tilde{x} = \tilde{b}
\end{equation}
where
\begin{align}
  \notag
  \tilde{A} &= S_1 P_1^{-1} A P_2^{-1} S_2^{-1},\\
  \label{eq:transformed_linear_system_components}
  \tilde{b} &= S_1 P_1^{-1} b,\\
  \notag
  \tilde{x} &= S_2 P_2 x,
\end{align} 
and where
\begin{itemize}
\item $P_1$ is the left preconditioner,
\item $P_2$ is the right preconditioner,
\item $S_1$ is a diagonal matrix of scale factors for $P_1^{-1} b$,
\item $S_2$ is a diagonal matrix of scale factors for $P_2 x$.
\end{itemize}
The {\sundials} solvers request that iterative linear solvers stop
based on the 2-norm of the scaled preconditioned residual meeting a
prescribed tolerance
\[
  \left\| \tilde{b} - \tilde{A} \tilde{x} \right\|_2  <  \text{tol}.
\]
We note that not all of the iterative linear solvers implemented in
{\sundials} support the full range of the above options.  Similarly,
some of the {\sundials} integrators only utilize a subset of these
options.  Exceptions to the operators shown above are described in
the documentation for each {\sunlinsol} implementation, or for each
{\sundials} solver ``Spils'' interface.

The generic \ID{SUNLinearSolver} type has been modeled after the
object-oriented style of the generic \id{N\_Vector} type.
Specifically, a generic \ID{SUNLinearSolver} is a pointer to a structure
that has an implementation-dependent {\em content} field containing
the description and actual data of the linear solver, and an {\em ops}
field pointing to a structure with generic linear solver operations.
The type \id{SUNLinearSolver} is defined as
%%
%%
\begin{verbatim}
typedef struct _generic_SUNLinearSolver *SUNLinearSolver;

struct _generic_SUNLinearSolver {
  void *content;
  struct _generic_SUNLinearSolver_Ops *ops;
};
\end{verbatim}
%%
%%
The \id{\_generic\_SUNLinearSolver\_Ops} structure is essentially a
list of pointers to the various actual linear solver operations, and
is defined as 
%%
\begin{verbatim}
struct _generic_SUNLinearSolver_Ops {
  SUNLinearSolver_Type (*gettype)(SUNLinearSolver);
  int                  (*setatimes)(SUNLinearSolver, void*, ATimesFn);
  int                  (*setpreconditioner)(SUNLinearSolver, void*, 
                                            PSetupFn, PSolveFn);
  int                  (*setscalingvectors)(SUNLinearSolver,
                                            N_Vector, N_Vector);
  int                  (*initialize)(SUNLinearSolver);
  int                  (*setup)(SUNLinearSolver, SUNMatrix);
  int                  (*solve)(SUNLinearSolver, SUNMatrix, N_Vector, 
                                N_Vector, realtype);
  int                  (*numiters)(SUNLinearSolver);
  realtype             (*resnorm)(SUNLinearSolver);
  long int             (*lastflag)(SUNLinearSolver);
  int                  (*space)(SUNLinearSolver, long int*, long int*);
  N_Vector             (*resid)(SUNLinearSolver);
  int                  (*free)(SUNLinearSolver);
};
\end{verbatim}

The generic {\sunlinsol} module defines and implements the linear
solver operations acting on \id{SUNLinearSolver} objects.  These
routines are in fact only wrappers for the linear solver operations
defined by a particular {\sunlinsol} implementation, which are
accessed through the {\em ops} field of the \id{SUNLinearSolver}
structure. To illustrate this point we show below the implementation
of a typical linear solver operation from the generic {\sunlinsol}
module, namely \id{SUNLinSolInitialize}, which initializes a
{\sunlinsol} object for use after it has been created and configured,
and returns a flag denoting a successful/failed operation:
%%
%%
\begin{verbatim}
int SUNLinSolInitialize(SUNLinearSolver S)
{
  return ((int) S->ops->initialize(S));
}
\end{verbatim}
%%
%%
Table \ref{t:sunlinsolops} contains a complete list of all linear
solver operations defined by the generic {\sunlinsol} module.  In
order to support both direct and iterative linear solver types, the
generic {\sunlinsol} module defines linear solver routines (or 
arguments) that may be specific to individual use cases.  As such,
for each routine we specify its intended use.  If a custom
{\sunlinsol} module is provided, the function pointers for
non-required routines may be set to \id{NULL} to indicate that they
are not provided.

A particular implementation of the {\sunlinsol} module must:
\begin{itemize}
\item Specify the {\em content} field of the \id{SUNLinearSolver} object.
\item Define and implement a minimal subset of the linear solver
  operations. See the documentation for each {\sundials} linear solver
  interface to determine which {\sunlinsol} operations they require.

  Note that the names of these routines should be unique to that
  implementation in order to permit using more than one {\sunlinsol}
  module (each with different \id{SUNLinearSolver} internal data
  representations) in the same code. 
\item Define and implement user-callable constructor and destructor
  routines to create and free a \id{SUNLinearSolver} with
  the new {\em content} field and with {\em ops} pointing to the
  new linear solver operations.
\item Optionally, define and implement additional user-callable routines
  acting on the newly defined \id{SUNLinearSolver} (e.g., routines to
  set various configuration options for tuning the linear solver to a
  particular problem).
\item Optionally, provide functions as needed for that particular
  implementation to access different parts in the {\em
  content} field of the newly defined \id{SUNLinearSolver} object
  (e.g., routines to return various statistics from the solver).
\end{itemize}

Each {\sunlinsol} implementation included in {\sundials} has a ``type''
identifier specified in enumeration and shown in Table \ref{t:linsolIDs}.
It is recommended that a user-supplied {\sunlinsol} implementation set
this identifier based on the {\sundials} solver interface they intend
to use: ``Dls'' interfaces require \ID{SUNLINEARSOLVER\_DIRECT}
{\sunlinsol} objects, ``Spils'' interfaces require 
\ID{SUNLINEARSOLVER\_ITERATIVE} objects, and ``Cls'' interfaces 
require \ID{SUNLINEARSOLVER\_CUSTOM} objects. 

\begin{table}
\centering
\caption{Identifiers associated with linear solver kernels supplied with {\sundials}.}
\label{t:linsolIDs}
\medskip
\begin{tabular}{|l|l|c|}
\hline
{\bf Linear Solver ID} & {\bf Solver type} & {\bf ID Value} \\
\hline
SUNLINEARSOLVER\_DIRECT      & Direct solvers     & 0 \\ 
SUNLINEARSOLVER\_ITERATIVE   & Iterative solvers  & 1 \\
SUNLINEARSOLVER\_CUSTOM      & Custom solvers     & 2 \\
\hline
\end{tabular}
\end{table}




%---------------------------------------------------------------------------
% Table of matrix kernels
%---------------------------------------------------------------------------

\newlength{\colOne}
\settowidth{\colOne}{\id{SUNLinSolSetScalingVectors}}
\newlength{\colTwo}
\setlength{\colTwo}{\textwidth}
\addtolength{\colTwo}{-0.5in}
\addtolength{\colTwo}{-\colOne}

\tablecaption{Description of the \id{SUNLinearSolver} operations}\label{t:sunlinsolops}
\tablehead{\hline {\rule{0mm}{5mm}}{\bf Name} & {\bf Usage and  Description} \\[3mm] \hline\hline}
\tabletail{\hline \multicolumn{2}{|r|}{\small\slshape continued on next page} \\ \hline}
\begin{xtabular}{|p{\colOne}|p{\colTwo}|}
%%
\id{SUNLinSolGetType} & \id{type = SUNLinSolGetType(LS);} \\ 
& Returns the type identifier for the linear solver \id{LS}. It is
  used to determine the solver type (direct, iterative, or custom) from
  the abstract \id{SUNLinearSolver} interface.  This is used to assess
  compatibility with {\sundials}-provided linear solver interfaces.
  Returned values are given in the Table \ref{t:linsolIDs}. 
\\[2mm]
%%
\id{SUNLinSolInitialize} & \id{ier = SUNLinSolInitialize(LS);} \\ 
& Performs linear solver initialization (assumes that all
  solver-specific options have been set).  This should return zero for a
  successful call, and a negative value for a failure, ideally
  returning one of the generic error codes listed in Table 
  \ref{t:sunlinsolerr}. 
\\[2mm]
%%
\id{SUNLinSolSetup} & \id{ier = SUNLinSolSetup(LS, A);} \\
& Performs any linear solver setup needed, based on an updated system
  {\sunmatrix} \id{A}.  This may be called frequently (e.g.~with a full
  Newton method) or infrequently (for a modified Newton method), based
  on the type of integrator and/or nonlinear solver requesting the
  solves.  This should return zero for a successful call, a positive
  value for a recoverable failure and a negative value for an
  unrecoverable failure, ideally returning one of the generic error
  codes listed in Table \ref{t:sunlinsolerr}. 
\\[2mm]
%%
\id{SUNLinSolSolve} & \id{ier = SUNLinSolSolve(LS, A, x, b, tol);} \\
& Solves a linear system $Ax = b$.  This should return zero for a
  successful call, a positive value for a recoverable failure and a
  negative value for an unrecoverable failure, ideally returning one
  of the generic error codes listed in Table \ref{t:sunlinsolerr}.\\ 
& {\bf Direct solvers:} can ignore the \id{realtype}
  argument \id{tol}. \\
& {\bf Iterative solvers:} can ignore the {\sunmatrix} input \id{A}
  since a \id{NULL} argument will be passed (these should instead rely
  on the matrix-vector product function supplied through the
  routine \id{SUNLinSolSetATimes}).  These should attempt to solve to
  the specified \id{realtype} tolerance \id{tol} in a weighted 2-norm.
  If the solver does not support scaling then it should just use a
  2-norm. \\
& {\bf Custom solvers:} all arguments will be supplied, and if the
  solver is approximate then it should attempt to solve to
  the specified \id{realtype} tolerance \id{tol} in a weighted 2-norm.
  If the solver does not support scaling then it should just use a
  2-norm. \\
\\[2mm]
%%
\id{SUNLinSolFree} & \id{ier = SUNLinSolFree(LS);} \\
& Frees memory allocated by the linear solver.  This should return
  zero for a successful call, and a negative value for a failure.
\\[2mm]
%%
\id{SUNLinSolSetATimes} & \id{ier = SUNLinSolSetATimes(LS, A\_data, ATimes);} \\
& (Iterative/Custom linear solvers only)
  Provides \id{ATimesFn} function pointer, as well as a \id{void *} pointer 
  to a data structure used by this routine, to a linear solver object.
  {\sundials} solvers will call this function to set the matrix-vector
  product function to either a solver-provided difference-quotient via
  vector operations or a user-supplied solver-specific routine. This
  routine should return zero for a successful call, and a negative
  value for a failure, ideally returning one of the generic error
  codes listed in Table \ref{t:sunlinsolerr}. 
\\[2mm]
%%
\id{SUNLinSolSetPreconditioner} & \id{ier = SUNLinSolSetPreconditioner(LS, Pdata, Pset, Psol);} \\
& (Optional; Iterative/Custom linear solvers only)
  Provides \id{PSetupFn} and \id{PSolveFn} function pointers that
  implement the preconditioner solves $P_1^{-1}$ and $P_2^{-1}$ from
  equations \eqref{eq:transformed_linear_system}-\eqref{eq:transformed_linear_system_components}.
  This routine will be called by a {\sundials} 
  solver, which will provide translation between the generic \id{Pset}
  and \id{Psol} calls and the integrator-specific and integrator- or
  user-supplied routines.  This routine should return zero for a
  successful call, and a negative value for a failure, ideally
  returning one of the generic error codes listed in
  Table \ref{t:sunlinsolerr}. 
\\[2mm]
%%
\id{SUNLinSolSetScalingVectors} & \id{ier = SUNLinSolSetScalingVectors(LS, s1, s2);} \\
& (Optional; Iterative/Custom linear solvers only)
  Sets pointers to left/right scaling vectors for the linear system
  solve.  Here, \id{s1} is an {\nvector} of positive scale factors
  containing the diagonal of the matrix $S_1$ from
  equations \eqref{eq:transformed_linear_system}-\eqref{eq:transformed_linear_system_components}.
  Similarly, \id{s2} is an {\nvector} containing the diagonal of $S_2$
  from equations \eqref{eq:transformed_linear_system}-\eqref{eq:transformed_linear_system_components}.
  Neither of these vectors are tested for positivity, and a \id{NULL}
  argument for either indicates that the corresponding scaling matrix
  is the identity. This routine should return zero for a successful call,
  and a negative value for a failure, ideally returning one of the
  generic error codes listed in Table \ref{t:sunlinsolerr}. 
\\[2mm]
%%
\id{SUNLinSolNumIters} & \id{its = SUNLinSolNumIters(LS);} \\
& (Optional; Iterative/Custom linear solvers only)
  Should return the \id{int} number of linear iterations performed in
  the last `solve' call. 
\\[2mm]
%%
\id{SUNLinSolResNorm} & \id{rnorm = SUNLinSolResNorm(LS);} \\
& (Optional; Iterative/Custom linear solvers only)
  Should return the \id{realtype} final residual norm from the last
  `solve' call.
\\[2mm]
%%
\id{SUNLinSolResid} & \id{rvec = SUNLinSolResid(LS);} \\
& (Optional; Iterative/Custom linear solvers only)
  If an iterative method computes the preconditioned initial residual
  and returns with a successful solve without performing any
  iterations (i.e.~either the initial guess or the preconditioner is
  sufficiently accurate), then this function may be called by the
  {\sundials} solver.  This routine should return the {\nvector}
  containing the preconditioned initial residual vector.
\\[2mm]
%%
\id{SUNLinLastFlag} & \id{lflag = SUNLinLastFlag(LS);} \\
& (Optional) Should return the last error flag encountered within the
  linear solver. This is not called by the {\sundials} solvers 
  directly; it allows the user to investigate linear solver issues
  after a failed solve.
\\[2mm]
%%
\id{SUNLinSolSpace} & \id{ier = SUNLinSolSpace(LS, \&lrw, \&liw);} \\
& (Optional) Returns the storage requirements for the linear
  solver \id{LS}.  \id{lrw} is a \id{long int} containing the number
  of realtype words and \id{liw} is a \id{long int} containing the
  number of integer words.  The return value is an integer flag
  denoting success/failure of the operation. 

  This function is advisory only, for use in determining a user's
  total space requirements.
\\[2mm]
%%
\end{xtabular}
\bigskip



%---------------------------------------------------------------------------
% Tables listing compatibility with matrix/vector types
%---------------------------------------------------------------------------

We note that not all {\sunlinsol} types are compatible with all
{\sunmatrix} and {\nvector} types provided with {\sundials}.  In Table 
\ref{t:linsol-matrix} we show the direct linear solver interfaces
available as {\sunlinsol} modules, and the compatible matrix
implementations.  In Table \ref{t:linsol-vector} we show the
compatibility between all {\sunlinsol} modules and vector
implementations.

\tablecaption{{\sundials} direct linear solvers and matrix
              implementations that can be used for each.}\label{t:linsol-matrix} 
\tablehead{\hline \multicolumn{1}{|p{2cm}|}{{Linear Solver Interface}} &
                  \multicolumn{1}{p{1.3cm}|}{{Dense Matrix}} & 
                  \multicolumn{1}{p{1.3cm}|}{{Banded Matrix}} & 
                  \multicolumn{1}{p{1.4cm}|}{{Sparse Matrix}} & 
                  \multicolumn{1}{p{1.4cm}|}{{User Supplied}} \\ \hline}
\tabletail{\hline \multicolumn{5}{|r|}{\small\slshape continued on next page} \\ \hline}
{\renewcommand{\arraystretch}{1.2}
\begin{xtabular}{|l|c|c|c|c|}
%   Linear Solver &  Dense   & Banded & Sparse & User     \\
%   Interface     &          &        &        & Supplied \\ 
    Dense         &  \cm     &        &        & \cm      \\ 
    Band          &          & \cm    &        & \cm      \\
    Diagonal      &          &        &        & \cm      \\ 
    LapackDense   &  \cm     &        &        & \cm      \\ 
    LapackBand    &          & \cm    &        & \cm      \\
    \klu          &          &        &  \cm   & \cm      \\
    \superlumt    &          &        &  \cm   & \cm      \\
    User supplied &  \cm     & \cm    &  \cm   & \cm      \\ 
    \hline
\end{xtabular}}
\bigskip


\tablecaption{{\sundials} linear solver interfaces and vector
             implementations that can be used for each.}\label{t:linsol-vector}
\tablehead{\hline \multicolumn{1}{|p{2cm}|}{{Linear Solver Interface}} &
                  \multicolumn{1}{p{1.3cm}|}{{Serial}} & 
                  \multicolumn{1}{p{1.3cm}|}{{Parallel (MPI)}} & 
                  \multicolumn{1}{p{1.4cm}|}{{OpenMP}} & 
                  \multicolumn{1}{p{1.4cm}|}{{pThreads}} & 
                  \multicolumn{1}{p{1.3cm}|}{{{\hypre} Vector}} & 
                  \multicolumn{1}{p{1.3cm}|}{{{\petsc} Vector}} & 
                  \multicolumn{1}{p{1.4cm}|}{{User Supplied}} \\ \hline }
\tabletail{\hline \multicolumn{8}{|r|}{\small\slshape continued on next page} \\ \hline}
{\renewcommand{\arraystretch}{1.2}
\begin{xtabular}{|l|c|c|c|c|c|c|c|}
%   Linear Solver &  Serial  & Parallel  &  OpenMP  &  pThreads  & {\hypre}    & {\petsc} & User     \\
%   Interface     &          & (MPI)     &          &            &  Vector     & Vector   & Supplied \\ 
    Dense         &  \cm     &           & \cm      &  \cm       &             &          & \cm      \\ 
    Band          &  \cm     &           & \cm      &  \cm       &             &          & \cm      \\
    LapackDense   &  \cm     &           & \cm      &  \cm       &             &          & \cm      \\
    LapackBand    &  \cm     &           & \cm      &  \cm       &             &          & \cm      \\
    \klu          &  \cm     &           & \cm      &  \cm       &             &          & \cm      \\
    \superlumt    &  \cm     &           & \cm      &  \cm       &             &          & \cm      \\
    \spgmr        &  \cm     &  \cm      &  \cm     &  \cm       & \cm         &  \cm     & \cm      \\
    \spfgmr       &  \cm     &  \cm      &  \cm     &  \cm       & \cm         &  \cm     & \cm      \\
    \spbcg        &  \cm     &  \cm      &  \cm     &  \cm       & \cm         &  \cm     & \cm      \\
    \sptfqmr      &  \cm     &  \cm      &  \cm     &  \cm       & \cm         &  \cm     & \cm      \\ 
    \pcg          &  \cm     &  \cm      &  \cm     &  \cm       & \cm         &  \cm     & \cm      \\
    User supplied &  \cm     &  \cm      &  \cm     &  \cm       & \cm         &  \cm     & \cm      \\ 
    \hline
\end{xtabular}}
\bigskip


%---------------------------------------------------------------------------
% Table of linear solver error codes
%---------------------------------------------------------------------------

\newlength{\ColumnOne}
\settowidth{\ColumnOne}{\id{SUNLS\_PACKAGE\_FAIL\_UNREC}}
\newlength{\ColumnTwo}
\settowidth{\ColumnTwo}{\id{Value}}
\newlength{\ColumnThree}
\setlength{\ColumnThree}{\textwidth}
\addtolength{\ColumnThree}{-0.5in}
\addtolength{\ColumnThree}{-\ColumnOne}
\addtolength{\ColumnThree}{-\ColumnTwo}

\tablecaption{Description of the \id{SUNLinearSolver} error codes}\label{t:sunlinsolerr}
\tablehead{\hline {\rule{0mm}{5mm}}{\bf Name} & {\bf Value} & {\bf Description} \\[3mm] \hline\hline}
\tabletail{\hline \multicolumn{3}{|r|}{\small\slshape continued on next page} \\ \hline}
\begin{xtabular}{|p{\ColumnOne}|p{\ColumnTwo}|p{\ColumnThree}|}
%%
\id{SUNLS\_SUCCESS} & \id{0} & successful call or converged solve
\\[1mm]
%%
\id{SUNLS\_MEM\_NULL} & \id{-1} & the memory argument to the function is \id{NULL}
\\[2mm]
%%
\id{SUNLS\_ILL\_INPUT} & \id{-2} & an illegal input has been provided to the function 
\\[2mm]
%%
\id{SUNLS\_MEM\_FAIL} & \id{-3} & failed memory access or allocation
\\[2mm]
%%
\id{SUNLS\_ATIMES\_FAIL\_UNREC} & \id{-4} & an unrecoverable failure
  occurred in the \id{ATimes} routine
\\[2mm]
%%
\id{SUNLS\_PSET\_FAIL\_UNREC} & \id{-5} & an unrecoverable failure
  occurred in the \id{Pset} routine
\\[2mm]
%%
\id{SUNLS\_PSOLVE\_FAIL\_UNREC} & \id{-6} & an unrecoverable failure
  occurred in the \id{Psolve} routine
\\[2mm]
%%
\id{SUNLS\_PACKAGE\_FAIL\_UNREC} & \id{-7} & an unrecoverable failure
  occurred in an external linear solver package
\\[2mm]
%%
\id{SUNLS\_GS\_FAIL} & \id{-8} & a failure occurred during
  Gram-Schmidt orthogonalization ({\sunlinsolspgmr}/{\sunlinsolspfgmr})
\\[2mm]
%%
\id{SUNLS\_QRSOL\_FAIL} & \id{-9} & a singular $R$ matrix was
  encountered in a QR factorization ({\sunlinsolspgmr}/{\sunlinsolspfgmr})
\\[2mm]
%%
\id{SUNLS\_RES\_REDUCED} & \id{1} &  an iterative solver reduced the
  residual, but did not converge to the desired tolerance
\\[2mm]
%%
\id{SUNLS\_CONV\_FAIL} & \id{2} &  an iterative solver did not
converge (and the residual was not reduced)
\\[2mm]
%%
\id{SUNLS\_ATIMES\_FAIL\_REC} & \id{3} & a recoverable failure occurred
  in the \id{ATimes} routine
\\[2mm]
%%
\id{SUNLS\_PSET\_FAIL\_REC} & \id{4} & a recoverable failure occurred
  in the \id{Pset} routine
\\[2mm]
%%
\id{SUNLS\_PSOLVE\_FAIL\_REC} & \id{5} & a recoverable failure occurred
  in the \id{Psolve} routine
\\[2mm]
%%
\id{SUNLS\_PACKAGE\_FAIL\_REC} & \id{6} &  a recoverable failure
  occurred in an external linear solver package
\\[2mm]
%%
\id{SUNLS\_QRFACT\_FAIL} & \id{7} & a singular matrix was encountered
  during a QR factorization ({\sunlinsolspgmr}/{\sunlinsolspfgmr})
\\[2mm]
%%
\id{SUNLS\_LUFACT\_FAIL} & \id{8} & a singular matrix was encountered
  during a LU factorization ({\sunlinsoldense}/{\sunlinsolband})
\\[2mm]
%%
%%
\end{xtabular}
\bigskip



%---------------------------------------------------------------------------
\section{The SUNLinearSolver\_Dense implementation}\label{ss:sunlinsol_dense}
\input{sunlinsol_dense}

%---------------------------------------------------------------------------
\section{The SUNLinearSolver\_Band implementation}\label{ss:sunlinsol_band}
\input{sunlinsol_band}

%---------------------------------------------------------------------------
\section{The SUNLinearSolver\_LapackDense implementation}\label{ss:sunlinsol_lapdense}
\input{sunlinsol_lapackdense}

%---------------------------------------------------------------------------
\section{The SUNLinearSolver\_LapackBand implementation}\label{ss:sunlinsol_lapband}
\input{sunlinsol_lapackband}

%---------------------------------------------------------------------------
\section{The SUNLinearSolver\_KLU implementation}\label{ss:sunlinsol_klu}
\input{sunlinsol_klu}

%---------------------------------------------------------------------------
\section{The SUNLinearSolver\_SuperLUMT implementation}\label{ss:sunlinsol_superlumt}
\input{sunlinsol_superlumt}

%---------------------------------------------------------------------------
\section{The SUNLinearSolver\_SPGMR implementation}\label{ss:sunlinsol_spgmr}
\input{sunlinsol_spgmr}

%---------------------------------------------------------------------------
\section{The SUNLinearSolver\_SPFGMR implementation}\label{ss:sunlinsol_spfgmr}
\input{sunlinsol_spfgmr}

%---------------------------------------------------------------------------
\section{The SUNLinearSolver\_SPBCGS implementation}\label{ss:sunlinsol_spbcgs}
\input{sunlinsol_spbcgs}

%---------------------------------------------------------------------------
\section{The SUNLinearSolver\_SPTFQMR implementation}\label{ss:sunlinsol_sptfqmr}
\input{sunlinsol_sptfqmr}

%---------------------------------------------------------------------------
\section{The SUNLinearSolver\_PCG implementation}\label{ss:sunlinsol_pcg}
\input{sunlinsol_pcg}

%---------------------------------------------------------------------------

\section{SUNLinearSolver Examples}\label{ss:sunlinsol_examples}

There are \id{SUNLinearSolver} examples that may be installed for each
implementation; these make use of the functions in \id{test\_sunlinsol.c}. 
These example functions show simple usage of the \id{SUNLinearSolver} family
of functions.  The inputs to the examples depend on the linear solver type,
and are output to \texttt{stdout} if the example is run without the
appropriate number of command-line arguments. 

\noindent The following is a list of the example functions in \id{test\_sunlinsol.c}:
\begin{itemize}
\item \id{Test\_SUNLinSolGetType}: Verifies the returned solver type against
  the value that should be returned.
\item \id{Test\_SUNLinSolInitialize}: Verifies that \id{SUNLinSolInitialize} 
  can be called and returns successfully. 
\item \id{Test\_SUNLinSolSetup}: Verifies that \id{SUNLinSolSetup} can
  be called and returns successfully. 
\item \id{Test\_SUNLinSolSolve}: Given a {\sunmatrix} object $A$,
  {\nvector} objects $x$ and $b$ (where $Ax=b$) and a desired solution
  tolerance \texttt{tol}, this routine clones $x$ into a new vector $y$,
  calls \id{SUNLinSolSolve} to fill $y$ as the solution to $Ay=b$ (to
  the input tolerance), verifies that each entry in $x$ and $y$
  match to within \texttt{10*tol}, and overwrites $x$ with $y$ prior
  to returning (in case the calling routine would like to investigate
  further).
\item \id{Test\_SUNLinSolSetATimes} (iterative solvers only): Verifies that
  \id{SUNLinSolSetATimes} can be called and returns successfully.
\item \id{Test\_SUNLinSolSetPreconditioner} (iterative solvers only):
  Verifies that \id{SUNLinSolSetPreconditioner} can be called and
  returns successfully.
\item \id{Test\_SUNLinSolSetScalingVectors} (iterative solvers only):  
  Verifies that \id{SUNLinSolSetScalingVectors} can be called and
  returns successfully.
\item \id{Test\_SUNLinSolLastFlag}: Verifies that \id{SUNLinSolLastFlag} can
  be called, and outputs the result to \texttt{stdout}.
\item \id{Test\_SUNLinSolNumIters} (iterative solvers only): Verifies that
  \id{SUNLinSolNumIters} can be called, and outputs the result to 
  \texttt{stdout}. 
\item \id{Test\_SUNLinSolResNorm} (iterative solvers only): Verifies that
  \id{SUNLinSolResNorm} can be called, and that the result is
  non-negative. 
\item \id{Test\_SUNLinSolResid} (iterative solvers only): Verifies that
  \id{SUNLinSolResid} can be called.
\item \id{Test\_SUNLinSolSpace} verifies that \id{SUNLinSolSpace} can be
  called, and outputs the results to \texttt{stdout}.
\end{itemize}
We'll note that these tests should be performed in a particular
order.  For either direct or iterative linear
solvers, \id{Test\_SUNLinSolInitialize} must be called
before \id{Test\_SUNLinSolSetup}, which must be called
before \id{Test\_SUNLinSolSolve}.  Additionally, for iterative linear
solvers \id{Test\_SUNLinSolSetATimes}, \id{Test\_SUNLinSolSetPreconditioner}
and \id{Test\_SUNLinSolSetScalingVectors} should be called
before \id{Test\_SUNLinSolInitialize};
similarly \id{Test\_SUNLinSolNumIters}, \id{Test\_SUNLinSolResNorm}
and \id{Test\_SUNLinSolResid} should be called
after \id{Test\_SUNLinSolSolve}.  These are called in the appropriate
order in all of the example problems.

