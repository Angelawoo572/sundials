%% This is a shared SUNDIALS TEX file with a description of the
%% klu sunlinsol implementation
%%

The {\klu} implementation of the {\sunlinsol} module provided with
{\sundials}, {\sunlinsolklu}, is designed to be used with the
corresponding {\sunmatsparse} matrix type, and one of the serial or
shared-memory {\nvector} implementations ({\nvecs}, {\nvecopenmp}, or 
{\nvecpthreads}).  The {\sunlinsolklu} module defines the {\em
content} field of a \id{SUNLinearSolver} to be the following structure:
%%
\begin{verbatim} 
struct _SUNLinearSolverContent_KLU {
  long int         last_flag;
  int              first_factorize;
  sun_klu_symbolic *symbolic;
  sun_klu_numeric  *numeric;
  sun_klu_common   common;
  sunindextype     (*klu_solver)(sun_klu_symbolic*, sun_klu_numeric*,
                                 sunindextype, sunindextype,
                                 double*, sun_klu_common*);
};
\end{verbatim}
%%
These entries of the \emph{content} field contain the following
information:
\begin{description}
  \item[last\_flag] - last error return flag from internal function evaluations,
  \item[first\_factorize] - flag indicating whether the factorization
    has ever been performed, 
  \item[symbolic] - {\klu} storage structure for symbolic factorization components,
  \item[numeric] - {\klu} storage structure for numeric factorization components,
  \item[common] - storage structure for common {\klu} solver components,
  \item[klu\_solver] -- pointer to the appropriate {\klu} solver function
    (depending on whether it is using a CSR or CSC sparse matrix).
\end{description}

{\warn} The {\sunlinsolklu} module is a {\sunlinsol} wrapper for
the {\klu} sparse matrix factorization and solver library written by Tim
Davis \cite{KLU_site,DaPa:10}.  In order to use the
{\sunlinsolklu} interface to {\klu}, it is assumed that {\klu} has
been installed on the system prior to installation of {\sundials}, and
that {\sundials} has been configured appropriately to link with {\klu}
(see Appendix \ref{c:install} for details).  Additionally, this
wrapper only supports double-precision calculations, and therefore
cannot be compiled if {\sundials} is configured to have \id{realtype}
set to either \id{extended} or \id{single} (see Section \ref{s:types}).
Since the {\klu} library supports both 32-bit and 64-bit integers, this
interface will be compiled for either of the available \id{sunindextype} options.

The {\klu} library has a symbolic factorization routine that computes
the permutation of the linear system matrix to block triangular form
and the permutations that will pre-order the diagonal blocks (the only
ones that need to be factored) to reduce fill-in (using AMD, COLAMD,
CHOLAMD, natural, or an ordering given by the user).  Of these
ordering choices, the default value in the {\sunlinsolklu} 
module is the COLAMD ordering.

{\klu} breaks the factorization into two separate parts.  The first is
a symbolic factorization and the second is a numeric factorization
that returns the factored matrix along with final pivot information.   
{\klu} also has a refactor routine that can be called instead of the numeric 
factorization.  This routine will reuse the pivot information.  This routine 
also returns diagnostic information that a user can examine to determine if 
numerical stability is being lost and a full numerical factorization should 
be done instead of the refactor.

Since the linear systems that arise within the context of {\sundials}
calculations will typically have identical sparsity patterns, the
{\sunlinsolklu} module is constructed to perform the
following operations:
\begin{itemize}
\item The first time that the ``setup'' routine is called, it
  performs the symbolic factorization, followed by an initial
  numerical factorization.  
\item On subsequent calls to the ``setup'' routine, it calls the
  appropriate {\klu} ``refactor'' routine, followed by estimates of
  the numerical conditioning using the relevant ``rcond'', and if
  necessary ``condest'', routine(s).  If these estimates of the
  condition number are larger than $\varepsilon^{-2/3}$ (where
  $\varepsilon$ is the double-precision unit roundoff), then a new
  factorization is performed.
\item The module includes the routine \id{SUNKLUReInit}, that 
  can be called by the user to force a full or partial refactorization
  at the next ``setup'' call. 
\item The ``solve'' call performs pivoting and forward and
  backward substitution using the stored {\klu} data structures.  We
  note that in this solve {\klu} operates on the native data arrays
  for the right-hand side and solution vectors, without requiring
  costly data copies.
\end{itemize}


\noindent The header file to include when using this module 
is \id{sunlinsol/sunlinsol\_klu.h}. The installed module
library to link to is
\id{libsundials\_sunlinsolklu.\textit{lib}}
where \id{\em.lib} is typically \id{.so} for shared libraries and
\id{.a} for static libraries. \\

%%
%%----------------------------------------------
%%

\noindent The {\sunlinsolklu} module defines implementations of all
``direct'' linear solver operations listed in
Table \ref{t:sunlinsolops}:
\begin{itemize}
\item \id{SUNLinSolGetType\_KLU}
\item \id{SUNLinSolInitialize\_KLU} -- this sets the
  \id{first\_factorize} flag to 1, forcing both symbolic and numerical
  factorizations on the subsequent ``setup'' call.
\item \id{SUNLinSolSetup\_KLU} -- this performs either a $LU$
  factorization or refactorization of the input matrix.
\item \id{SUNLinSolSolve\_KLU} -- this calls the appropriate {\klu}
  solve routine to utilize the $LU$ factors to solve the linear
  system. 
\item \id{SUNLinSolLastFlag\_KLU}
\item \id{SUNLinSolSpace\_KLU} -- this only returns information for
  the storage within the solver \emph{interface}, i.e.~storage for the
  integers \id{last\_flag} and \id{first\_factorize}.  For additional
  space requirements, see the {\klu} documentation.
\item \id{SUNLinSolFree\_KLU}
\end{itemize}
The module {\sunlinsolklu} provides the following additional
user-callable routines: 
%%
\begin{itemize}

%%--------------------------------------

\item \ID{SUNKLU}

  This constructor function creates and allocates memory for a {\sunlinsolklu}
  object.  Its arguments are an {\nvector} and {\sunmatrix}, that it
  uses to determine the linear system size and to assess compatibility
  with the linear solver implementation. 

  This routine will perform consistency checks to ensure that it is
  called with consistent {\nvector} and {\sunmatrix} implementations.
  These are currently limited to the {\sunmatsparse} matrix type
  (using either CSR or CSC storage formats) and the {\nvecs},
  {\nvecopenmp}, and {\nvecpthreads} vector types.  As additional
  compatible matrix and vector implementations are added to
  {\sundials}, these will be included within this compatibility
  check. 

  If either \id{A} or \id{y} are incompatible then this routine will
  return \id{NULL}.

  \verb|SUNLinearSolver SUNKLU(N_Vector y, SUNMatrix A);|

%%--------------------------------------

\item \ID{SUNKLUReInit}

  This function reinitializes memory and flags for a new factorization
  (symbolic and numeric) to be conducted at the next solver setup
  call.  This routine is useful in the cases where the number of
  nonzeroes has changed or if the structure of the linear system has
  changed which would require a new symbolic (and numeric
  factorization). 

  The \id{reinit\_type} argument governs the level of
  reinitialization.  The allowed values are: 
  \begin{itemize}
  \item \texttt{SUNKLU\_REINIT\_FULL} -- The Jacobian matrix will be destroyed
    and a new one will be allocated based on the \id{nnz} value passed
    to this call.  New symbolic and numeric factorizations will be
    completed at the next solver setup. 
  \item \texttt{SUNKLU\_REINIT\_PARTIAL} -- Only symbolic and numeric 
    factorizations will be completed.  It is assumed that the Jacobian 
    size has not exceeded the size of \id{nnz} given in the sparse 
    matrix provided to the original constructor routine (or the
    previous \id{SUNKLUReInit} call). 
  \end{itemize}
  
  This routine assumes no other changes to solver use are necessary.

  The return values from this function are \id{SUNLS\_MEM\_NULL}
  (either \id{S} or \id{A} are \id{NULL}), \id{SUNLS\_ILL\_INPUT}
  (\id{A} does not have type \id{SUNMATRIX\_SPARSE} or
  \id{reinit\_type} is invalid), \id{SUNLS\_MEM\_FAIL} (reallocation
  of the sparse matrix failed) or \id{SUNLS\_SUCCESS}.
  
\begin{verbatim}
int SUNKLUReInit(SUNLinearSolver S, SUNMatrix A, 
                 sunindextype nnz, int reinit_type);
\end{verbatim}


%%--------------------------------------

\item \ID{SUNKLUSetOrdering}

  This function sets the ordering used by {\klu} for reducing fill in
  the linear solve.  Options for \id{ordering\_choice} are:
  \begin{itemize}
  \item[0] AMD,
  \item[1] COLAMD, and
  \item[2] the natural ordering.
  \end{itemize}
  The default is 1 for COLAMD.

  The return values from this function are \id{SUNLS\_MEM\_NULL}
  (\id{S} is \id{NULL}), \id{SUNLS\_ILL\_INPUT}
  (invalid \id{ordering\_choice}), or \id{SUNLS\_SUCCESS}.
  
  \verb|int SUNKLUSetOrdering(SUNLinearSolver S, int ordering_choice);|

\end{itemize}
%%
%%------------------------------------
%%
For solvers that include a Fortran interface module, the
{\sunlinsolklu} module also includes the Fortran-callable
function \id{FSUNKLUInit(code, ier)} to initialize this
{\sunlinsolklu} module for a given {\sundials} solver.  Here \id{code}
is an integer input solver id (1 for {\cvode}, 2 for {\ida}, 3 for {\kinsol},
4 for {\arkode}); \id{ier} is an error return flag equal to 0 for success
and -1 for failure. Both \id{code} and \id{ier}
are declared to match C type \id{int}. This
routine must be called \emph{after} both the {\nvector} and
{\sunmatrix} objects have been initialized.  Additionally, when using
{\arkode} with a non-identity mass matrix, the Fortran-callable function
\id{FSUNMassKLUInit(ier)} initializes this {\sunlinsolklu} module for
solving mass matrix linear systems.

The \id{SUNKLUReInit} and \ID{SUNKLUSetOrdering} routines also support
Fortran interfaces for the system and mass matrix solvers:
\begin{itemize}
\item \id{FSUNKLUReInit(code, NNZ, reinit\_type, ier)} -- \id{NNZ}
  should be commensurate with a C \id{long int} and \id{reinit\_type}
  should be commensurate with a C \id{int} (1 = `FULL', 2 = `PARTIAL')
\item \id{FSUNMassKLUReInit(NNZ, reinit\_type, ier)}
\item \id{FSUNKLUSetOrdering(code, ordering, ier)} -- \id{ordering}
  should be commensurate with a C \id{int}
\item \id{FSUNMassKLUSetOrdering(ordering, ier)}
\end{itemize}
