/*******************************************************************
 *                                                                 *
 * File          : idaband.c                                       *
 * Programmers   : Allan G. Taylor, Alan C. Hindmarsh, and         *
 *                 Radu Serban @ LLNL                              *
 * Version of    : 11 July 2002                                    *
 *-----------------------------------------------------------------*
 * Copyright (c) 2002, The Regents of the University of California * 
 * Produced at the Lawrence Livermore National Laboratory          *
 * All rights reserved                                             *
 * For details, see sundials/ida/LICENSE                           *
 *-----------------------------------------------------------------*
 * This is the implementation file for the IDA banded linear       *
 * solver module, IDABAND. This module uses standard banded        *
 * matrix techniques to solve the linear systems generated by the  *
 * (nonlinear) Newton iteration process of IDA. The user may       *
 * either supply a banded Jacobian routine or use the routine      *
 * supplied with this module (IDABandDQJac).                       *
 *                                                                 *
 *******************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "idaband.h"
#include "ida.h"
#include "band.h"
#include "sundialstypes.h"
#include "nvector.h"
#include "sundialsmath.h"


/* Error Messages */

#define IDABAND  "IDABand/IDAReInitBand-- "

#define MSG_IDAMEM_NULL  IDABAND "IDA memory is NULL.\n\n"

#define MSG_BAD_SIZES_1  IDABAND "Illegal bandwidth parameter(s) "
#define MSG_BAD_SIZES_2  "mlower = %ld, mupper = %ld.\n"
#define MSG_BAD_SIZES_3  "Must have 0 <=  mlower, mupper <= N-1 =%ld.\n\n"
#define MSG_BAD_SIZES    MSG_BAD_SIZES_1 MSG_BAD_SIZES_2 MSG_BAD_SIZES_3

#define MSG_MEM_FAIL     IDABAND "A memory request failed.\n\n"

#define MSG_WRONG_NVEC   IDABAND "Incompatible NVECTOR implementation.\n\n"

/* Constants */

#define ZERO         RCONST(0.0)
#define ONE          RCONST(1.0)
#define TWO          RCONST(2.0)



/******************************************************************
 *                                                                *           
 * Types : IDABandMemRec, IDABandMem                              *
 *----------------------------------------------------------------*
 * The type IDABandMem is pointer to an IDABandMemRec. This       *
 * structure contains IDABand solver-specific data.               *
 *                                                                *
 ******************************************************************/

typedef struct {

   IDABandJacFn b_jac;   /* jac = banded Jacobian routine to be called   */

   BandMat b_J;          /* J = dF/dy + cj*dF/dy', banded approximation. */
  
   integertype b_mupper;     /* mupper = upper bandwidth of Jacobian matrix. */

   integertype b_mlower;     /* mlower = lower bandwidth of Jacobian matrix. */

   integertype b_storage_mu; /* storage_mu = upper bandwidth with storage for
                            factoring = min(Neq-1, mupper+mlower).       */

   integertype *b_pivots;    /* pivots = pivot array for PJ = LU        */

   long int b_nje;       /* nje = no. of calls to jac               */
 
   void *b_jdata;        /* jdata = data structure required by jac. */

} IDABandMemRec, *IDABandMem;


/* IDABAND linit, lsetup, lsolve, and lfree routines */
 
static int IDABandInit(IDAMem ida_mem);

static int IDABandSetup(IDAMem ida_mem, N_Vector yyp, N_Vector ypp,
                        N_Vector resp, N_Vector tempv1,
                        N_Vector tempv2, N_Vector tempv3);

static int IDABandSolve(IDAMem ida_mem, N_Vector b, N_Vector ycur,
                        N_Vector ypcur, N_Vector rescur);

static int IDABandFree(IDAMem ida_mem);

static int IDABandDQJac(integertype Neq, integertype mupper, integertype mlower,
                        realtype tt, N_Vector yy, N_Vector yp, realtype cj,
                        N_Vector constraints, ResFn res, void *rdata,
                        void *jdata, N_Vector resvec, N_Vector ewt, realtype hh,
                        realtype uround, BandMat JJ, long int *nrePtr,
                        N_Vector tempv1, N_Vector tempv2, N_Vector tempv3);

/*************** IDABandDQJac ****************************************

 This routine generates a banded difference quotient approximation JJ
 to the DAE system Jacobian J.  It assumes that a band matrix of type
 BandMat is stored column-wise, and that elements within each column
 are contiguous.  The address of the jth column of JJ is obtained via
 the macros BAND_COL and BAND_COL_ELEM. The columns of the Jacobian are 
 constructed using mupper + mlower + 1 calls to the res routine, and
 appropriate differencing.
 The return value is either SUCCESS = 0, or the nonzero value returned
 by the res routine, if any.
**********************************************************************/

static int IDABandDQJac(integertype Neq, integertype mupper, integertype mlower,
                        realtype tt, N_Vector yy, N_Vector yp, realtype cj,
                        N_Vector constraints, ResFn res, void *rdata,
                        void *jdata, N_Vector resvec, N_Vector ewt, realtype hh,
                        realtype uround, BandMat JJ, long int *nrePtr,
                        N_Vector tempv1, N_Vector tempv2, N_Vector tempv3)

{
  realtype inc, inc_inv, yj, ypj, srur, conj, ewtj;
  realtype *y_data, *yp_data, *ewt_data, *cns_data = NULL;
  realtype *ytemp_data, *yptemp_data, *rtemp_data, *r_data, *col_j;
  int group, ngroups;
  
  N_Vector rtemp, ytemp, yptemp;
  integertype i, j, i1, i2, width;
  int retval = SUCCESS;

  rtemp = tempv1; /* Rename work vector for use as the perturbed residual. */

  ytemp = tempv2; /* Rename work vector for use as a temporary for yy. */


  yptemp= tempv3; /* Rename work vector for use as a temporary for yp. */

  /* Obtain pointers to the data for all eight vectors used.  */

  ewt_data = N_VGetData(ewt);
  r_data   = N_VGetData(resvec);
  y_data   = N_VGetData(yy);
  yp_data  = N_VGetData(yp);

  rtemp_data   = N_VGetData(rtemp);
  ytemp_data   = N_VGetData(ytemp);
  yptemp_data  = N_VGetData(yptemp);

  if (constraints != NULL) cns_data = N_VGetData(constraints);

  /* Initialize ytemp and yptemp. */

  N_VScale(ONE, yy, ytemp);
  N_VScale(ONE, yp, yptemp);

  /* Compute miscellaneous values for the Jacobian computation. */

  srur = RSqrt(uround);
  width = mlower + mupper + 1;
  ngroups = MIN(width, Neq);

  /* Loop over column groups. */
  for (group=1; group <= ngroups; group++) {

    /* Increment all yy[j] and yp[j] for j in this group. */

    for (j=group-1; j<Neq; j+=width) {
        yj = y_data[j];
        ypj = yp_data[j];
        ewtj = ewt_data[j];

        /* Set increment inc to yj based on sqrt(uround)*abs(yj), with
        adjustments using ypj and ewtj if this is small, and a further
        adjustment to give it the same sign as hh*ypj. */

        inc = srur*MAX(ABS(yj), MAX( ABS(hh*ypj), ONE/ewtj));
        if (hh*ypj < ZERO) inc = -inc;
        inc = (yj + inc) - yj;

        /* Adjust sign(inc) again if yj has an inequality constraint. */
        if (constraints != NULL) {
          conj = cns_data[j];
          if (ABS(conj) == ONE)      {if((yj+inc)*conj <  ZERO) inc = -inc;}
          else if (ABS(conj) == TWO) {if((yj+inc)*conj <= ZERO) inc = -inc;}
        }

        /* Increment yj and ypj. */

        ytemp_data[j] += inc;
        yptemp_data[j] += cj*inc;
    }

    /* Call res routine with incremented arguments. */
    (*nrePtr)++;
    retval = res(Neq, tt, ytemp, yptemp, rtemp, rdata);
    if (retval != SUCCESS) break;

    /* Loop over the indices j in this group again. */

    for (j=group-1; j<Neq; j+=width) {

      /* Reset ytemp and yptemp components that were perturbed. */

      yj = ytemp_data[j]  = y_data[j];
      ypj = yptemp_data[j] = yp_data[j];
      col_j = BAND_COL(JJ, j);
      ewtj = ewt_data[j];
      
      
      /* Set increment inc exactly as above. */
      
      inc = srur*MAX(ABS(yj),MAX( ABS(hh*ypj), ONE/ewtj));
      if (hh*ypj < ZERO) inc = -inc;
      inc = (yj + inc) - yj;
      if (constraints != NULL) {
        conj = cns_data[j];
        if (ABS(conj) == ONE)      {if((yj+inc)*conj <  ZERO) inc = -inc;}
        else if (ABS(conj) == TWO) {if((yj+inc)*conj <= ZERO) inc = -inc;}
      }
      
      /* Load the difference quotient Jacobian elements for column j. */

      inc_inv = ONE/inc;
      i1 = MAX(0, j-mupper);
      i2 = MIN(j+mlower,Neq-1);
      
      for (i=i1; i<=i2; i++) 
            BAND_COL_ELEM(col_j,i,j) = inc_inv*(rtemp_data[i]-r_data[i]);
    }
    
  }
  
  return(retval);
  
}

/* Readability Replacements */

#define Neq         (ida_mem->ida_Neq)
#define res         (ida_mem->ida_res)
#define rdata       (ida_mem->ida_rdata)
#define uround      (ida_mem->ida_uround)
#define tn          (ida_mem->ida_tn)
#define hh          (ida_mem->ida_hh)
#define cj          (ida_mem->ida_cj)
#define cjratio     (ida_mem->ida_cjratio)
#define ewt         (ida_mem->ida_ewt)
#define constraints (ida_mem->ida_constraints)
#define nre         (ida_mem->ida_nre)
#define errfp       (ida_mem->ida_errfp)
#define iopt        (ida_mem->ida_iopt)
#define linit       (ida_mem->ida_linit)
#define lsetup      (ida_mem->ida_lsetup)
#define lsolve      (ida_mem->ida_lsolve)
#define lperf       (ida_mem->ida_lperf)
#define lfree       (ida_mem->ida_lfree)
#define lmem        (ida_mem->ida_lmem)
#define machenv     (ida_mem->ida_machenv)
#define setupNonNull  (ida_mem->ida_setupNonNull)

#define jac         (idaband_mem->b_jac)
#define JJ          (idaband_mem->b_J)
#define storage_mu  (idaband_mem->b_storage_mu)
#define pivots      (idaband_mem->b_pivots)
#define nje         (idaband_mem->b_nje)
#define jacdata     (idaband_mem->b_jdata)
 
                  
/*************** IDABand *********************************************

 This routine initializes the memory record and sets various function
 fields specific to the IDABAND linear solver module.
 IDABand first calls the existing lfree routine if this is not NULL.
 Then it sets the ida_linit, ida_lsetup, ida_lsolve, ida_lperf, and
 ida_lfree fields in (*IDA_mem) to be IDABandInit, IDABandSetup,
 IDABandSolve, NULL, and IDABandFree, respectively.
 It allocates memory for a structure of type IDABandMemRec and sets
 the ida_lmem field in (*IDA_mem) to the address of this structure.
 It sets setupNonNull in (*IDA_mem) to TRUE, sets the b_jdata field in
 the IDABandMemRec structure to be the input parameter jdata, and sets
 the b_jac field to be:
   (1) the input parameter bjac, if bjac != NULL, or
   (2) IDABandDQJac, if bjac == NULL.
 Finally, it allocates memory for JJ and pivots.
 IDABand returns SUCCESS = 0, LMEM_FAIL = -1, or LIN_ILL_INPUT = -2.

 NOTE: The band linear solver assumes a serial implementation
       of the NVECTOR package. Therefore, IDABand will first 
       test for compatible a compatible N_Vector internal
       representation by checking (1) the machine environment
       ID tag and (2) that the functions N_VMake, N_VDispose,
       N_VGetData, and N_VSetData are implemented.

**********************************************************************/

int IDABand(void *IDA_mem, integertype mupper, integertype mlower,
            IDABandJacFn bjac, void *jdata)
{
  IDAMem ida_mem;
  IDABandMem idaband_mem;
  int flag;

  /* Return immediately if IDA_mem is NULL. */
  ida_mem = (IDAMem) IDA_mem;
  if (ida_mem == NULL) {
    fprintf(errfp, MSG_MEM_FAIL);
    return(LMEM_FAIL);
  }

  /* Test if the NVECTOR package is compatible with the BAND solver */
  if ((strcmp(machenv->tag,"serial")) || 
      machenv->ops->nvmake    == NULL || 
      machenv->ops->nvdispose == NULL ||
      machenv->ops->nvgetdata == NULL || 
      machenv->ops->nvsetdata == NULL) {
    fprintf(errfp, MSG_WRONG_NVEC);
    return(LIN_ILL_INPUT);
  }

  if (lfree != NULL) flag = lfree(ida_mem);

  /* Set five main function fields in ida_mem. */
  linit  = IDABandInit;
  lsetup = IDABandSetup;
  lsolve = IDABandSolve;
  lperf  = NULL;
  lfree  = IDABandFree;

  /* Get memory for IDABandMemRec. */
  lmem = idaband_mem = (IDABandMem) malloc(sizeof(IDABandMemRec));
  if (idaband_mem == NULL) {
    fprintf(errfp, MSG_MEM_FAIL);
    return(LMEM_FAIL);
  }

  /* Set Jacobian routine field to user's bjac or IDABandDQJac. */
  if (bjac == NULL) jac = IDABandDQJac;
  else jac = bjac;
  setupNonNull = TRUE;
  jacdata = jdata;

  /* Test mlower and mupper for legality and load in memory. */
  if ((mlower < 0) || (mupper < 0) || (mlower >= Neq) || (mupper >= Neq)) {
    fprintf(errfp, MSG_BAD_SIZES, mlower, mupper, Neq-1);
    return(LIN_ILL_INPUT);
  }
  idaband_mem->b_mlower = mlower;
  idaband_mem->b_mupper = mupper;
    
  /* Set extended upper half-bandwidth for JJ (required for pivoting). */
  storage_mu = MIN(Neq-1, mupper + mlower);

  /* Allocate memory for JJ and pivot array. */
  JJ = BandAllocMat(Neq, mupper, mlower, storage_mu);
  if (JJ == NULL) {
    fprintf(errfp, MSG_MEM_FAIL);
    return(LMEM_FAIL);
  }
  pivots = BandAllocPiv(Neq);
  if (pivots == NULL) {
    fprintf(errfp, MSG_MEM_FAIL);
    BandFreeMat(JJ);
    return(LMEM_FAIL);
  }  

  return(SUCCESS);
}


/*************** IDAReInitBand****************************************

 This routine resets the link between the main IDA module and the
 band linear solver module IDABAND.  No memory freeing or allocation
 operations are done, as the existing linear solver memory is assumed
 sufficient.  All other initializations are the same as in IDABand.
 The return value is SUCCESS=0, LMEM_FAIL = -1, or LIN_ILL_INPUT = -2.

**********************************************************************/

int IDAReInitBand(void *IDA_mem, integertype mupper, integertype mlower,
                  IDABandJacFn bjac, void *jdata)
{
  IDAMem ida_mem;
  IDABandMem idaband_mem;

  /* Return immediately if IDA_mem is NULL. */
  ida_mem = (IDAMem) IDA_mem;
  if (ida_mem == NULL) {
    fprintf(errfp, MSG_MEM_FAIL);
    return(LMEM_FAIL);
   }

  /* Test if the NVECTOR package is compatible with the BAND solver */
  if ((strcmp(machenv->tag,"serial")) || 
      machenv->ops->nvmake    == NULL || 
      machenv->ops->nvdispose == NULL ||
      machenv->ops->nvgetdata == NULL || 
      machenv->ops->nvsetdata == NULL) {
    fprintf(errfp, MSG_WRONG_NVEC);
    return(LIN_ILL_INPUT);
  }

  /* Set five main function fields in ida_mem. */
  linit  = IDABandInit;
  lsetup = IDABandSetup;
  lsolve = IDABandSolve;
  lperf  = NULL;
  lfree  = IDABandFree;

  idaband_mem = lmem;  /* Use existing linear solver memory pointer. */

  /* Set Jacobian routine field to user's bjac or IDABandDQJac. */
  if (bjac == NULL) jac = IDABandDQJac;
  else jac = bjac;
  setupNonNull = TRUE;
  jacdata = jdata;

  /* Test mlower and mupper for legality and load in memory. */
  if ((mlower < 0) || (mupper < 0) || (mlower >= Neq) || (mupper >= Neq)) {
    fprintf(errfp, MSG_BAD_SIZES, mlower, mupper, Neq-1);
    return(LIN_ILL_INPUT);
  }
  idaband_mem->b_mlower = mlower;
  idaband_mem->b_mupper = mupper;
     
  /* Set extended upper half-bandwidth for JJ (required for pivoting). */
  storage_mu = MIN(Neq-1, mupper + mlower);

  return(SUCCESS);
}


/* More convenience definitions */
#define mlower      (idaband_mem->b_mlower)
#define mupper      (idaband_mem->b_mupper)


/*************** IDABandInit *****************************************

 This routine does remaining initializations specific to the IDABAND
 linear solver module.  It returns LINIT_OK = 0.

***********************************************************************/

static int IDABandInit(IDAMem ida_mem)
{
  IDABandMem idaband_mem;

  idaband_mem = (IDABandMem) lmem;

  /* Initialize nje and set workspace lengths. */
  nje = 0;
  if (iopt != NULL) {
    iopt[BAND_NJE] = nje;
    iopt[BAND_LRW] = Neq*(storage_mu + mlower + 1);
    iopt[BAND_LIW] = Neq;
  }
  
  return(LINIT_OK);
}


/*************** IDABandSetup ****************************************

 This routine does the setup operations for the IDABAND linear 
 solver module.  It calls the Jacobian evaluation routine,
 updates counters, and calls the band LU factorization routine.
 The return value is either
     SUCCESS = 0        if successful,
     LSETUP_ERROR_RECVR if the jac routine failed recoverably or the
                        LU factorization failed, or
     LSETUP_ERROR_NONRECVR if the jac routine failed unrecoverably.
**********************************************************************/

static int IDABandSetup(IDAMem ida_mem, N_Vector yyp, N_Vector ypp,
                         N_Vector resp, N_Vector tempv1, N_Vector tempv2,
                         N_Vector tempv3)
{
  int retval;
  integertype retfac;
  IDABandMem idaband_mem;
  
  idaband_mem = (IDABandMem) lmem;

  /* Increment nje counter. */
  nje++;

  if (iopt != NULL) iopt[BAND_NJE] = nje;

  /* Zero out JJ; call Jacobian routine jac; return if it failed. */
  BandZero(JJ);
  retval = jac(Neq, mupper, mlower, tn, yyp, ypp, cj, constraints, res, 
    rdata, jacdata, resp, ewt, hh, uround, JJ, &nre, tempv1, tempv2, tempv3);
  if (retval < 0) return(LSETUP_ERROR_NONRECVR);
  if (retval > 0) return(LSETUP_ERROR_RECVR);

  /* Do LU factorization of JJ; return success or fail flag. */
  retfac = BandFactor(JJ, pivots);

  if (retfac != SUCCESS) return(LSETUP_ERROR_RECVR);
  return(SUCCESS);
}



/*************** IDABandSolve ****************************************

 This routine handles the solve operation for the IDABAND linear
 solver module.  It calls the band backsolve routine, scales the
 solution vector according to cjratio, then returns SUCCESS = 0.

**********************************************************************/

static int IDABandSolve(IDAMem ida_mem, N_Vector b, N_Vector ycur,
                         N_Vector ypcur, N_Vector rescur)
{
  IDABandMem idaband_mem;
  realtype *bd;

  idaband_mem = (IDABandMem) lmem;
  
  bd = N_VGetData(b);
  BandBacksolve(JJ, pivots, bd);
  N_VSetData(bd, b);

  /* Scale the correction to account for change in cj. */
  if (cjratio != ONE) N_VScale(TWO/(ONE + cjratio), b, b);

  return(SUCCESS);
}



/*************** IDABandFree *****************************************

 This routine frees memory specific to the IDABAND linear solver.

**********************************************************************/

static int IDABandFree(IDAMem ida_mem)
{
  IDABandMem idaband_mem;

  idaband_mem = (IDABandMem) lmem;
  
  BandFreeMat(JJ);
  BandFreePiv(pivots);
  free(lmem);

  return(0);

}
