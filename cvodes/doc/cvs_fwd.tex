%===================================================================================
\chapter{Using CVODES for Forward Sensitivity Analysis}\label{s:forward}
%===================================================================================

This section describes the use of {\cvodes} to compute solution sensitivities using
forward sensitivity analysis. One of our main guiding principles was to design 
the {\cvodes} user interface for forward sensitivity analysis as an extension of
that for IVP integration. Assuming a user main program and user-defined support 
routines for IVP integration have already been defined, in order to perform 
forward sensitivity analysis the user only has to insert a few more calls 
into the main program and (optionally) define an additional routine which
computes the right-hand side of the sensitivity systems (\ref{e:sens_eqns}). 
The only departure from this philosophy is due to the \id{RhsFn} type definition
(\S\ref{ss:user_fct_sim}). Without changing the definition of this type, the
only way to pass values of the problem parameters to the ODE right-hand side
function is to require the user data structure \id{f\_data} to contain a pointer
to the array of real parameters $p$.

We begin with a brief overview, in the form of a skeleton user program.
Following that are detailed descriptions of the interface to the
various user-callable routines and of the user-supplied routines that were not already
described in \S\ref{s:simulation}.

%-------------------------------------------------
\section{A skeleton of the user's main program}\label{s:forward_usage}
%-------------------------------------------------

The following is a skeleton of the user's main program (or calling
program) as an application of {\cvodes}. The user program is to have these 
steps in the order indicated, unless otherwise noted.
For the sake of brevity, we defer many of the details to the later sections.
As in \S\ref{ss:skeleton_sim}, most steps are independent of the {\nvector}
implementation used; where this is not the case, usage specifications are given for the
two implementations provided with {\cvodes}: steps marked with {\p} correspond to 
{\nvecp}, while steps marked with {\s} correspond to {\nvecs}.
Differences between the user main program in \S\ref{ss:skeleton_sim} and
the one below start only at step (\ref{i:fwd_start}).

First, note that no additional header files need be included for forward sensitivity 
analysis beyond those for IVP solution (\S\ref{ss:skeleton_sim}).
%%
%%
\index{User main program!forward sensitivity analysis}
\begin{Steps}
  
\item 
  \textcolor{gray}{\bf {\p} Initialize MPI}

\item
  \textcolor{gray}{\bf Set problem dimensions}

\item
  \textcolor{gray}{\bf Initialize vector specification}

\item
  \textcolor{gray}{\bf Set intial values}
 
\item
  \textcolor{gray}{\bf Create {\cvodes} object}

\item
  \textcolor{gray}{\bf Set optional inputs}

\item
  \textcolor{gray}{\bf Allocate internal memory}

\item
  \textcolor{gray}{\bf Attach linear solver module}

\item
  \textcolor{gray}{\bf Set linear solver optional inputs}

\item \label{i:fwd_start}
  {\bf Define the sensitivity problem}

  $\centerdot$ Set \id{p}, an array of \id{Np} real parameters upon which the IVP depends 
  (both through its right-hand side and initial conditions). Only parameters
  with respect to which sensitivities are (potentially) desired need to 
  be included. Also set \id{pbar}, an array of \id{Np} scaling factors.
  
  $\centerdot$ Attach \id{p} to the user data structure \id{f\_data}. 
  For example, \id{f\_data->p = p;}
  
  $\centerdot$ Set \id{Ns}, the number of parameters with respect to which sensitivities
  are to be computed. \id{Ns} must not be larger than \id{Np};
  
  $\centerdot$ Set \id{plist}, an array of \id{Ns} integer flags to specify the parameters
  \id{p} with respect to which solution sensitivities are to be computed.
  
  Note that the names for \id{p}, \id{pbar}, \id{plist}, as well as the field
  {\em p} of \id{f\_data} are arbitrary, but they must agree with the arguments
  to \id{CVodeSensMalloc} below;

\item
  {\bf Set sensitvivity initial conditions}

  Set the \id{Ns} vectors \id{yS0[i]} of \id{N} initial values
  for sensitivities (for $i=0,\ldots,Ns-1$). 
  If an existing data array \id{ySdata} (of type \id{realtype**} and pointing to
  {\tt Ns} vectors of length {\tt N} each) contains the initial values
  {\tt yS0}, then use a macro of type \id{NVS\_MAKE} defined by the current 
  {\nvector} implementation:

  {\s} \id{NVS\_MAKE\_S(Ns, yS0, ySdata, nvSpec);}

  {\p} \id{NVS\_MAKE\_P(Ns, yS0, ySdata, nvSpec);}

  Otherwise, make the call \id{yS0 = }\Id{N\_VNew\_S}\id{(Ns, nvSpec);} 
  to create an array of \id{N\_Vector}s and load initial values for 
  sensitivities \id{yS0[i]} into the array given by:

  {\s} \id{NV\_DATA\_S(yS0[i])}

  {\p} \id{NV\_DATA\_P(yS0[i])}
  
\item
  {\bf Set sensitivity analysis optional inputs}

  Call \id{CVodeSetSens*} routines to change from their default values any
  optional inputs that control the behavior of {\cvodes} in computing forward 
  sensitivities.

\item
  {\bf Activate sensitivity calculations}

  Call \id{ier = }\Id{CVodeSensMalloc}\id{(\ldots);} to activate forward 
  sensitivity computations and allocate internal
  memory for {\cvodes} related to sensitivity calculations
  (see \S\ref{ss:sensi_malloc});

\item
  \textcolor{gray}{\bf Advance solution in time}

\item
  {\bf Extract sensitivity solution}

  After each successful return from \id{CVode}, the solution of the
  original IVP is available in the \id{y} argument of \id{CVode},
  while the sensitivity solution can be extracted into \id{yS} (which can 
  be the same as \id{yS0}) by calling the routine 
  \id{ier = }\Id{CVodeGetSens}\id{(cvode\_mem, t, yS);}
  (see \S\ref{ss:sensi_get});

\item
  \textcolor{gray}{\bf Deallocate memory for solution vector}

\item 
  {\bf Deallocate memory for sensitivity vectors}

  Upon completion of the integration, deallocate memory for the vectors \id{yS}. 
  If \id{yS} was created from \id{ysdata}, then use the implementation-dependent 
  {\nvector} deallocation macro:

  {\s} \id{NVS\_DISPOSE\_S(yS, Ns);}

  {\p} \id{NVS\_DISPOSE\_P(yS, Ns);}

  If \id{yS} was allocated through a call to \id{N\_VNew\_S} then deallocate
  it by calling \Id{N\_VFree\_S}\id{(Ns, yS);}
  
\item
  {\bf Free user data structure}

  Before freeing the pointer to the user-defined data block 
  \id{f\_data}, release the array containing the real parameters \id{p}:
  \id{free(f\_data->p); free(f\_data);}

\item
  \textcolor{gray}{\bf Free solver memory}
  
\item
  \textcolor{gray}{\bf Free vector specification memory}

\end{Steps}

%-------------------------------------------------------------------------------
\section{User-callable routines for forward sensitivity analysis}
%-------------------------------------------------------------------------------

This section describes the {\cvodes} functions, additional to those presented
in \S\ref{ss:cvodes_fct_sim}, that are called by the user to set up and solve
a forward sensitvity problem.

\subsection{Forward sensitivity initialization functions}
\label{ss:sensi_malloc}
%%
Activation of forward sensitivity computation is done through a call to the
function \id{CVodeSensMalloc}.
The form of the call to this routine is as follows:
%%
\ucfunction{CVodeSensMalloc}
{
  flag = CVodeSensMalloc(cvode\_mem, Ns, ism, p, plist, yS0);
}
{
  The routine \ID{CVodeSensMalloc} activates forward sensitivity computations and
  allocates internal memory related to sensitivity calculations.
}
{
  \begin{args}[cvode\_mem]

  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.

  \item[Ns] (\id{int}) 
    the number of sensitivities to be computed.

  \item[ism] (\id{int})
    \index{forward sensitivity analysis!correction strategies}
    a flag used to select the sensitivity solution method and can 
    be \id{SIMULTANEOUS}, \id{STAGGERED}, or \id{STAGGERED1}:
    \begin{itemize}
    \item In the \ID{SIMULTANEOUS} approach, the state and sensitivity variables are
      corrected at the same time. If \id{NEWTON} was selected as the nonlinear system 
      solution method, this amounts to performing a modified Newton iteration on the
      combined nonlinear system;
    \item In the \ID{STAGGERED} approach, the correction step for the sensitivity
      variables takes place at the same time for all sensitivity equations, but only after 
      the correction of the state variables has converged and the state variables 
      have passed the local error test; 
    \item In the \ID{STAGGERED1} approach, all corrections are done sequentially, first
      for the state variables and then for the sensitivity variables, one parameter at
      a time. If the sensitivity variables are not included in the error control, this 
      approach is equivalent to \id{STAGGERED}. Note that the \id{STAGGERED1} approach 
      can be used only if \id{ifS = ONESENS}.
    \end{itemize}

  \item[p] (id{realtype *})
    a pointer to the array of real problem parameters used to evaluate $f(t,y,p)$.
    The user data block \id{f\_data} must include a realtype pointer (e.g. \id{p})
    that points to \id{p}. For example, if the pointer to the data block has the 
    form \id{typedef struct}\{\id{\ldots, realtype *p;}\}\id{*f\_data;} 
    then \id{f\_data->p = p;} must point to the array in which 
    \id{p[i-1] =} $p_i$, for $i=1,\ldots,N_p$.
    
  \item[plist] (\id{int *}) 
    an array of \id{Ns} nonzero integer flags that serves two functions:
    it specifies parameter indeces in $\{1,\ldots,N_p\}$  
    with respect to which sensitivities are to be computed
    and indicates whether a given parameter affects the right-hand side of the original
    IVP or only its initial conditions.
    More specifically, a positive \id{j = plist[i]} indicates that the sensitivity
    of the solution with respect to the \id{j}-th parameter \id{p[j-1]} is to be computed.
    A negative \id{j = plist[i]} indicates that the sensitivity of the solution with
    respect to the (\id{-j})-th parameter \id{p[-j-1]} is to be computed and indicates
    that \id{p[-j-1]} does not enter $f(t,y,p)$ thus increasing the efficiency of the
    difference quotient approximation routine for sensitivity right-hand side evaluation.
    
  \item[yS0] (\id{N\_Vector}) 
    a pointer to an array of \id{Ns} vectors of length \id{N} containing the initial 
    values of the sensitivities.

  \end{args}
}
{
  The return flag \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[SCVM\_ILL\_INPUT]
  \item[\Id{SUCCESS}]
    The call to \id{CVodeSensMalloc} was successful.
  \item[\Id{SCVM\_NO\_MEM}] 
    The {\cvodes} memory block was not initialized through a 
    previous call to \id{CVodeCreate}.
  \item[\Id{SCVM\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{SCVM\_ILL\_INPUT}] 
    An input argument to \id{CVodeSensMalloc} has an illegal value.
  \end{args}
}
{
  Unlike the argument \id{y0} of \id{CVodeMalloc} - which could be deallocated
  by the user before the call to \id{CVode}, the space \id{yS0} is used during the
  integration of the sensitivity equations and should therefore not be deallocated 
  until after the last call to \id{CVode}.

  If an error occured, \id{CVodeSensMalloc} also prints an error message to the
  file specified by the optional input \id{errfp}.
}
%%
%%
The routine \ID{CVodeSensReInit}, useful during the solution of a sequence of problems of 
same size, reinitializes the sensitivity related internal memory 
and must follow a call to \Id{CVodeSensMalloc} (and maybe a call to \id{CVReInit}). 
The number \id{Ns} of sensitivities is assumed to be unchanged since the call to 
\Id{CVodeSensMalloc}.
%%
The call to the \id{CVodeSensReInit} function has the form:
%%
\ucfunction{CVodeSensReInit}
{
  flag = CVodeSensReInit(cvode\_mem, ism, p, plist, yS0);
}
{
  The routine \ID{CVodeSensReInit} reinitializaes forward sensitivity computations.
}
{
  \begin{args}[cvode\_mem]

  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.

  \item[ism] (\id{int})
    \index{forward sensitivity analysis!correction strategies}
    a flag used to select the sensitivity solution method and can 
    be \id{SIMULTANEOUS}, \id{STAGGERED}, or \id{STAGGERED1}.

  \item[p] (id{realtype *})
    a pointer to the array of real problem parameters used to evaluate $f(t,y,p)$.
    
  \item[plist] (\id{int *}) 
    an array of \id{Ns} nonzero integer flags that specifies the sensitivity parameter.
    
  \item[yS0] (\id{N\_Vector}) 
    a pointer to an array of \id{Ns} vectors of length \id{N} containing the initial 
    values of the sensitivities.

  \end{args}
}
{
  The return flag \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[SCVREI\_ILL\_INPUT]
  \item[\Id{SUCCESS}]
    The call to \id{CVodeReInit} was successful.
  \item[\Id{SCVREI\_NO\_MEM}] 
    The {\cvodes} memory block was not initialized through a 
    previous call to \id{CVodeCreate}.
  \item[\Id{SCVREI\_NO\_SENSI}]
    Memory space for sensitivity integration was not allocated through a 
    previous call to \id{CVodeSensMalloc}.
  \item[\Id{SCVREI\_ILL\_INPUT}] 
    An input argument to \id{CVodeSensReInit} has an illegal value.    
  \item[\Id{SCVREI\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \end{args}
}
{
  All arguments of \id{CVodeSensReInit} have the same meaning as those of
  \id{CVodeSensMalloc}.

  If an error occured, \id{CVodeSensReInit} also prints an error message to the
  file specified by the optional input \id{errfp}.
}

%--------------------------

\subsection{Forward sensitivity extraction functions}\label{ss:sensi_get}

If forward sensitivity computations have been initialized by a call to \id{CVodeSensMalloc},
or reinitialized by a call to \id{CVSensReInit}, then {\cvodes} computes both solution
and sensitivities at time \id{t}. However, \id{CVode} will still return only the solution
$y$ in \id{y}. Solution sensitivities can be obtained through one of the following functions:
%%
%%
\ucfunction{CVodeGetSens}
{
  flag = CVodeGetSens(cvode\_mem, t, yS);
}
{
  The function \id{CVodeGetSens} returns the sensitivity solution vectors after
  successful return from \id{CVode}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the memory previously allocated by \id{CVodeMalloc}.
  \item[t] (\id{realtype})
    specifies the time at which quadrature information is 
    requested. The time \id{t} must fall within the interval defined by the last 
    succesful step taken by {\cvodes}.
  \item[yS] (\id{N\_Vector *})
    the computed forward sensitivity vectors.
  \end{args}
}
{
  The return value \id{flag} of \id{CVodeGetSens} is one of:
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}] 
    \id{CVodeGetSens} was successful.
  \item[\Id{CVG\_NO\_MEM}] 
    \id{cvode\_mem} was NULL.
  \item[\Id{CVG\_NO\_SENS}] 
    Forward sensitivity analysis was not initialized.
  \item[\Id{BAD\_DKY}] 
    \id{yQ} is \id{NULL}.
  \item[\Id{BAD\_T}]
    The time \id{t} is not in the allowed range.
  \end{args}
}
{
  In case of an error return, an error message is also printed.  
}
%%
%%
The function \ID{CVodeGetSensDky} computes the \id{k}-th derivatives of the interpolating 
polynomials for the sensitivity variables at time \id{t}.
This function is called by \id{CVodeGetSens} with \id{k} $= 0$, but may also be called 
directly by the user.
%%
\ucfunction{CVodeGetSensDky}
{
  flag = CVodeGetSensDky(cvode\_mem, t, k, dkyS);
}
{
  The function \id{CVodeGetSensDky} returns derivatives of the sensitivity solution 
  vectors after successful return from \id{CVode}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the memory previously allocated by \id{CVodeMalloc}.
  \item[t] (\id{realtype})
    specifies the time at which quadrature information is 
    requested. The time \id{t} must fall within the interval defined by the last 
    succesful step taken by {\cvodes}.
  \item[k] (\id{int})
  \item[dkyS] (\id{N\_Vector *})
    the vectors continaing the derivatives. The space for dkyS must be allocated by 
    the user. 
  \end{args}
}
{
  The return value \id{flag} of \id{CVodeGetSensDky} is one of:
  \begin{args}
  \item[\Id{OKAY}] 
    \id{CVodeGetSensDky} succeeded.
  \item[\Id{CVG\_NO\_MEM}] 
    The pointer to \id{cvode\_mem} was NULL.
  \item[\Id{CVG\_NO\_SENS}] 
    Forward sensitivity analysis was not initialized.
  \item[\Id{BAD\_DKY}] 
    One of the vectors \id{dkyS} is \id{NULL}.
  \item[\Id{BAD\_K}]
    \id{k} is not in the range $0, 1, ..., q_u$.
  \item[\Id{BAD\_T}] 
    The time \id{t} is not in the allowed range.
  \end{args}
}
{
  In case of an error return, an error message is also printed.  
}
%%
%%
Forward sensitivity solution vectors can also be extracted separately for 
each parameter in turn through the functions \id{CVodeGetSens1} and
\id{CVodeGetSensDky1}, defined as follows:
\ucfunction{CVodeGetSens1}
{
  flag = CVodeGetSens1(cvode\_mem, t, is, yS);
}
{
  The function \id{CVodeGetSens1} returns the \id{is}-th sensitivity solution vector
  after successful return from \id{CVode}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the memory previously allocated by \id{CVodeMalloc}.
  \item[t] (\id{realtype})
    specifies the time at which quadrature information is 
    requested. The time \id{t} must fall within the interval defined by the last 
    succesful step taken by {\cvodes}.
  \item[is] (\id{int}) specifies which sensitivity vector is to be returned
    ($0\le$\id{is}<$N_s$).
  \item[yS] (\id{N\_Vector})
    the computed forward sensitivity vector.
  \end{args}
}
{
  The return value \id{flag} of \id{CVodeGetSens1} is one of:
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}]
    \id{CVodeGetSens1} was successful.
  \item[\Id{CVG\_NO\_MEM}] 
    \id{cvode\_mem} was NULL.
  \item[\Id{CVG\_NO\_SENS}] 
    Forward sensitivity analysis was not initialized.
  \item[\Id{BAD\_IS}]
    The index \id{is} is not in the allowed range.
  \item[\Id{BAD\_DKY}] 
    \id{yQ} is \id{NULL}.
  \item[\Id{BAD\_T}] 
    The time \id{t} is not in the allowed range.
  \end{args}
}
{
  In case of an error return, an error message is also printed.  
}
%%
%%
\ucfunction{CVodeGetSensDky1}
{
  flag = CVodeGetSensDky1(cvode\_mem, t, k, is, dkyS);
}
{
  The function \id{CVodeGetSensDky1} returns the \id{k}-th derivative of the 
  \id{is}-th sensitivity solution vector after successful return from \id{CVode}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the memory previously allocated by \id{CVodeMalloc}.
  \item[t] (\id{realtype})
    specifies the time at which quadrature information is 
    requested. The time \id{t} must fall within the interval defined by the last 
    succesful step taken by {\cvodes}.
  \item[k] (\id{int})
  \item[is] (\id{int}) specifies which sensitivity derivative vector is to be returned
    ($0\le$\id{is}<$N_s$).
  \item[dkyS] (\id{N\_Vector})
    the vector continaing the derivative. The space for dkyS must be allocated by 
    the user. 
  \end{args}
}
{
  The return value \id{flag} of \id{CVodeGetSensDky1} is one of:
  \begin{args}
  \item[\Id{OKAY}] 
    \id{CVodeGetQuadDky1} succeeded.
  \item[\Id{CVG\_NO\_MEM}] 
    The pointer to \id{cvode\_mem} was NULL.
  \item[\Id{CVG\_NO\_SENS}] 
    Forward sensitivity analysis was not initialized.
  \item[\Id{BAD\_DKY}] 
    One of the vectors \id{dkyS} is \id{NULL}.
  \item[\Id{BAD\_IS}]
    The index \id{is} is not in the allowed range.
  \item[\Id{BAD\_K}] 
    \id{k} is not in the range $0, 1, ..., q_u$.
  \item[\Id{BAD\_T}] 
    The time \id{t} is not in the allowed range.
  \end{args}
}
{
  In case of an error return, an error message is also printed.  
}
%%
%%

%--------------------------
\subsection{Optional inputs for forward sensitivity analysis}
\label{ss:sens_optional_input}

Optional input variables that control the computation of sensitivities
can be changed from their default values through calls to \id{CVodeSetSens*}
functions. Table~\ref{t:optional_input_fwd} lists all forward sensitivity 
optional input functions in {\cvodes} which are described in detail in the 
remainder of this section. 
%%
%%
\begin{table}
\centering
\caption{Forward sensitivity optional inputs}
\label{t:optional_input_fwd}
\medskip
\begin{tabular}{|l|l|l|}\hline
{\bf Optional input} & {\bf Routine name} & {\bf Default} \\
\hline
Sensitivity right-hand side routine & \id{CVodeSetSensRhsFn} & internal DQ \\
Sensitivity right-hand side routine & \id{CVodeSetSensRhs1Fn} & internal DQ \\
Data for sensitivity right-hand side routine & \id{CVodeSetSensFdata} & NULL \\
Sensitivity scaling factors & \id{CVodeSetSensPbar} & \id{NULL} \\
Type of DQ approximation & \id{CVodeSetSensRho} & \id{0.0} \\
Error control strategy & \id{CVodeSetSensErrCon} & \id{FALSE} \\
Sensitivity integration tolerances & \id{CVodeSetSensTolerances} & estimated \\
Maximum no. of nonlinear iterations & \id{CVodeSetSensMaxNonlinIters} & 3 \\
\hline
\end{tabular}
\end{table}
%%
%%
\ucfunction{CVodeSetSensRhsFn}
{
  flag = CVodeSetSensRhsFn(cvode\_mem, fS);
}
{
  The function \ID{CVodeSetSensRhsFn} specifies the user-supplied {\C} function
  to evaluate the sensitivity right-hand sides (for all parameters at once).
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[fS] (\id{SensRhsFn})
    user-defined sensitivity right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVS\_NO\_MEM]
  \item[\Id{SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVS\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  This type of sensitivity right-hand side function is not compatible with
  with the \id{STAGGERED1} sensitivity solution method (argument \id{ism}
  to \id{CVodeSensMalloc}). The compatibility test is performed at the first
  step in \id{CVode}.

  Passing \id{fS}$=$\id{NULL} indicates using the default internal difference 
  quotient sensitivity right-hand side routine.
}
%%
\ucfunction{CVodeSetSensRhsFn1}
{
  flag = CVodeSetSensRhs1Fn(cvode\_mem, fS);
}
{
  The function \ID{CVodeSetSensRhs1Fn} specifies the user-supplied {\C} function
  to evaluate the sensitivity right-hand sides (one parameter at a time).
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[fS] (\id{SensRhs1Fn})
    user-defined sensitivity right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVS\_NO\_MEM]
  \item[\Id{SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVS\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  This type of sensitivity right-hand side function {\em must} be used when
  the \id{STAGGERED1} sensitivity solution method is selected through
  \id{CVodeSensMalloc}, but can also be used with the other two choices
  (\id{SIMULTANEOUS} and \id{STAGGERED}).

  Passing \id{fS}$=$\id{NULL} indicates using the default internal difference 
  quotient sensitivity right-hand side routine.
}
%%
%%
\ucfunction{CVodeSetSensFdata}
{
  flag = CVodeSetSensFdata(cvode\_mem, fS\_data);
}
{
  The function \ID{CVodeSetSensFdata} specifies the user data block 
  for use by the user sensitivity right-hand side function and attaches 
  it to the main {\cvodes} memory block.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[fS\_data] (\id{void *})
    pointer to the user data.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVS\_NO\_MEM]
  \item[\Id{SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVS\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  If \id{fS\_data} is not specified, a \id{NULL} pointer is
  passed to the user sensitivity right-hand side function.

  The pointer \id{fS\_data} can be the same as the pointer \id{f\_data}
  specified through \id{CVodeSetFdata} (see \S\ref{ss:optional_input})
  and passed to the user right-hand side function $f$.
}
%%
%%
\ucfunction{CVodeSetSensPbar}
{
  flag = CVodeSetSensPbar(cvode\_mem, pbar);
}
{
  The function \ID{CVodeSetSensPbar} specifies an array of scaling factors for 
  the sensitivity variables.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[pbar] (\id{realtype *})
    pointer to the array of scaling factors.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVS\_NO\_MEM]
  \item[\Id{SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVS\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  Each \id{pbar[i]} must be set to a nonzero constant that is
  dimensionally consistent with \id{p[i]}.
  Typically, \id{pbar[i]}$=$\id{p[i]} whenever \id{p[i]} is nonzero.

  Passing \id{pbar}$=$\id{NULL} means using the default values
  ${\bar p}_i = 1.0, ~ i = 1,\ldots,N_p$.
}
%%
%%
\ucfunction{CVodeSetSensRho}
{
  flag = CVodeSetSensRho(cvode\_mem, rho);
}
{
  The function \ID{CVodeSetSensRho} specifies the difference quotient strategy in
  the case in which the right-hand side of the sensitivity equations are to
  be computed by {\cvodes}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[rho] (\id{realtype})
    value of the selection parameter.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVS\_NO\_MEM]
  \item[\Id{SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVS\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is \id{rho}$=0.0$. See \S\ref{ss:fwd_sensi} for
  details.
}
%%
%%
\ucfunction{CVodeSetSensErrCon}
{
  flag = CVodeSetSensErrCon(cvode\_mem, errconS);
}
{
  The function \ID{CVodeSetSensErrCon} specifies the error control
  strategy for sensitivity variables.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[errconS] (\id{booleantype})
    specifies whether sensitivity variables are included (\id{TRUE}) or not
    (\id{FALSE}) in the error control mechanism.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVS\_NO\_MEM]
  \item[\Id{SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVS\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  By default, \id{errconQ} is set to \id{FALSE}. 
  If \id{errcon}$=$\id{TRUE} then both state variables and
  sensitivity variables are included in the error tests. 
  If \id{errcon}$=$\id{FALSE} then the sensitivity variables are excluded from the 
  error tests. Note that, in any event, all variables are considered in the convergence 
  tests.
}
%%
%%
\ucfunction{CVodeSetSensTolerances}
{
  flag = CVodeSetSensTolerances(cvode\_mem, itolS, reltolS, abstolS);
}
{
  The function \ID{CVodeSetSensTolerances} specifies the integration tolerances for
  sensitivity variables.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[itolS]  (\id{int}) 
    is either \Id{SS} or \Id{SV}, where \Id{itolS}$=$\id{SS} indicates scalar relative error 
    tolerance and scalar absolute error tolerance, while \id{itolS}$=$\id{SV} indicates scalar
    relative error tolerance and vector absolute error tolerance. 
  \item[reltolS] (\id{realtype *})
    \index{tolerances}
    is a pointer to the relative error tolerance.
  \item[abstolS] (\id{void *})
    is a pointer to the absolute error tolerance.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVS\_ILL\_INPUT]
  \item[\Id{SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVS\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVS\_ILL\_INPUT}]
     An input argument to \id{CVodeSetSensTolerances} has an illegal value.
  \end{args}
}
{
  The default behavior is for  {\cvodes} to estimated appropriate integration 
  tolerances for the sensitivity variables based on the state tolerances and
  the scaling factors ${\bar p}$. See \S\ref{ss:fwd_sensi} for details.
}
%%
%%
\ucfunction{CVodeSetSensMaxNonlinIters}
{
  flag = CVodeSetSensMaxNonlinIters(cvode\_mem, maxcorS);
}
{
  The function \ID{CVodeSetSensMaxNonlinIters} specifies the maximum
  number of nonlinear solver iterations for sensitivity varaibles at one step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[maxcorS] (\id{int})
    maximum number of nonlinear solver iterations allowed on one step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVS\_NO\_MEM]
  \item[\Id{SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVS\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $3$.
}
%%
%%
%%--------------------------

\subsection{Optional outputs for forward sensitivity analysis}
\label{ss:sens_optional_output}

Optional output functions that return statistics and solver performance information
related to forward sensitivity computations are listed in Table~\ref{t:optional_output_fwd}
and described in detail in the remainder of this section.
%%
%%
\begin{table}
\centering
\caption{Forward sensitivity optional outputs}
\label{t:optional_output_fwd}
\medskip
\begin{tabular}{|l|l|}\hline
{\bf Optional output} & {\bf Routine name} \\
\hline
No. of calls to sensitivity r.h.s. function & \id{CVodeGetNumSensRhsEvals} \\
No. of calls to r.h.s. function for sensitivity& \id{CVodeGetNumRhsEvalsSens} \\
No. of sensitivity local error test failures & \id{CVodeGetNumSensErrTestFails} \\
No. of calls to lin. solv. setup routine for sens.& \id{CVodeGetNumSensLinSolvSetups} \\
Error weight vector for sensitivity variables & \id{CVodeGetSensErrWeights} \\
No. of sens. nonlinear solver iterations& \id{CVodeGetNumSensNonlinSolvIters} \\
No. of sens. convergence failures& \id{CVodeGetNumSensNonlinSolvConvFails} \\ 
No. of staggered nonlinear solver iterations& \id{CVodeGetNumStgrSensNonlinSolvIters} \\
No. of staggered convergence failures& \id{CVodeGetNumStgrSensNonlinSolvConvFails} \\ 
\hline
\end{tabular}
\end{table}
%%
%%
\ucfunction{CVodeGetNumSensRhsEvals}
{
  flag = CVodeGetNumSensRhsEvals(cvode\_mem, \&nfSevals);
}
{
  The function \ID{CVodeGetNumSensRhsEvals} returns the number of calls to the sensitivity
  right-hand side evalauation function.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfSevals] (\id{long int})
    number of calls to the sensitivity right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}] 
    The optional output value has been successfully set.
  \item[\Id{CVG\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVG\_NO\_SENS}]
    Forward sensitivity analysis was not initialized.
  \end{args}
}
{
  In order to accomodate any of the three possible sensitivity solution methods,
  the default internal 
  finite difference quotient functions evaluate the sensitivity right-hand sides 
  one at a time. Therefore, \id{nfSevals} will allways be a multiple of the
  number of sensitivity parameters (the same as the case in which the user supplies
  a routine of type \id{SensRhs1Fn}).
}
%%
%%
\ucfunction{CVodeGetNumRhsEvalsSens}
{
  flag = CVodeGetNumRhsEvalsSens(cvode\_mem, \&nfevalsS);
}
{
  The function \ID{CVodeGetNumRhsEvalsSEns} returns the number of calls to the
  user's right-hand side evalauation function due to finite difference approximation
  of the sensitivity right-hand sides.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfevalsS] (\id{long int})
    number of calls to the user right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}] 
    The optional output value has been successfully set.
  \item[\Id{CVG\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVG\_NO\_SENS}]
    Forward sensitivity analysis was not initialized.
  \end{args}
}
{
  This counter is incremented only if the internal finite difference approximation
  routines are used for the evaluation of the sensitivity right-hand sides.
}
%%
%%
\ucfunction{CVodeGetNumSensErrTestFails}
{
  flag = CVodeGetNumSensErrTestFails(cvode\_mem, \&nSetfails);
}
{
  The function \ID{CVodeGetNumSensErrTestFails} returns the number of local
  error test failures for the sensitivity variables that have occured.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nSetfails] (\id{long int})
    number of error test failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}] 
    The optional output value has been successfully set.
  \item[\Id{CVG\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVG\_NO\_SENS}]
    Forward sensitivity analysis was not initialized.
  \end{args}
}
{
  This counter is incremented only if the sensitivity variables have been included
  in the error test (see \id{CVodeSetSensErrCon} in \S\ref{ss:sens_optional_input}). 
  Even in that case, this counter is not incremented if the \id{ism}$=$\id{SIMULTANEOUS} 
  sensitivity solution method has been used.
}
%%
%%
\ucfunction{CVodeGetNumSensLinSolvSetups}
{
  flag = CVodeGetNumSensLinSolvSetups(cvode\_mem, \&nlinsetupsS);
}
{
  The function \ID{CVodeGetNumSensLinSolvSetups} returns the number of calls
  to the linear solver setup function due to forward sensitivity calculations.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nlinsetupsS] (\id{long int})
    number of calls to the linear solver setup function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}] 
    The optional output value has been successfully set.
  \item[\Id{CVG\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVG\_NO\_SENS}]
    Forward sensitivity analysis was not initialized.
  \end{args}
}
{
  This counter is incremented only if Newton iteration has been used and if
  either the \id{ism}$=$\id{STAGGERED} or the \id{ism}$=$\id{STAGGERED1} sensitivity
  solution method has been specified in the call to \id{CVodeSensMalloc}
  (see \S\ref{ss:sensi_malloc}).
}
%%
%%
\ucfunction{CVodeGetSensStats}
{
  \begin{tabular}[t]{@{}r@{}l@{}}
    flag = CVodeGetSensStats(&cvode\_mem, \&nfSevals, \&nfevalsS, \\
                             &\&nSetfails, \&nlinsetupsS);
  \end{tabular}
}
{
  The function \ID{CVodeGet} returns all of the above sensitivity-related solver
  statistics as a group.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfSevals] (\id{long int})
    number of calls to the sensitivity right-hand side function.
  \item[nfevalsS] (\id{long int})
    number of calls to the user right-hand side function.
  \item[nSetfails] (\id{long int})
    number of error test failures.
  \item[nlinsetupsS] (\id{long int})
    number of calls to the linear solver setup function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}] 
    The optional output value has been successfully set.
  \item[\Id{CVG\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVG\_NO\_SENS}]
    Forward sensitivity analysis was not initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetSensErrWeights}
{
  flag = CVodeGetSensErrWeights(cvode\_mem, \&eSweight);
}
{
  The function \ID{CVodeGetSensErrWeights} returns the sensitivity error weights at the
  current time. These are the reciprocals of the $W_i$ of (\ref{e:errwt}) for the
  sensitivity variables.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[eSweight] (\id{N\_Vector\_S})
    pointer to the array of error weight vectors.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}] 
    The optional output value has been successfully set.
  \item[\Id{CVG\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVG\_NO\_SENS}]
    Forward sensitivity analysis was not initialized.
  \end{args}
}
{
  The user need not allocate space for \id{eSweight} and should not modify
  any of its components.
}
%%
%%
\ucfunction{CVodeGetNumSensNonlinSolvIters}
{
  flag = CVodeGetNumSensNonlinSolvIters(cvode\_mem, \&nSniters);
}
{
  The function \ID{CVodeGetNumSensNonlinSolvIters} returns the
  number of nonlinear (functional or Newton) iterations performed for 
  sensitivity calculations.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nSniters] (\id{long int})
    number of nonlinear iterations performed.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}] 
    The optional output value has been successfully set.
  \item[\Id{CVG\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVG\_NO\_SENS}]
    Forward sensitivity analysis was not initialized.
  \end{args}
}
{
  This counter is incremented only if either the \id{ism}$=$\id{STAGGERED} or 
  the \id{ism}$=$\id{STAGGERED1} sensitivity solution method has been specified 
  in the call to \id{CVodeSensMalloc} (see \S\ref{ss:sensi_malloc}).
  
  In the \id{STAGGERED1} case, the value of \id{nSniters} is the sum of 
  the number of nonlinear iterations performed for each sensitivity equation.
  These individual counters can be obtained through a call to
  \id{CVodeGetNumStgrSensNonlinSolvIters} (see below).
}
%%
%%
\ucfunction{CVodeGetNumSensNonlinSolvConvFails}
{
  flag = CVodeGetNumSensNonlinSolvConvFails(cvode\_mem, \&nSncfails);
}
{
  The function \ID{CVodeGetNumSensNonlinSolvConvFails} returns the
  number of nonlinear convergence failures that have occurred for
  sensitivity calculations.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nSncfails] (\id{long int})
    number of nonlinear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}] 
    The optional output value has been successfully set.
  \item[\Id{CVG\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVG\_NO\_SENS}]
    Forward sensitivity analysis was not initialized.
  \end{args}
}
{
  This counter is incremented only if either the \id{ism}$=$\id{STAGGERED} or 
  the \id{ism}$=$\id{STAGGERED1} sensitivity solution method has been specified 
  in the call to \id{CVodeSensMalloc} (see \S\ref{ss:sensi_malloc}).
  
  In the \id{STAGGERED1} case, the value of \id{nSncfails} is the sum of 
  the number of nonlinear convergence failures that occured for each sensitivity equation.
  These individual counters can be obtained through a call to
  \id{CVodeGetNumStgrSensNonlinConvFails} (see below).
}
%%
%%
\ucfunction{CVodeGetSensNonlinSolvStats}
{
  flag = CVodeGetSensNonlinSolvStats(cvode\_mem, \&nSniters, \&nSncfails);
}
{
  The function \ID{CVodeGetSensNonlinSolvStats} returns the sensitivity-related
  nonlinear solver statistics as a group.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nSniters] (\id{long int})
    number of nonlinear iterations performed.
  \item[nSncfails] (\id{long int})
    number of nonlinear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}] 
    The optional output value has been successfully set.
  \item[\Id{CVG\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVG\_NO\_SENS}]
    Forward sensitivity analysis was not initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetNumStgrSensNonlinSolvIters}
{
  flag = CVodeGetNumStgrSensNonlinSolvIters(cvode\_mem, nSTGR1niters);
}
{
  The function \ID{CVodeGetNumStgrSensNonlinSolvIters} returns the
  number of nonlinear (functional or Newton) iterations performed for 
  each sensitivity equation separately, in the \id{STAGGERED1} case.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nSTGR1niters] (\id{long int *})
    pointer to an array (of dimension \id{Ns}) containing the number of 
    nonlinear iterations performed.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}] 
    The optional output value has been successfully set.
  \item[\Id{CVG\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVG\_NO\_SENS}]
    Forward sensitivity analysis was not initialized.
  \end{args}
}
{
  The user need not allocate space for \id{nSTGR1niters} and should not modify
  any of its components.
}
%%
%%
\ucfunction{CVodeGetNumStgrSensNonlinSolvConvFails}
{
  flag = CVodeGetNumStgrSensNonlinSolvConvFails(cvode\_mem, nSTGR1ncfails);
}
{
  The function \ID{CVodeGetNumStgrSensNonlinSolvConvFails} returns the
  number of nonlinear convergence failures that have occurred for
  each sensitivity equation separately, in the \id{STAGGERED1} case.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nSTGR1ncfails] (\id{long int *})
    pointer to an array (of dimension \id{Ns}) containing the 
    number of nonlinear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}] 
    The optional output value has been successfully set.
  \item[\Id{CVG\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVG\_NO\_SENS}]
    Forward sensitivity analysis was not initialized.
  \end{args}
}
{
  The user need not allocate space for \id{nSTGR1ncfails} and should not modify
  any of its components.
}
%%
%%
\ucfunction{CVodeGetStgrSensNonlinSolvStats}
{
  \begin{tabular}[t]{@{}r@{}l@{}}
    flag = CVodeGetStgrSensNonlinSolvStats(&cvode\_mem, \\
                                           &nSTGR1niters, nSTGR1ncfails);
  \end{tabular}
}
{
  The function \ID{CVodeGetSensNonlinSolvStats} returns the sensitivity-related
  nonlinear solver statistics as a group, in the \id{STAGGERED1} case.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nSTGR1niters] (\id{long int *})
    pointer to an array (of dimension \id{Ns}) containing the number of 
    nonlinear iterations performed.
  \item[nSTGR1ncfails] (\id{long int *})
    pointer to an array (of dimension \id{Ns}) containing the 
    number of nonlinear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVG\_NO\_SENS]
  \item[\Id{OKAY}] 
    The optional output value has been successfully set.
  \item[\Id{CVG\_NO\_MEM}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVG\_NO\_SENS}]
    Forward sensitivity analysis was not initialized.
  \end{args}
}
{}
%%
%%
%-------------------------------------------------------------------
\section{User-supplied routines for forward sensitivity analysis}
\label{s:user_fct_fwd}
%-------------------------------------------------------------------

In addition to the required and optional user-supplied routines described
in \S\ref{ss:user_fct_sim}, when using {\cvodes} for forward sensitivity analysis,
the user has the option of providing a routine that calculates the right-hand side 
of the sensitivity equations (\ref{e:sens_eqns}).

By default, {\cvodes} uses difference quotient approximation routines for the right
hand sides of the sensitivity equations.
However, {\cvodes} allows the option for user-defined sensitivity right-hand side routines
(which also provides a mechanism for interfacing {\cvodes} to routines
generated by automatic differentiation).

\subsubsection{Sensitivity equations right-hand side (all at once)}
\index{forward sensitivity analysis!right-hand side evaluation|(}
\index{right-hand side function!forward sensitivity|(}

If the \Id{SIMULTANEOUS} or \Id{STAGGERED} approach was selected in the call to
\id{CVodeSensMalloc}, the user may provide the right-hand sides of the sensitivity equations
(\ref{e:sens_eqns}), for all sensitivity parameters at once, through a function 
of type \ID{SensRhsFn} defined by
%%
\usfunction{SensRhsFn}
{
  typedef void (*SensRhsFn)(&int Ns, realtype t, \\
                            &N\_Vector y, N\_Vector ydot, \\ 
                            &N\_Vector *yS, N\_Vector *ySdot, \\
                            &void *fS\_data,  \\
                            &N\_Vector tmp1, N\_Vector tmp2);
}
{
  This function computes the sensitivity right-hand side for all sensitivity
  equations at once.
  It must compute the vectors $(\dfdyI) s_i(t) + (\dfdpiI)$ and store them in 
  \id{ySdot[i]}. 
}
{
  \begin{args}[fS\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the state vector, $y(t)$.
  \item[ydot]
    is the current value of the right-hand side of the state equations.
  \item[yS]
    contains the current values of the sensitivity vectors.
  \item[ySdot]
     is the output of \id{SensRhsFn}. On exit it must contain
    the sensitivity right-hand side vectors.
  \item[f\_data]
    is a pointer to user data - the same as the \Id{fS\_data}      
    parameter passed to \id{CVodeSetSensFdata}.
  \item[tmp1]
  \item[tmp2]
    are \id{N\_Vector}s which can be used as temporary storage.
  \end{args}
}
{
  A \id{SensRhsFn} function type does not have a return value.                        
}
{
  Note that a sensitivity right-hand side function of type \id{SensRhsFn} is not
  compatible with the \id{STAGGERED1} approach.

  Allocation of memory for \id{ySdot} is handled within {\cvodes}.
}

\subsubsection{Sensitivity equations right-hand side (one at a time)}
  
Alternatively, the user may provide the sensitivity right-hand sides, one sensitivity
parameter at a time through a function of type \ID{SensRhs1Fn}. 
Note that a sensitivity right-hand side function of type \id{SensRhs1Fn} is compatible 
with any legal value of the \id{CVodeSensMalloc} argument \id{ism}, and is 
required if \id{ism}$=$\Id{STAGGERED1}.
The type \id{SensRhs1Fn} is defined by
%%
\usfunction{SensRhs1Fn}
{
  typedef void (*SensRhs1Fn)(&int Ns, realtype t, \\
                             &N\_Vector y, N\_Vector ydot, \\ 
                             &int iS, N\_Vector yS, N\_Vector ySdot, \\
                             &void *fS\_data,  \\
                             &N\_Vector tmp1, N\_Vector tmp2);
}
{
  This function computes the sensitivity right-hand side for all one sensitivity
  equation at a time.
  It must compute the vector $(\dfdyI) s_i(t) + (\dfdpiI)$ for $i$=\id{iS} and 
  store it in \id{ySdot}. 
}
{
  \begin{args}[fS\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the state vector, $y(t)$.
  \item[ydot]
    is the current value of the right-hand side of the state equations.
  \item[iS]
    is the index of the parameter for which the sensitivity right-hand
    side must be computed.
  \item[yS]
    contains the current values of the \id{iS}-th sensitivity vector.
  \item[ySdot]
    is the output of \id{SensRhs1Fn}. On exit it must contain
    the \id{iS}-th sensitivity right-hand side vector.
  \item[f\_data]
    is a pointer to user data - the same as the \Id{fS\_data}      
    parameter passed to \id{CVodeSetSensFdata}.
  \item[tmp1]
  \item[tmp2]
    are \id{N\_Vector}s which can be used as temporary storage.
  \end{args}
}
{
  A \id{SensRhs1Fn} function type does not have a return value.                        
}
{
  Allocation of memory for \id{ySdot} is handled within {\cvodes}.
}

%%
%%-------------------------------------------------------------------
\section{Note on using partial error control}\label{ss:partial}
%%-------------------------------------------------------------------
%%
\index{partial error control!explanation of {\cvodes} behavior}
For some problems, when sensitivities are excluded from the error control test, 
the behavior of {\cvodes} may appear at first glance erroneous. One would
expect that, in such cases, the sensitivity variables will not influence in
any way the step size selection. A comparison of the solver diagnostics 
reported for the \id{cvdx} and the second run of the \id{cvfdx} example 
in \cite{cvodes1.1_ex} indicates that this may not always be the case.

The short explanation of this behavior is that the step size selection
implemented by the error control mechanism in {\cvodes} is based on the 
magnitude of the correction calculated by the nonlinear solver. As mentioned
in \S\ref{ss:sensi_malloc}, even with partial error control selected
in the call to \id{CVodeSensMalloc}, the sensitivity variables are included
in the convergence tests of the nonlinear solver.

When using the simultaneous corrector method (\S\ref{ss:fwd_sensi}) 
the nonlinear system that is solved at each step involves both the states
and sensitivity equations. In this case, it is easy to see how the sensitivity 
variables may affect the convergence rate of the nonlinear solver and therefore
the step size selection. 
The case of the staggered corrector approach is more subtle. 
After all, in this case (\id{ism=STAGGERED} or \id{ism=STAGGERED1} in the call 
to \id{CVodeSensMalloc}), the sensitivity variables at a given step are 
computed only once the solver for the nonlinear state equations has converged.
However, if the nonlinear system corresponding to the sensitivity equations
has convergence problems, {\cvodes} will attempt to improve the initial guess
by reducing the step size in order to provide a better prediction of the
sensitivity variables. Moreover, even if there are no convergence failures in
the solution of the sensitivity system, {\cvodes} may trigger a call to the
linear solver's setup routine which typically involves re-evaluation of Jacobian
information (Jacobian approximation in the case of {\cvdense} and {\cvband} or
preconditioner data in the case of {\cvspgmr}). The new Jacobian information
will be used by subsequent calls to the nonlinear solver for the state equations
and, in this way, potentially affect the step size selection.

When using the simultaneous corrector method it is not possible to decide whether 
nonlinear solver convergence failures or calls to the linear solver setup routine
have been triggered by convergence problems due to the state or the sensitivity 
equations.
When using one of the staggered corrector methods however, these situations can be 
identified by carefully monitoring the diagnostic information provided through 
optional outputs. If there are no convergence
failures in the sensitivity nonlinear solver and none
of the calls to the linear solver setup routine were made by the sensitivity
nonlinear solver then the step size selection is
not affected by the sensitivity variables.

Finally, the user must be warned that the effect of appending sensitivity 
equations to a given system of ODEs on the step size selection 
(through the mechanisms described above) is problem-dependent and can therefore
lead to either an increase or decrease of the total number of steps that {\cvodes} takes
to complete the simulation. At first glance, one would expect that the impact
of the sensitivity variables, if any, will be in the direction of increasing the
step size and therefore reducing the total number of steps. The argument for this
is that the presence of the sensitivity variables in the convergence test of the
nonlinear solver can only lead to additional iterations (and therefore a smaller
final correction) or to additional calls to the linear solver setup routine
(and therefore more up-to-date Jacobain information), both of which will lead
to larger steps being taken by {\cvodes}. However, this is true only locally.
Overall, a larger integration step taken at a given time may lead to 
step size reductions at later times (due to either nonlinear solver convergence
failures or error test failures).